<?xml version="1.0" encoding="utf-8"?>
<!--
============================================================================================================================================
D:\OSS\NetCoreGameEngine\src\EngineCore\EngineCore.csproj
============================================================================================================================================
-->
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" InitialTargets="_CheckForInvalidConfigurationAndPlatform">
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.props))\dir.props">

D:\OSS\NetCoreGameEngine\src\dir.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="..\dir.props">

D:\OSS\NetCoreGameEngine\dir.props
============================================================================================================================================
-->
  <!-- Import Microsoft.Common.Props -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
    <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonProps>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!-- 
        Import wildcard "ImportBefore" props files if we're actually in a 12.0+ project (rather than a project being
        treated as 4.0)
    -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' != ''">-->
  <!-- 
            Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props.d folder.
            This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
            the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory. Unfortunately, there
            is already a file named "Microsoft.Common.props" in this directory so we have to have a slightly different
            directory name to hold extensions.
        -->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')">

C:\Program Files (x86)\MSBuild\14.0\Imports\Microsoft.Common.props\ImportBefore\Microsoft.NuGet.ImportBefore.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NuGetProps Condition="'$(NuGetProps)'==''">$(MSBuildExtensionsPath)\Microsoft\NuGet\Microsoft.NuGet.props</NuGetProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetProps)" Condition="Exists('$(NuGetProps)')">

C:\Program Files (x86)\MSBuild\Microsoft\NuGet\Microsoft.NuGet.props
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.props" Condition="Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.props') AND '$(IncludeNuGetImports)' != 'false'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Imports\Microsoft.Common.props\ImportBefore\Microsoft.NuGet.ImportBefore.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!-- 
        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
        only forced 4.0 if that ToolsVersion did not exist.  

        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
        as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
        targets. 
   -->
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt;= '12.0')">
    <!--
           Reset VisualStudioVersion if it's 12.0+: Should be 10.0 if VS 2010 is installed or 11.0 otherwise, 
           but since we don't have a good way of telling whether VS 2010 is installed, make it 11.0 if 
           VS 2012 is installed or 10.0 otherwise.  The reset should be safe because if it was already 
           set to something (e.g. 11.0 in a VS 2012 command prompt) then MSBuild's internal 
           VisualStudioVersion-defaulting code should never come into the picture, so the only way it could 
           be 12.0+ when building a TV 12.0 project (because we're in this file) using MSBuild 4.5 (because 
           MSBuildAssemblyVersion hasn't been set) is if it's a TV 12.0 project on an empty command prompt. 
      -->
    <VisualStudioVersion Condition="Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">11.0</VisualStudioVersion>
    <VisualStudioVersion Condition="!Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">10.0</VisualStudioVersion>
  </PropertyGroup>
  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so override 
         the custom extensibility target locations with the hard-coded 4.0 equivalent. -->
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v4.0\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so import
         Microsoft.Common.props from the 4.0 location, and make sure everything else in here is 
         set up such that if it's defaulted to something there, it won't be overridden here. -->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props" Condition="'$(MSBuildAssemblyVersion)' == '' and Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')" />-->
  <PropertyGroup>
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!-- 
         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
         so there's no need to import them twice.
     -->
  <!--<Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />-->
  <!-- This is used to determine whether Microsoft.Common.targets needs to import 
         Microsoft.Common.props itself, or whether it has been imported previously,
         e.g. by the project itself. -->
  <PropertyGroup>
    <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
  </PropertyGroup>
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' and '$(DefaultProjectConfiguration)' != '' ">$(DefaultProjectConfiguration)</Configuration>
    <Platform Condition=" '$(Platform)' == '' and '$(DefaultProjectPlatform)' != '' ">$(DefaultProjectPlatform)</Platform>
  </PropertyGroup>
  <PropertyGroup>
    <WMSJSProject Condition="'$(WMSJSProject)' == ''">WJProject</WMSJSProject>
    <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />-->
  <!-- 
         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
         so there's no need to import them twice.
     -->
  <!--<Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />-->
  <!-- 
        Import wildcard "ImportAfter" props files if we're actually in a 12.0+ project (rather than a project being
        treated as 4.0)
    -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' != ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\dir.props
============================================================================================================================================
-->
  <!-- Project targeting defaults -->
  <PropertyGroup>
    <ProjectTypeGuids Condition="'$(ProjectTypeGuids)' == ''">
      {786C830F-07A1-408B-BD7F-6EE04809D6DB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}
    </ProjectTypeGuids>
    <TargetFrameworkVersion Condition="'$(TargetFrameworkVersion)' == ''">v5.0</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- Common repo directories -->
  <PropertyGroup>
    <ProjectDir>$(MSBuildThisFileDirectory)</ProjectDir>
    <SourceDir>$(ProjectDir)src/</SourceDir>
    <RefsDir>$(ProjectDir)refs/</RefsDir>
    <CommonPath>$(SourceDir)Common\src</CommonPath>
    <CommonTestPath>$(SourceDir)Common\tests</CommonTestPath>
    <!-- Output directories -->
    <BinDir Condition="'$(BinDir)'==''">$(ProjectDir)bin/</BinDir>
    <ObjDir Condition="'$(ObjDir)'==''">$(BinDir)obj/</ObjDir>
    <OutputPath>$(BinDir)$(Platform)/$(Configuration)</OutputPath>
    <IntermediateOutputPath>$(ObjDir)$(Platform)/$(Configuration)</IntermediateOutputPath>
    <!-- Input Directories -->
    <PackagesDir Condition="'$(PackagesDir)'==''">$(ProjectDir)packages/</PackagesDir>
  </PropertyGroup>
  <!-- 
  Projects that have no OS-specific implementations just use Debug and Release for $(Configuration).
  Projects that do have OS-specific implementations use OS_Debug and OS_Release, for all OS's we support even
  if the code is the same between some OS's (so if you have some project that just calls POSIX APIs, we still have
  OSX_[Debug|Release] and Linux_[Debug|Release] configurations.  We do this so that we place all the output under
  a single binary folder and can have a similar experience between the command line and Visual Studio.
  
  Since now have multiple *Debug and *Release configurations, ConfigurationGroup is set to Debug for any of the
  debug configurations, and to Release for any of the release configurations.
  -->
  <!-- Set default Configuration and Platform -->
  <PropertyGroup>
    <Platform Condition="'$(Platform)'==''">AnyCPU</Platform>
    <Configuration Condition="'$(Configuration)'==''">Debug</Configuration>
    <ConfigurationGroup Condition="$(Configuration.EndsWith('Debug'))">Debug</ConfigurationGroup>
    <ConfigurationGroup Condition="$(Configuration.EndsWith('Release'))">Release</ConfigurationGroup>
    <ConfigurationGroup Condition="'$(ConfigurationGroup)'==''">$(Configuration)</ConfigurationGroup>
  </PropertyGroup>
  <!-- Set up Default symbol and optimization for Configuration -->
  <PropertyGroup Condition="'$(ConfigurationGroup)' == 'Debug'">
    <DebugSymbols Condition="'$(DebugSymbols)' == ''">true</DebugSymbols>
    <Optimize Condition="'$(Optimize)' == ''">false</Optimize>
    <DebugType Condition="'$(DebugType)' == ''">full</DebugType>
    <DefineConstants>$(DefineConstants);DEBUG;TRACE</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ConfigurationGroup)' == 'Release'">
    <DebugSymbols Condition="'$(DebugSymbols)' == ''">true</DebugSymbols>
    <Optimize Condition="'$(Optimize)' == ''">true</Optimize>
    <DebugType Condition="'$(DebugType)' == ''">pdbonly</DebugType>
    <DefineConstants>$(DefineConstants);TRACE</DefineConstants>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\src\dir.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\src\EngineCore\EngineCore.csproj
============================================================================================================================================
-->
  <PropertyGroup>
    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{C29C63AB-7CFB-4EAA-BE26-9F225FB9E007}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>EngineCore</RootNamespace>
    <AssemblyName>EngineCore</AssemblyName>
    <NoWarn>3001;3003</NoWarn>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DefineConstants>$(DefineConstants);USE_SLEEP0</DefineConstants>
  </PropertyGroup>
  <!-- Default configurations to help VS understand the configurations -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' " />
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' " />
  <ItemGroup>
    <Compile Include="Components\Component.cs" />
    <Compile Include="Components\Transform.cs" />
    <Compile Include="Entities\Behaviour.cs" />
    <Compile Include="Graphics\DirectX\RenderableObjectBase.cs" />
    <Compile Include="Graphics\GameWindowResizedEventArgs.cs" />
    <Compile Include="Graphics\GraphicsSystem.cs" />
    <Compile Include="Graphics\ILightInfo.cs" />
    <Compile Include="Graphics\LightComponent.cs" />
    <Compile Include="Graphics\LightKind.cs" />
    <Compile Include="Graphics\OpenGL\BatchedOpenGLMeshInfo.cs" />
    <Compile Include="Graphics\OpenGL\GLEx.cs" />
    <Compile Include="Graphics\OpenGL\TextRenderer.cs" />
    <Compile Include="Graphics\OpenGL\TextureBuffer.cs" />
    <Compile Include="Graphics\DirectX\Direct3DMeshInfo.cs" />
    <Compile Include="Graphics\Texture2D.cs" />
    <Compile Include="Input\InputSystem.cs" />
    <Compile Include="Graphics\OpenGL\NativeWindowInputSystem.cs" />
    <Compile Include="Graphics\OpenGL\OpenGLGraphicsSystem.cs" />
    <Compile Include="Graphics\OpenGL\OpenGLMeshInfo.cs" />
    <Compile Include="Graphics\RenderableObjectInfo.cs" />
    <Compile Include="Input\KeyCode.cs" />
    <Compile Include="Input\MouseButton.cs" />
    <Compile Include="Physics\BoxCollider.cs" />
    <Compile Include="Physics\CharacterController.cs" />
    <Compile Include="Physics\Collider.cs" />
    <Compile Include="Physics\PhysicsExtensions.cs" />
    <Compile Include="Physics\SphereCollider.cs" />
    <Compile Include="Time.cs" />
    <Compile Include="Utility\Convert.cs" />
    <Compile Include="Entities\BoxRenderer.cs" />
    <Compile Include="GameObject.cs" />
    <Compile Include="Game.cs" />
    <Compile Include="Physics\BepuPhysicsSystem.cs" />
    <Compile Include="Entities\EntityUpdateSystem.cs" />
    <Compile Include="GameSystem.cs" />
    <Compile Include="GameSystemCollection.cs" />
    <Compile Include="Graphics\Color4f.cs" />
    <Compile Include="Graphics\SimpleVertex.cs" />
    <Compile Include="Graphics\IRenderable.cs" />
    <Compile Include="Graphics\PolyMesh.cs" />
    <Compile Include="Graphics\Camera.cs" />
    <Compile Include="Graphics\FpsTracker.cs" />
    <Compile Include="Entities\IUpdateableEntity.cs" />
    <Compile Include="Utility\MathUtil.cs" />
    <Compile Include="Utility\Resources.cs" />
    <Compile Include="Graphics\DirectX\DirectionalLight.cs" />
    <Compile Include="Graphics\DirectX\SimpleRenderer.cs" />
    <Compile Include="Graphics\DirectX\SimpleShader.cs" />
    <Compile Include="Graphics\DirectX\SharpDxGraphicsSystem.cs" />
    <Compile Include="Graphics\DirectX\ShaderCache.cs" />
    <Compile Include="Graphics\DirectX\SimpleText.cs" />
    <Compile Include="Graphics\DirectX\OLD_InputSystem.cs" />
    <Compile Include="Physics\ConvexHullCollider.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="project.json" />
  </ItemGroup>
  <ItemGroup>
    <Reference Condition="'$(Configuration)' == 'Release'" Include="$(RefsDir)\OpenTK\Release\OpenTK.dll" />
    <Reference Condition="'$(Configuration)' == 'Debug'" Include="$(RefsDir)\OpenTK\Debug\OpenTK.dll" />
    <Reference Include="$(RefsDir)\ExperimentalCollections\Microsoft.Experimental.Collections.dll" />
    <Reference Include="$(RefsDir)\SharpDx\SharpDX.dll" />
    <Reference Include="$(RefsDir)\SharpDx\SharpDX.D3DCompiler.dll" />
    <Reference Include="$(RefsDir)\SharpDx\SharpDX.Direct3D11.dll" />
    <Reference Include="$(RefsDir)\SharpDx\SharpDX.DXGI.dll" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\BEPU\BEPUphysics\BEPUphysics.csproj">
      <Project>{c0d52c9f-14b8-4008-8ddc-109c27561a5c}</Project>
      <Name>BEPUphysics</Name>
    </ProjectReference>
    <ProjectReference Include="..\BEPU\BEPUutilities\BEPUutilities.csproj">
      <Project>{34853dea-43a6-4f2f-a379-d1ee04d256d2}</Project>
      <Name>BEPUutilities</Name>
    </ProjectReference>
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.targets))\dir.targets">

D:\OSS\NetCoreGameEngine\src\dir.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="..\dir.targets">

D:\OSS\NetCoreGameEngine\dir.targets
============================================================================================================================================
-->
  <!-- Import portable targets -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.CSharp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.CSharp.targets

Contains common properties and targets that are shared by all v5.0 Portable Library C# projects.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <PortableEnableXamlTargets>true</PortableEnableXamlTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Portable.Common.targets">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.Common.targets

Contains common properties that are shared by all v5.0 Portable Library projects.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <PortableNuGetMode>true</PortableNuGetMode>
    <NoStdLib>true</NoStdLib>
    <NuGetTargetMoniker>.NETPlatform,Version=v5.0</NuGetTargetMoniker>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="..\Microsoft.Portable.Core.props">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\Microsoft.Portable.Core.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.Core.props

Contains common properties that are shared by all portable library projects regardless of version.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="VisualStudio\v$(VisualStudioVersion)\Microsoft.Portable.CurrentVersion.props" Condition="Exists('VisualStudio\v$(VisualStudioVersion)\Microsoft.Portable.CurrentVersion.props')">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\VisualStudio\v14.0\Microsoft.Portable.CurrentVersion.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.CurrentVersion.props

Contains common properties that are shared by all portable library projects targeting a specific
Visual Studio version.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <ItemDefinitionGroup>
    <!-- Hide TargetPlatform items by default so that they don't show up as visible in the project -->
    <TargetPlatform>
      <Visible>false</Visible>
    </TargetPlatform>
  </ItemDefinitionGroup>
  <PropertyGroup>
    <TargetPlatformMonikerDisplayName>Windows</TargetPlatformMonikerDisplayName>
    <PortableSDKRoot Condition="'$(PortableSDKRoot)' == ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Portable\v$(VisualStudioVersion)</PortableSDKRoot>
    <!-- Assume TargetPlatformResourceVersion of 8.1 and AppxOSMinVersion of 6.3.0.
             In future releases we may need to set this in the project or pull it from properties associated with the intersection. -->
    <TargetPlatformResourceVersion Condition="'$(TargetPlatformResourceVersion)' == ''">8.1</TargetPlatformResourceVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == ''">6.3.0</AppxOSMinVersion>
    <!-- Use latest -->
    <XamlTargetPlatformVersion Condition="'$(XamlTargetPlatformVersion)' == ''">8.1</XamlTargetPlatformVersion>
    <WindowsUIXamlCommonTargets Condition="'$(WindowsUIXamlCommonTargets)' == ''">$(MSBuildExtensionsPath32)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\$(XamlTargetPlatformVersion)\Microsoft.Windows.UI.Xaml.Common.targets</WindowsUIXamlCommonTargets>
    <!-- Set WindowsAppContainer to bring in the AppX targets for packaging outputs and resource support -->
    <WindowsAppContainer Condition="'$(WindowsAppContainer)' == ''">true</WindowsAppContainer>
    <!-- Automatically reference all WinMDs in the target platform -->
    <ImplicitlyExpandTargetPlatform Condition="'$(ImplicitlyExpandTargetPlatform)' == ''">true</ImplicitlyExpandTargetPlatform>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\Microsoft.Portable.Core.props
============================================================================================================================================
-->
  <PropertyGroup>
    <TargetPlatformIdentifier>Portable</TargetPlatformIdentifier>
    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
    <TargetFrameworkMonikerDisplayName>.NET Portable Subset</TargetFrameworkMonikerDisplayName>
    <!-- Automatically reference all assemblies in the target framework -->
    <ImplicitlyExpandTargetFramework Condition="'$(ImplicitlyExpandTargetFramework)' == '' AND '$(PortableNuGetMode)' != 'true'">true</ImplicitlyExpandTargetFramework>
  </PropertyGroup>
  <!-- Redefine AssemblySearchPaths to exclude {AssemblyFolders} and {GAC}, these represent .NET-specific locations -->
  <PropertyGroup>
    <AssemblySearchPaths Condition="'$(AssemblySearchPaths)' == ''">
            {CandidateAssemblyFiles};
            $(ReferencePath);
            {HintPathFromItem};
            {TargetFrameworkDirectory};
            {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
            {RawFileName};
            $(OutDir)
        </AssemblySearchPaths>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.Common.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.Targets">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.Targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by 
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- 
        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
        only forced 4.0 if that ToolsVersion did not exist.  

        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
        as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
        targets. 
   -->
  <Choose>
    <When Condition="'$(MSBuildAssemblyVersion)' == ''">
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.CSharp.targets</CSharpTargetsPath>
        <!-- Same condition as in .NET 4.5 C# targets so that we can override the behavior where it defaults to 
                 MSBuildToolsPath, which would be incorrect in this case -->
        <CscToolPath Condition="'$(CscToolPath)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">$(MsBuildFrameworkToolsPath)</CscToolPath>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CurrentVersion.targets</CSharpTargetsPath>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
    <!-- 
           Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because 
           Microsoft.CSharp.targets imports Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath, 
           so defining these in Microsoft.Common.targets alone would not suffice for C# projects.

           NOTE: This logic is duplicated in Microsoft.VisualBasic.targets (VB has the same problem) and in Microsoft.Common.targets
           (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two. 
       -->
    <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
    <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
    <ImportByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == ''">$(ImportByWildcardAfterMicrosoftCommonTargets)</ImportByWildcardAfter40MicrosoftCommonTargets>
    <ImportByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == ''">true</ImportByWildcardAfter40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)</ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == ''">$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)</ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets>
    <ImportByWildcardBeforeMicrosoftCommonTargets>false</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets>false</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>false</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>false</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
    <!-- Overrides for the Microsoft.CSharp.targets extension targets -->
    <ImportByWildcardBefore40MicrosoftCSharpTargets Condition="'$(ImportByWildcardBefore40MicrosoftCSharpTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCSharpTargets)</ImportByWildcardBefore40MicrosoftCSharpTargets>
    <ImportByWildcardBefore40MicrosoftCSharpTargets Condition="'$(ImportByWildcardBefore40MicrosoftCSharpTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCSharpTargets>
    <ImportByWildcardAfter40MicrosoftCSharpTargets Condition="'$(ImportByWildcardAfter40MicrosoftCSharpTargets)' == ''">$(ImportByWildcardAfterMicrosoftCSharpTargets)</ImportByWildcardAfter40MicrosoftCSharpTargets>
    <ImportByWildcardAfter40MicrosoftCSharpTargets Condition="'$(ImportByWildcardAfter40MicrosoftCSharpTargets)' == ''">true</ImportByWildcardAfter40MicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets)' == ''">$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)</ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets)' == ''">$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)</ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets>
    <ImportByWildcardBeforeMicrosoftCSharpTargets>false</ImportByWildcardBeforeMicrosoftCSharpTargets>
    <ImportByWildcardAfterMicrosoftCSharpTargets>false</ImportByWildcardAfterMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets>false</ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets>false</ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets>
    <CustomBeforeMicrosoftCSharpTargets Condition="'$(CustomBeforeMicrosoftCSharpTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.Microsoft.CSharp.targets</CustomBeforeMicrosoftCSharpTargets>
    <CustomAfterMicrosoftCSharpTargets Condition="'$(CustomAfterMicrosoftCSharpTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.After.Microsoft.CSharp.targets</CustomAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
    <!-- 
            Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
            (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
            Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
            own redirection targets.

            NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.Common.targets because VB and C#
            import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
            so for any changes to this logic in this file, please also edit the other two. 
        -->
    <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardAfterMicrosoftNetFrameworkProps)</ImportByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps)</ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps)</ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportByWildcardBeforeMicrosoftNetFrameworkProps>false</ImportByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportByWildcardAfterMicrosoftNetFrameworkProps>false</ImportByWildcardAfterMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps>false</ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps>false</ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')" />-->
  <!--</ImportGroup>-->
  <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
        targets), we're stuck doing it this way instead. -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')" />-->
  <!--</ImportGroup>-->
  <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports 
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
        way instead. -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(CSharpTargetsPath)">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by 
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCSharpTargets>
    <ImportByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportByWildcardAfterMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <PropertyGroup>
    <CustomBeforeMicrosoftCSharpTargets Condition="'$(CustomBeforeMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.CSharp.targets</CustomBeforeMicrosoftCSharpTargets>
    <CustomAfterMicrosoftCSharpTargets Condition="'$(CustomAfterMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.CSharp.targets</CustomAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCSharpTargets)" Condition="'$(CustomBeforeMicrosoftCSharpTargets)' != '' and Exists('$(CustomBeforeMicrosoftCSharpTargets)')" />-->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <DefaultLanguageSourceExtension>.cs</DefaultLanguageSourceExtension>
    <Language>C#</Language>
    <TargetRuntime>Managed</TargetRuntime>
    <AlwaysUseNumericalSuffixInItemNames>true</AlwaysUseNumericalSuffixInItemNames>
    <DefineCommonItemSchemas Condition=" '$(DefineCommonItemSchemas)' == '' ">true</DefineCommonItemSchemas>
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">true</DefineCommonReferenceSchemas>
    <DefineCommonCapabilities Condition=" '$(DefineCommonCapabilities)' == '' ">true</DefineCommonCapabilities>
    <SynthesizeLinkMetadata Condition=" '$(SynthesizeLinkMetadata)' == '' and '$(HasSharedItems)' == 'true' ">true</SynthesizeLinkMetadata>
  </PropertyGroup>
  <ItemGroup>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.ProjectItemsSchema.xaml;" />
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.xaml;">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.BrowseObject.xaml;">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <ProjectCapability Include="CSharp;Managed" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' ">
    <ProjectCapability Include="ReferencesFolder;LanguageService" />
    <ProjectCapability Include="ProjectConfigurationsInferredFromUsage" />
  </ItemGroup>
  <!--
    The CreateManifestResourceNames target create the manifest resource names from the .RESX
    files.
    
        [IN]
        @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                              Expected Metadata "Type" can either be "Resx" or "Non-Resx"

        [OUT]
        @(EmbeddedResource) - EmbeddedResource items with metadata         
        
    For C# applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        SubFolder\Resources1.resx => RootNamespace.SubFolder.Resources1 => Build into main assembly
        Resources1.fr.resx => RootNamespace.Resources1.fr => Build into satellite assembly
        Resources1.notaculture.resx => RootNamespace.Resources1.notaculture => Build into main assembly

    For other project systems, this transformation may be different.
    -->
  <PropertyGroup>
    <CreateManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateManifestResourceNames" Condition="'@(EmbeddedResource)' != ''" DependsOnTargets="$(CreateManifestResourceNamesDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <!-- Create manifest names for all culture non-resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" PrependCultureAsDirectory="false" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <ItemGroup>
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' == ''" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveCodeAnalysisRuleSet" Condition="'$(CodeAnalysisRuleSet)' != ''">
    <ResolveCodeAnalysisRuleSet CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)" CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
      <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
    </ResolveCodeAnalysisRuleSet>
  </Target>
  <ItemGroup>
    <!-- Activate CPS projects to track folder names in namespace. -->
    <ProjectCapability Include="RelativePathDerivedDefaultNamespace" />
  </ItemGroup>
  <PropertyGroup>
    <!-- Provide a facility to override UseHostCompilerIfAvailable-->
    <UseHostCompilerIfAvailable Condition=" '$(UseHostCompilerIfAvailable)' == ''">true</UseHostCompilerIfAvailable>
  </PropertyGroup>
  <ItemGroup>
    <DocFileItem Include="$(DocumentationFile)" Condition="'$(DocumentationFile)'!=''" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(PdbFile)' != ''">
    <_DebugSymbolsIntermediatePathTemporary Include="$(PdbFile)" />
    <!-- Add any missing .pdb extension, as the compiler does -->
    <_DebugSymbolsIntermediatePath Include="@(_DebugSymbolsIntermediatePathTemporary->'%(RootDir)%(Directory)%(Filename).pdb')" />
  </ItemGroup>
  <PropertyGroup>
    <CoreCompileDependsOn>_ComputeNonExistentFileProperty;ResolveCodeAnalysisRuleSet</CoreCompileDependsOn>
    <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
  </PropertyGroup>
  <!--
      The XamlPreCompile target must remain identical to
      the CoreCompile target in Microsoft.CSharp.Core.targets.
      Any updates to one must be made to the other.
-->
  <Target Name="XamlPreCompile" Inputs="$(MSBuildAllProjects);&#xD;&#xA;                @(Compile);&#xD;&#xA;                @(_CoreCompileResourceInputs);&#xD;&#xA;                $(ApplicationIcon);&#xD;&#xA;                $(AssemblyOriginatorKeyFile);&#xD;&#xA;                @(ReferencePath);&#xD;&#xA;                @(CompiledLicenseFile);&#xD;&#xA;                @(LinkResource);&#xD;&#xA;                @(EmbeddedDocumentation); &#xD;&#xA;                $(Win32Resource);&#xD;&#xA;                $(Win32Manifest);&#xD;&#xA;                @(CustomAdditionalCompileInputs);&#xD;&#xA;                @(Page);&#xD;&#xA;                @(ApplicationDefinition);&#xD;&#xA;                $(ResolvedCodeAnalysisRuleSet)" Outputs="@(DocFileItem);&#xD;&#xA;                 @(XamlIntermediateAssembly);&#xD;&#xA;                 @(_DebugSymbolsIntermediatePath);&#xD;&#xA;                 $(NonExistentFile);&#xD;&#xA;                 @(CustomAdditionalCompileOutputs)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''" Returns="" DependsOnTargets="$(CoreCompileDependsOn)">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition=" '$(BuildingInsideVisualStudio)' == 'true' and '$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0' ">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <ItemGroup Condition="'$(TargetingClr2Framework)'=='true'">
      <ReferencePath>
        <EmbedInteropTypes />
      </ReferencePath>
    </ItemGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
    <!-- Analyzers="@(Analyzer)" -->
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <Csc Condition=" '%(_CoreCompileResourceInputs.WithCulture)' != 'true' " AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" DebugType="$(DebugType)" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DocumentationFile="@(DocFileItem)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" FileAlignment="$(FileAlignment)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Optimize="$(Optimize)" OutputAssembly="@(XamlIntermediateAssembly)" PdbFile="$(PdbFile)" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" References="@(ReferencePath)" ReportAnalyzer="$(ReportAnalyzer)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" />
    <!-- Only Applicable to the regular CoreCompile:
              <ItemGroup>
                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
              </ItemGroup>

              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>
-->
    <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
  </Target>
  <PropertyGroup>
    <CSharpCoreTargetsPath Condition="'$(CSharpCoreTargetsPath)' == ''">Microsoft.CSharp.Core.targets</CSharpCoreTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CSharpCoreTargetsPath)">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.Core.targets
============================================================================================================================================
-->
  <Target Name="CoreCompile" Inputs="$(MSBuildAllProjects);&#xD;&#xA;                @(Compile);&#xD;&#xA;                @(_CoreCompileResourceInputs);&#xD;&#xA;                $(ApplicationIcon);&#xD;&#xA;                $(AssemblyOriginatorKeyFile);&#xD;&#xA;                @(ReferencePath);&#xD;&#xA;                @(CompiledLicenseFile);&#xD;&#xA;                @(LinkResource);&#xD;&#xA;                @(EmbeddedDocumentation);&#xD;&#xA;                $(Win32Resource);&#xD;&#xA;                $(Win32Manifest);&#xD;&#xA;                @(CustomAdditionalCompileInputs);&#xD;&#xA;                $(ResolvedCodeAnalysisRuleSet)" Outputs="@(DocFileItem);&#xD;&#xA;                 @(IntermediateAssembly);&#xD;&#xA;                 @(_DebugSymbolsIntermediatePath);&#xD;&#xA;                 $(NonExistentFile);&#xD;&#xA;                 @(CustomAdditionalCompileOutputs)" Returns="" DependsOnTargets="$(CoreCompileDependsOn)">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition=" '$(BuildingInsideVisualStudio)' == 'true' and '$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0' ">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <ItemGroup Condition="'$(TargetingClr2Framework)'=='true'">
      <ReferencePath>
        <EmbedInteropTypes />
      </ReferencePath>
    </ItemGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <Csc Condition=" '%(_CoreCompileResourceInputs.WithCulture)' != 'true' " AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" Analyzers="@(Analyzer)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" DebugType="$(DebugType)" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DocumentationFile="@(DocFileItem)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" FileAlignment="$(FileAlignment)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Optimize="$(Optimize)" OutputAssembly="@(IntermediateAssembly)" PdbFile="$(PdbFile)" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" References="@(ReferencePath)" ReportAnalyzer="$(ReportAnalyzer)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" />
    <ItemGroup>
      <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
    </ItemGroup>
    <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Common.targets">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- 
       In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
       as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
       just used whatever ToolsVersion was in the project file if it existed on the machine, and 
       only forced 4.0 if that ToolsVersion did not exist.  

       Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
       but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
       the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
       property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
       as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
       targets. 
   -->
  <Choose>
    <When Condition="'$(MSBuildAssemblyVersion)' == ''">
      <PropertyGroup>
        <CommonTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.Common.targets</CommonTargetsPath>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <CommonTargetsPath>$(MSBuildToolsPath)\Microsoft.Common.CurrentVersion.targets</CommonTargetsPath>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
    <!-- 
          Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. 

          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
          import Microsoft.Common.targets from the current directory and thus don't get the benefit of the redirections, so for 
          any changes to this logic in this file, please also edit the other two. 
      -->
    <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
    <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
    <ImportByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == ''">$(ImportByWildcardAfterMicrosoftCommonTargets)</ImportByWildcardAfter40MicrosoftCommonTargets>
    <ImportByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == ''">true</ImportByWildcardAfter40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)</ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == ''">$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)</ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets>
    <ImportByWildcardBeforeMicrosoftCommonTargets>false</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets>false</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>false</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>false</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)' == ''">$(MSBuildExtensionsPath)\v4.0\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
    <!-- 
          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
          own redirection targets. 

          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
          so for any changes to this logic in this file, please also edit the other two. 
      -->
    <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardAfterMicrosoftNetFrameworkProps)</ImportByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps)</ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps)</ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == ''">true</ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps>
    <ImportByWildcardBeforeMicrosoftNetFrameworkProps>false</ImportByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportByWildcardAfterMicrosoftNetFrameworkProps>false</ImportByWildcardAfterMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps>false</ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkProps>
    <ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps>false</ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(CommonTargetsPath)">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(MicrosoftCommonPropsHasBeenImported)' != 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportBefore\Microsoft.Cpp.VCLibs120Universal.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.cpp.VCLibs120Universal.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
      created a backup copy.  Incorrect changes to this file will make it
      impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>$(_GenerateAppxManifestDependsOn);_FixVCLibs120References</_GenerateAppxManifestDependsOn>
  </PropertyGroup>
  <Target Name="_FixVCLibs120References" Condition="'$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP'">
    <!-- Check if VC libs 120 reference is found,  If found remove it-->
    <ItemGroup>
      <VCLibs120Ref Include="'%(PackagingOutputs.SDKName)'" Condition="'%(PackagingOutputs.SDKName)' == 'Microsoft.VCLibs, Version=12.0'" />
    </ItemGroup>
    <ItemGroup Condition="'@(VCLibs120Ref)' != ''">
      <PackagingOutputs Remove="@(PackagingOutputs)" Condition="'%(PackagingOutputs.SDKName)' == 'Microsoft.VCLibs, Version=12.0'" />
    </ItemGroup>
    <!-- Get the resolved SDK reference item for Microsoft.VCLibs.120, Version=14.0 and add that to the packaging output -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == '' and '@(VCLibs120Ref)' != ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ResolveSDKReference SDKReferences="Microsoft.VCLibs.120, Version=14.0" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(VCLibs120Ref)' != ''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="VCLibs12UniversalReference" />
    </ResolveSDKReference>
    <ItemGroup Condition="'@(VCLibs120Ref)' != '' and '@(VCLibs12UniversalReference)' != '' ">
      <PackagingOutputs Include="@(VCLibs12UniversalReference)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportBefore\Microsoft.Net.CoreRuntime.ImportBefore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.ImportBefore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetfxCoreRuntimeSettingsTargets Condition="'$(ProjectNTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\.NetNative\Microsoft.Net.CoreRuntime.Settings.targets</NetfxCoreRuntimeSettingsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetfxCoreRuntimeSettingsTargets)" Condition="exists('$(NetfxCoreRuntimeSettingsTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\.NetNative\Microsoft.Net.CoreRuntime.Settings.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.Settings.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Enable UWP projects to target CoreCLR when .net native is not enabled (i.e.: in the default debug configuration) -->
    <EnableCoreRuntime Condition="'$(EnableCoreRuntime)' == ''">true</EnableCoreRuntime>
    <!-- Enable the temporary workaround to inject the .net framework libraries into the app package -->
    <EnableAppLocalFxWorkaround Condition="'$(EnableAppLocalFxWorkaround)' == ''">true</EnableAppLocalFxWorkaround>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportBefore\Microsoft.Net.CoreRuntime.ImportBefore.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportBefore\Microsoft.NetNative.ImportBefore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.ImportBefore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ProjectNSettingsTargets Condition="'$(ProjectNTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\.NetNative\Microsoft.NetNative.Settings.targets</ProjectNSettingsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ProjectNSettingsTargets)" Condition="exists('$(ProjectNSettingsTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\.NetNative\Microsoft.NetNative.Settings.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.Settings.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Check platform and project for Microsoft .Net Native support -->
  <PropertyGroup>
    <!-- TargetPlatformVersion should be at least 8.1 -->
    <_ProjectNPlatformSupported Condition="'$(SDKVersion)' != '' or ('$(TargetPlatformVersion)' != '' and '$(TargetPlatformVersion)' &gt;= '8.1')">true</_ProjectNPlatformSupported>
    <_ProjectNProjectSupported Condition="'$(AppxPackage)' == 'true'">true</_ProjectNProjectSupported>
    <!-- Denotes that Microsoft .Net Native is supported by this kind of project so corresponding UI elements should be visible -->
    <CanUseProjectN Condition="'$(_ProjectNPlatformSupported)' == 'true' and '$(_ProjectNProjectSupported)' == 'true'">true</CanUseProjectN>
    <!-- Formerly, EnableDotNetNativeCompatibleProfile was EnableProjectNCompatibleProfile and -->
    <!-- UseDotNetNativeToolchain was known as UseProjectNToolchain. Use the old form of the   -->
    <!-- attributes if the new form has not yet been set.                                      -->
    <EnableDotNetNativeCompatibleProfile Condition="'$(EnableDotNetNativeCompatibleProfile)' == ''">$(EnableProjectNCompatibleProfile)</EnableDotNetNativeCompatibleProfile>
    <UseDotNetNativeToolchain Condition="'$(UseDotNetNativeToolchain)' == ''">$(UseProjectNToolchain)</UseDotNetNativeToolchain>
    <!-- EnableDotNetNativeCompatibleProfile property is defined on the project level and set from  UI-->
    <ProjectNProfileEnabled Condition="'$(CanUseProjectN)'=='true' and '$(EnableDotNetNativeCompatibleProfile)'=='true'">true</ProjectNProfileEnabled>
    <DefineConstants Condition="'$(ProjectNProfileEnabled)'=='true'">$(DefineConstants);CODE_ANALYSIS</DefineConstants>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportBefore\Microsoft.NetNative.ImportBefore.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />-->
  <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
  <PropertyGroup>
    <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
  </PropertyGroup>
  <PropertyGroup>
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
    <ReportingServicesTargets Condition="'$(ReportingServicesTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\ReportingServices\Microsoft.ReportingServices.targets</ReportingServicesTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="'$(CustomBeforeMicrosoftCommonTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonTargets)')" />-->
  <!-- By default, we are creating a managed app because .NET 2.0 projects did not have this property. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == ''">
    <TargetRuntime>Managed</TargetRuntime>
  </PropertyGroup>
  <!-- Because .NET 2.0 apps did not set TargetFrameworkIdentifier, we need to set it for them here by default.  If
       the runtime is set to Managed, we also need to set these.  Otherwise they should be blank (for instance Javascript or
       Native apps) because they do not target a .NET Framework. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed'">
    <TargetFrameworkIdentifier Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
    <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v4.0</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- AvailablePlatforms is the list of platform targets available. -->
  <PropertyGroup>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' == '10.0' or '$(VisualStudioVersion)' == ''">Any CPU,x86,x64,Itanium</AvailablePlatforms>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0'">Any CPU,x86,x64</AvailablePlatforms>
  </PropertyGroup>
  <!-- Import does NOT apply to .NETCore -->
  <!--<Import Project="Microsoft.NETFramework.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight'" />-->
  <PropertyGroup>
    <!-- Yield optimization properties -->
    <YieldDuringToolExecution Condition="'$(YieldDuringToolExecution)' == ''">true</YieldDuringToolExecution>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' != '' and '$(TargetFrameworkVersion)' != ''">
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == '' and '$(TargetFrameworkProfile)' != ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion),Profile=$(TargetFrameworkProfile)</TargetFrameworkMoniker>
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
    <!-- The FrameworkPathOverride is required for the inproc visual basic compiler to initialize when targeting target frameworks less than 4.0. If .net 2.0 is not installed then the property value above will not provide the location
             of mscorlib. This is also true if the build author overrides this property to some other directory which does not contain mscorlib.dll. In the case we cannot find mscorlib.dll at the correct location
             we need to find a directory which does contain mscorlib to allow the inproc compiler to initialize and give us the chance to show certain dialogs in the IDE (which only happen after initialization).-->
    <FrameworkPathOverride Condition="'$(FrameworkPathOverride)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToStandardLibraries($(TargetFrameworkIdentifier), $(TargetFrameworkVersion), $(TargetFrameworkProfile), $(PlatformTarget)))</FrameworkPathOverride>
    <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <PropertyGroup>
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">Windows</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">7.0</TargetPlatformVersion>
    <TargetPlatformSdkPath Condition=" '$(TargetPlatformIdentifier)' == 'Windows'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition=" '$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
    <TargetPlatformSdkMetadataLocation Condition="'$(TargetPlatformSdkMetadataLocation)' == '' and Exists('$(TargetPlatformSdkPath)')">$(TargetPlatformSdkPath)Windows Metadata</TargetPlatformSdkMetadataLocation>
    <TargetPlatformSdkMetadataLocation Condition="Exists('$(TargetPlatformSdkPath)') and ('$(TargetPlatformSdkMetadataLocation)' == '' or !Exists('$(TargetPlatformSdkMetadataLocation)'))">$(TargetPlatformSdkPath)References\CommonConfiguration\Neutral</TargetPlatformSdkMetadataLocation>
    <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
    <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
    <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!--
    Several properties must be set in the main project file, before using this .TARGETS file.
    However, if the properties are not set, we pick some defaults.

    OutDir:
    Indicates the final output location for the project or solution. When building a solution,
    OutDir can be used to gather multiple project outputs in one location. In addition,
    OutDir is included in AssemblySearchPaths used for resolving references.

    OutputPath:
    This property is usually specified in the project file and is used to initialize OutDir.
    OutDir and OutputPath are distinguished for legacy reasons, and OutDir should be used if at all possible.

    BaseIntermediateOutputPath:
    This is the top level folder where all configuration specific intermediate output folders will be created.
    Default value is obj\

    IntermediateOutputPath:
    This is the full intermediate Output Path, and is derived from BaseIntermediateOutputPath, if none specified
    (eg. obj\debug). If this property is overridden, then setting BaseIntermediateOutputPath has no effect.
    -->
  <PropertyGroup>
    <!-- Ensure any OutputPath has a trailing slash, so it can be concatenated -->
    <OutputPath Condition="'$(OutputPath)' != '' and !HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
    <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
    <!--
        Be careful not to give OutputPath a default value in the case of an invalid Configuration/Platform.
        We use OutputPath specifically to check for invalid configurations/platforms.
        -->
    <OutputPath Condition=" '$(Platform)'=='' and '$(Configuration)'=='' and '$(OutputPath)'=='' ">bin\Debug\</OutputPath>
    <_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
    <_OriginalPlatform>$(Platform)</_OriginalPlatform>
    <Configuration Condition=" '$(Configuration)'=='' ">Debug</Configuration>
    <ConfigurationName Condition=" '$(ConfigurationName)' == '' ">$(Configuration)</ConfigurationName>
    <!-- Example, Debug -->
    <Platform Condition=" '$(Platform)'=='' ">AnyCPU</Platform>
    <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
    <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
    <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>
    <DebugSymbols Condition=" '$(ConfigurationName)' == 'Debug' and '$(DebugSymbols)' == '' and '$(DebugType)'==''">true</DebugSymbols>
    <!-- Whether or not a .pdb file is produced. -->
    <_DebugSymbolsProduced>false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>
    <!-- Whether or not a .xml file is produced. -->
    <_DocumentationFileProduced>true</_DocumentationFileProduced>
    <_DocumentationFileProduced Condition="'$(DocumentationFile)'==''">false</_DocumentationFileProduced>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(OutputPath)' == '' ">
    <!--
        A blank OutputPath at this point means that the user passed in an invalid Configuration/Platform
        combination.  Whether this is considered an error or a warning depends on the value of
        $(SkipInvalidConfigurations).
        -->
    <_InvalidConfigurationError Condition=" '$(SkipInvalidConfigurations)' != 'true' ">true</_InvalidConfigurationError>
    <_InvalidConfigurationWarning Condition=" '$(SkipInvalidConfigurations)' == 'true' ">true</_InvalidConfigurationWarning>
  </PropertyGroup>
  <!--
    IDE Macros available from both integrated builds and from command line builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps.
    -->
  <PropertyGroup>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='exe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='appcontainerexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='library'">.dll</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='module'">.netmodule</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winmdobj'">.winmdobj</TargetExt>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Required for enabling Team Build for packaging app package-generating projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
    <!-- Example, bin\Debug\ -->
    <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
    <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
    <!-- Example, MyProject -->
    <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
    <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
    <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>
    <!-- Example, MyAssembly -->
    <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>
    <!-- Example, MyProject.csproj -->
    <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>
    <!-- Example, .csproj -->
    <WinMDExpOutputWindowsMetadataFilename Condition="'$(WinMDExpOutputWindowsMetadataFilename)' == '' and '$(OutputType)' == 'winmdobj'">$(TargetName).winmd</WinMDExpOutputWindowsMetadataFilename>
    <TargetFileName Condition=" '$(TargetFileName)' == '' and '$(OutputType)' == 'winmdobj'">$(WinMDExpOutputWindowsMetadataFilename)</TargetFileName>
    <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>
    <!-- Example, MyAssembly.dll -->
  </PropertyGroup>
  <PropertyGroup>
    <!--
        The PublishableProject property is used when invoking the publish target on a solution that
        contains multiple projects. The property determines which projects should be published, and
        which projects should be skipped in the publish target. By default any "Windows Application"
        or "Console Application" project type is publishable. However, a project that would otherwise
        be published can be skipped by defining the PublishableProject property in the project itself.
        -->
    <_DeploymentPublishableProjectDefault Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">true</_DeploymentPublishableProjectDefault>
    <PublishableProject Condition="'$(PublishableProject)'==''">$(_DeploymentPublishableProjectDefault)</PublishableProject>
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, Native.MyAssembly.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='appcontainerexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' != 'true'">$(AssemblyName).application</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.application -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.xbap -->
    <GenerateClickOnceManifests Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">$(GenerateManifests)</GenerateClickOnceManifests>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='winexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='exe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='appcontainerexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' != 'true'">$(AssemblyName).application</_DeploymentDeployManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</_DeploymentDeployManifestIdentity>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'=='true'">.deploy</_DeploymentFileMappingExtension>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'!='true'" />
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'=='true'">$(UpdateInterval)</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'=='true'">$(UpdateIntervalUnits)</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'!='true'">0</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
    <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
  </PropertyGroup>
  <PropertyGroup>
    <!--
        By default, GenerateApplicationManifest puts all satellite assemblies to the manifest
        record by default by setting TargetCulture to *.
        -->
    <TargetCulture Condition="'$(TargetCulture)'==''">*</TargetCulture>
    <FallbackCulture Condition="'$(UICulture)'!='' and '$(FallbackCulture)'==''">$(UICulture)</FallbackCulture>
  </PropertyGroup>
  <ItemGroup>
    <!-- Not used any more-->
    <_OutputPathItem Include="$(OutDir)" />
    <_UnmanagedRegistrationCache Include="$(BaseIntermediateOutputPath)$(MSBuildProjectFile).UnmanagedRegistration.cache" />
    <_ResolveComReferenceCache Include="$(IntermediateOutputPath)$(MSBuildProjectFile).ResolveComReference.cache" />
  </ItemGroup>
  <PropertyGroup>
    <!-- Example, c:\MyProjects\MyProject\bin\debug\ -->
    <!--
        Condition intentionally omitted on this one, because it causes problems
        when we pick up the value of an environment variable named TargetDir
        -->
    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
    <!-- Example, c:\MyProjects\MyProject\bin\debug\MyAssembly.dll -->
    <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
    <!-- Example, c:\MyProjects\MyProject\ -->
    <ProjectDir Condition=" '$(ProjectDir)' == '' ">$(MSBuildProjectDirectory)\</ProjectDir>
    <!-- Example, c:\MyProjects\MyProject\MyProject.csproj -->
    <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>
    <!-- Example, AnyCPU -->
    <PlatformName Condition=" '$(PlatformName)' == '' ">$(Platform)</PlatformName>
  </PropertyGroup>
  <ItemGroup>
    <!-- This is not used here but remains for backwards compatibility -->
    <AppConfigFileDestination Include="$(OutDir)$(TargetFileName).config" />
  </ItemGroup>
  <!--
    IDE Macros available only from integrated builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps. However, they are not defined when directly building
    a project from the command line, only when building a solution.
    -->
  <PropertyGroup>
    <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
    <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
    <!-- Example, MySolution -->
    <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
    <!-- Example, MySolution.sln -->
    <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>
    <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
    <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>
    <!-- Example, f:\MySolutions\MySolution\ -->
    <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>
    <!-- Example, .sln -->
  </PropertyGroup>
  <PropertyGroup>
    <GenerateBindingRedirectsOutputType Condition="'$(OutputType)'=='exe' or '$(OutputType)'=='winexe'">true</GenerateBindingRedirectsOutputType>
  </PropertyGroup>
  <PropertyGroup>
    <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == '' and '$(DesignTimeBuild)' == 'true'">false</BuildProjectReferences>
    <!-- By default we will build (and if applicable, clean) all project references. But this can be used to disable that-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == ''">true</BuildProjectReferences>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
    <_ResolveReferenceDependencies Condition="'$(_ResolveReferenceDependencies)' == ''">false</_ResolveReferenceDependencies>
    <_GetChildProjectCopyToOutputDirectoryItems Condition="'$(_GetChildProjectCopyToOutputDirectoryItems)' == ''">true</_GetChildProjectCopyToOutputDirectoryItems>
    <OverwriteReadOnlyFiles Condition="'$(OverwriteReadOnlyFiles)' == ''">false</OverwriteReadOnlyFiles>
    <ComReferenceNoClassMembers Condition="'$(ComReferenceNoClassMembers)' == ''">false</ComReferenceNoClassMembers>
  </PropertyGroup>
  <PropertyGroup Condition=" $(IntermediateOutputPath) == '' ">
    <IntermediateOutputPath Condition=" '$(PlatformName)' == 'AnyCPU' ">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition=" '$(PlatformName)' != 'AnyCPU' ">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
  </PropertyGroup>
  <PropertyGroup>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
    <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(MSBuildProjectFile).$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
  </PropertyGroup>
  <ItemGroup>
    <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" />
    <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true'">
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).compile.pdb" Condition="'$(OutputType)' == 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).pdb" Condition="'$(OutputType)' != 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'">
    <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''">
    <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''">
    <_IntermediateWindowsMetadataPath>$(IntermediateOutputPath)$(WinMDExpOutputWindowsMetadataFilename)</_IntermediateWindowsMetadataPath>
    <_WindowsMetadataOutputPath>$(OutDir)$(WinMDExpOutputWindowsMetadataFilename)</_WindowsMetadataOutputPath>
  </PropertyGroup>
  <ItemGroup>
    <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
    <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
      <TargetPath>$(TargetFileName)</TargetPath>
    </_DeploymentManifestEntryPoint>
    <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
    <!-- NOTE: The item Include and the Exists function are operating relative to the PROJECT (.csproj, .vbproj etc.) directory in this case -->
    <_DeploymentManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
      <TargetPath>$(ApplicationIcon)</TargetPath>
    </_DeploymentManifestIconFile>
    <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
    <ApplicationManifest Include="$(IntermediateOutputPath)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </ApplicationManifest>
    <!-- Create an item for the final application manifest (Example: WindowsApplication1.exe.manifeset)
             This item represents the final output application manifest used for project-to-project
             references and for copying to the publish output location. -->
    <_ApplicationManifestFinal Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </_ApplicationManifestFinal>
    <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
    <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
      <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
    </DeployManifest>
    <!-- Create an item for the intermediate trust info file -->
    <_DeploymentIntermediateTrustInfoFile Include="$(IntermediateOutputPath)$(TargetName).TrustInfo.xml" Condition="'$(TargetZone)'!=''" />
  </ItemGroup>
  <!--
    Determine the <deploymentProvider> (_DeploymentUrl) for the ClickOnce deployment manifest.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if not specified.
    If the UpdateUrl is specified then _DeploymentUrl is always set to the UpdateUrl.
    Otherwise, only set the _DeploymentUrl if it's an installed app and updates are enabled.
    -->
  <PropertyGroup>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(UpdateUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(InstallUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(PublishUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="!('$(UpdateUrl)'=='') and '$(Install)'=='false'" />
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'!=''">$(_DeploymentUrl)$(TargetDeployManifestFileName)</_DeploymentUrl>
    <!--
        Need to explicitly blank out the _DeploymentUrl when it's not used. Otherwise an
        inappropriate value may be used. For example a local path from the PublishUrl
        is something we never want to see in the manifest because it means you could
        only install the app from that machine.
        -->
    <_DeploymentUrl Condition="'$(UpdateUrl)'=='' and !('$(Install)'=='true' and '$(UpdateEnabled)'=='true')" />
    <_DeploymentUrl Condition="'$(ExcludeDeploymentUrl)'=='true'" />
  </PropertyGroup>
  <!-- Determine the URLs for the bootstrapper. -->
  <PropertyGroup>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</_DeploymentApplicationUrl>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true' and '$(InstallUrl)'==''">$(PublishUrl)</_DeploymentApplicationUrl>
    <_DeploymentComponentsUrl Condition="'$(BootstrapperComponentsLocation)'=='Absolute'">$(BootstrapperComponentsUrl)</_DeploymentComponentsUrl>
  </PropertyGroup>
  <!-- Output location for publish target. -->
  <PropertyGroup>
    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
  </PropertyGroup>
  <!--
    ProcessorArchitecture is the target processor architecture.
    -->
  <PropertyGroup Condition="'$(ProcessorArchitecture)'==''">
    <!--
        If ProcessorArchitecture is not set, set it to PlatformTarget
        Note: if $(PlatformTarget) is also blank resolve assembly reference defaults to msil which is the
        desired behavior in this case
        -->
    <ProcessorArchitecture>$(PlatformTarget)</ProcessorArchitecture>
    <!--
        If Processor architecture is not set and PlatformTarget is a known target translate the
        PlatformTarget into something ResolveAssemblyReference knows about
        -->
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'AnyCpu' ">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x64' ">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x86' ">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'ARM' ">arm</ProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup>
    <ConsiderPlatformAsProcessorArchitecture Condition="'$(ConsiderPlatformAsProcessorArchitecture)' == ''">true</ConsiderPlatformAsProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ProcessorArchitecture)' == '' and '$(ConsiderPlatformAsProcessorArchitecture)' == 'true'">
    <!-- We need to do this here because if we were to just compare against platform visual would parse them out as available platforms which may not be the case -->
    <ProcessorArchitectureAsPlatform>$(Platform)</ProcessorArchitectureAsPlatform>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'AnyCpu' or '$(ProcessorArchitectureAsPlatform)' == 'Any Cpu'">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x64' or '$(ProcessorArchitectureAsPlatform)' == 'amd64'">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x86' or '$(ProcessorArchitectureAsPlatform)' == 'win32'">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'ARM' ">arm</ProcessorArchitecture>
    <!--For compatibility with the 4.0 behavior, if not set above, default to the environment. To override this, set ProcessorArchitecture explicitly. We also need to disable the warning since we do not know if what the environment is set to is correct-->
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ProcessorArchitecture)'==''">None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
  </PropertyGroup>
  <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values -->
  <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == ''">
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">CLR2</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v4.0' or '$(TargetFrameworkVersion)' == 'v4.5'">CLR4</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkAsMSBuildRuntime)' == ''">CurrentRuntime</TargetFrameworkAsMSBuildRuntime>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' != ''">true</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">false</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'x86' or ('$(PlatformTarget)' == 'x64' and '$(MSBuildExtensionsPath64)' != '')">$(PlatformTarget)</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'arm'">x86</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="('$(PlatformTarget)' == 'ia64' and '$(MSBuildExtensionsPath64)' != '')">x64</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">CurrentArchitecture</PlatformTargetAsMSBuildArchitecture>
  </PropertyGroup>
  <!-- Flavor is the project flavor. For example, Client, Smart Devices, SQL Server, etc. -->
  <PropertyGroup>
    <ProjectFlavor Condition="'$(ProjectFlavor)'==''">Client</ProjectFlavor>
  </PropertyGroup>
  <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
  <PropertyGroup>
    <DelaySign Condition="'$(SignAssembly)' != 'true'">false</DelaySign>
    <DelaySign Condition="'$(DelaySign)'!='true'" />
  </PropertyGroup>
  <!-- These properties control web reference proxy generation. -->
  <PropertyGroup>
    <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
    <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
    <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
  </PropertyGroup>
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildProjectFullPath);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <MSBuildAllProjects Condition="Exists('$(MSBuildProjectFullPath).user')">$(MSBuildAllProjects);$(MSBuildProjectFullPath).user</MSBuildAllProjects>
  </PropertyGroup>
  <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
  <PropertyGroup>
    <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\$(TargetFrameworkIdentifier)</FrameworkRegistryBase>
    <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
    <!--
        The SearchPaths property is set to find assemblies in the following order:

            (1) Files from current project - indicated by {CandidateAssemblyFiles}
            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
            (5) Registered assembly folders, indicated by {Registry:*,*,*}
            (6) Legacy registered assembly folders, indicated by {AssemblyFolders}
            (7) Resolve to the GAC.
            (8) Treat the reference's Include as if it were a real file name.
            (9) Look in the application's output folder (like bin\debug)
        -->
    <AssemblySearchPaths Condition=" '$(AssemblySearchPaths)' == ''">
      {CandidateAssemblyFiles};
      $(ReferencePath);
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
      {AssemblyFolders};
      {GAC};
      {RawFileName};
      $(OutDir)
    </AssemblySearchPaths>
    <!--
        These are the extensions that assembly reference resolution will consider for resolution.
        Add new extensions here if you want to add new file types to consider (for example, .metadata_dll).
        Put the most likely extensions first for reference resolution speed.
        -->
    <AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
      .winmd;
      .dll;
      .exe
    </AllowedReferenceAssemblyFileExtensions>
    <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references.  Add new extensions here if you want to add new file types to consider.
        -->
    <AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
      .pdb;
      .xml;
      .pri
    </AllowedReferenceRelatedFileExtensions>
    <!--
        These names are used when determining which TargetFramework subset to use. If the any of the FullReferenceAssemblyNames
        are seen in the list of client subsets, RAR will assume that no client subset is being used. The list is semicolon seperated
        For example :   Full;Complete;AllThere
        -->
    <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
  </PropertyGroup>
  <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
         Default to ErrorAndStop, since that matches the behaviour in previous versions, and what users
         typically expect -->
  <PropertyGroup>
    <ContinueOnError Condition="'$(ContinueOnError)' == ''">false</ContinueOnError>
  </PropertyGroup>
  <!-- Common Project System support -->
  <PropertyGroup>
    <CommonXamlResourcesDirectory Condition=" '$(CommonXamlResourcesDirectory)' == '' ">$(MSBuildThisFileDirectory)$(LangName)\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <!-- We need to fallback to en-US in case the xaml rules are not localized (possibly happen on community languages).  -->
  <PropertyGroup Condition="!Exists('$(CommonXamlResourcesDirectory)')">
    <CommonXamlResourcesDirectory>$(MSBuildThisFileDirectory)en-US\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonItemSchemas)' == 'true' ">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectItemsSchema.xaml" />
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)General.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Debugger_General.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General.BrowseObject.xaml">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General_File.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SCC.xaml">
      <Context>Invisible</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Folder.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)None.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Content.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)EmbeddedResource.xaml;&#xD;&#xA;                        ">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SpecialFolder.xaml;">
      <Context>File;ProjectSubscriptionService</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <PropertyGroup>
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">$(DefineCommonItemSchemas)</DefineCommonReferenceSchemas>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonReferenceSchemas)' == 'true' ">
    <!-- Assembly references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)assemblyreference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedAssemblyReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- COM references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)COMReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedCOMReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- Project references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedProjectReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' ">
    <ProjectCapability Include="&#xD;&#xA;                          AssemblyReferences;&#xD;&#xA;                          COMReferences;&#xD;&#xA;                          ProjectReferences;&#xD;&#xA;                          SharedProjectReferences;&#xD;&#xA;                          OutputGroups;&#xD;&#xA;                          AllTargetOutputGroups;&#xD;&#xA;                          VisualStudioWellKnownOutputGroups;&#xD;&#xA;                          SingleFileGenerators;&#xD;&#xA;                          DeclaredSourceItems;&#xD;&#xA;                          UserSourceItems;&#xD;&#xA;                           " />
    <ProjectCapability Condition=" '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &lt; 8.0 " Include="BuildWindowsDesktopTarget" />
  </ItemGroup>
  <ItemDefinitionGroup Condition=" '$(DefineExplicitDefaults)' == 'true' ">
    <None>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </None>
    <Content>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
    <Compile>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Compile>
    <EmbeddedResource>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
  </ItemDefinitionGroup>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Build Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        _CheckForInvalidConfigurationAndPlatform

    This target checks for errors in statically defined properties.  It always
    gets executed before any other target.
    ============================================================
    -->
  <Target Name="_CheckForInvalidConfigurationAndPlatform">
    <PropertyGroup>
      <_InvalidConfigurationMessageText>The OutputPath property is not set for project '$(MSBuildProjectFile)'.  Please check to make sure that you have specified a valid combination of Configuration and Platform for this project.  Configuration='$(_OriginalConfiguration)'  Platform='$(_OriginalPlatform)'.</_InvalidConfigurationMessageText>
      <_InvalidConfigurationMessageText Condition="'$(BuildingInsideVisualStudio)' == 'true'">$(_InvalidConfigurationMessageText)  This error may also appear if some other project is trying to follow a project-to-project reference to this project, this project has been unloaded or is not included in the solution, and the referencing project does not build using the same or an equivalent Configuration or Platform.</_InvalidConfigurationMessageText>
      <_InvalidConfigurationMessageText Condition="'$(BuildingInsideVisualStudio)' != 'true'">$(_InvalidConfigurationMessageText)  You may be seeing this message because you are trying to build a project without a solution file, and have specified a non-default Configuration or Platform that doesn't exist for this project.</_InvalidConfigurationMessageText>
    </PropertyGroup>
    <Error Condition=" '$(_InvalidConfigurationError)' == 'true' " Text="$(_InvalidConfigurationMessageText)" />
    <Warning Condition=" '$(_InvalidConfigurationWarning)' == 'true' " Text="$(_InvalidConfigurationMessageText)" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Configuration=$(Configuration)" Importance="Low" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Platform=$(Platform)" Importance="Low" />
    <!-- Although we try to ensure a trailing slash, it's possible to circumvent this if the property is set on the command line -->
    <Error Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')" Text="The OutDir property must end with a trailing slash." />
    <Error Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')" Text="The BaseIntermediateOutputPath must end with a trailing slash." />
    <Error Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')" Text="The IntermediateOutputPath must end with a trailing slash." />
    <!-- Also update the value of PlatformTargetAsMSBuildArchitecture per the value of Prefer32Bit.  We are doing 
         this here because Prefer32Bit may be set anywhere in the targets, so we can't depend on it having the 
         correct value when we're trying to figure out PlatformTargetAsMSBuildArchitecture -->
    <PropertyGroup Condition="'$(Prefer32Bit)' == 'true' and ('$(PlatformTarget)' == 'AnyCPU' or '$(PlatformTarget)' == '') and '$(PlatformTargetAsMSBuildArchitectureExplicitlySet)' != 'true'">
      <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        Build

    The main build entry point.
    ============================================================
    -->
  <PropertyGroup>
    <BuildDependsOn>
      BeforeBuild;
      CoreBuild;
      AfterBuild
    </BuildDependsOn>
  </PropertyGroup>
  <Target Name="Build" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(BuildDependsOn)" Returns="$(TargetPath)" />
  <!--
    ============================================================
                                        BeforeBuild

    Redefine this target in your project in order to run tasks just before Build
    ============================================================
    -->
  <Target Name="BeforeBuild" />
  <!--
    ============================================================
                                        AfterBuild

    Redefine this target in your project in order to run tasks just after Build
    ============================================================
    -->
  <Target Name="AfterBuild" />
  <!--
    ============================================================
                                        CoreBuild

    The core build step calls each of the build targets.
    ============================================================
    -->
  <PropertyGroup>
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      Compile;
      ExportWindowsMDFile;
      UnmanagedUnregistration;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
      GenerateManifests;
      GetTargetPath;
      PrepareForRun;
      UnmanagedRegistration;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>
  <Target Name="CoreBuild" DependsOnTargets="$(CoreBuildDependsOn)">
    <OnError ExecuteTargets="_TimeStampAfterCompile;PostBuildEvent" Condition="'$(RunPostBuildEvent)'=='Always' or '$(RunPostBuildEvent)'=='OnOutputUpdated'" />
    <OnError ExecuteTargets="_CleanRecordFileWrites" />
  </Target>
  <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
  <PropertyGroup>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
    <RebuildDependsOn>
      BeforeRebuild;
      Clean;
      $(_ProjectDefaultTargets);
      AfterRebuild;
    </RebuildDependsOn>
    <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' ">
      BeforeRebuild;
      Clean;
      Build;
      AfterRebuild;
    </RebuildDependsOn>
  </PropertyGroup>
  <Target Name="Rebuild" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(RebuildDependsOn)" Returns="$(TargetPath)" />
  <!--
    ============================================================
                                        BeforeRebuild

    Redefine this target in your project in order to run tasks just before Rebuild
    ============================================================
    -->
  <Target Name="BeforeRebuild" />
  <!--
    ============================================================
                                        AfterRebuild

    Redefine this target in your project in order to run tasks just after Rebuild
    ============================================================
    -->
  <Target Name="AfterRebuild" />
  <!--
    ============================================================
                                        BuildGenerateSources

    Redefine this target in your project in order to run tasks for BuildGenerateSources

    Set BuildPassReferences to enable P2P builds
    ============================================================
    -->
  <PropertyGroup>
    <BuildGenerateSourcesAction>Build</BuildGenerateSourcesAction>
  </PropertyGroup>
  <Target Name="BuildGenerateSources" DependsOnTargets="BuildGenerateSourcesTraverse;$(BuildGenerateSourcesAction)" />
  <Target Name="BuildGenerateSourcesTraverse" DependsOnTargets="AssignProjectConfiguration;_SplitProjectReferencesByFileExistence">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildGenerateSources" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)" />
  </Target>
  <!--
    ============================================================
                                        BuildCompile

    Redefine this target in your project in order to run tasks for BuildCompile
    ============================================================
    -->
  <PropertyGroup>
    <BuildCompileAction>Build</BuildCompileAction>
  </PropertyGroup>
  <Target Name="BuildCompile" DependsOnTargets="BuildCompileTraverse;$(BuildCompileAction)" />
  <Target Name="BuildCompileTraverse" DependsOnTargets="AssignProjectConfiguration;_SplitProjectReferencesByFileExistence">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildCompile" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)" />
  </Target>
  <!--
    ============================================================
                                        BuildLink

    Redefine this target in your project in order to run tasks for BuildLink
    ============================================================
    -->
  <PropertyGroup>
    <BuildLinkAction>Build</BuildLinkAction>
  </PropertyGroup>
  <Target Name="BuildLink" DependsOnTargets="BuildLinkTraverse;$(BuildLinkAction)" />
  <Target Name="BuildLinkTraverse" DependsOnTargets="AssignProjectConfiguration;_SplitProjectReferencesByFileExistence">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildLink" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)" />
  </Target>
  <!--
    ============================================================
                                        CopyRunEnvironmentFiles

    Copy environment files necessary to run the user's app to the final directory.
    This is a public target that can be invoked by an IDE.

    This may be used by an IDE to make the app.config file available for running
    the target app.
    ============================================================
    -->
  <Target Name="CopyRunEnvironmentFiles" DependsOnTargets="PrepareForBuild;SetWin32ManifestProperties;_CopyAppConfigFile;_CleanRecordFileWrites" />
  <!--
    ============================================================
                                        Run

    Run the final build output if it is a .EXE
    ============================================================
    -->
  <PropertyGroup>
    <RunDependsOn />
  </PropertyGroup>
  <Target Name="Run" DependsOnTargets="$(RunDependsOn)">
    <Error Text="Cannot run '$(TargetPath)' because project output type is not '.exe'" Condition="'$(TargetExt)'!='.exe'" />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(OutDir)" Condition=" '$(StartWorkingDirectory)' == '' " />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(StartWorkingDirectory)" Condition=" '$(StartWorkingDirectory)' != '' " />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                BuildOnlySettings Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        BuildOnlySettings

    This target is called only when doing a real build.  It is specifically not called during project load.
    ============================================================
    -->
  <PropertyGroup>
    <BuildingProject>false</BuildingProject>
  </PropertyGroup>
  <Target Name="BuildOnlySettings">
    <PropertyGroup>
      <BuildingProject>true</BuildingProject>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForBuild Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareForBuild

    Prepare the prerequisites for building.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareForBuildDependsOn>GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)">
    <ItemGroup>
      <AppConfigWithTargetPath Include="$(AppConfig)" Condition="'$(AppConfig)'!=''">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
    <FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config" Condition="'$(AppConfig)'==''">
      <Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath" />
      <Output TaskParameter="AppConfigFile" PropertyName="AppConfig" />
    </FindAppConfigFile>
    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="True" />
  </Target>
  <!--
    ============================================================
                                        GetFrameworkPaths

    Get the paths for the .NET Framework installation directory

    These paths are not used directly by this .targets file but are available for pre and
    post build steps.
    ============================================================
    -->
  <PropertyGroup>
    <Framework40Dir>@(_TargetFramework40DirectoryItem)</Framework40Dir>
    <Framework35Dir>@(_TargetFramework35DirectoryItem)</Framework35Dir>
    <Framework30Dir>@(_TargetFramework30DirectoryItem)</Framework30Dir>
    <Framework20Dir>@(_TargetFramework20DirectoryItem)</Framework20Dir>
    <!-- Note we need to make the 4.0 FrameworkDir point to the 2.0 location by default since we shipped msbuild 4.0 that way and to change it would be a breaking change.-->
    <FrameworkDir Condition="'$(FrameworkDir)' == '' and ('$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0')">@(_TargetFramework20DirectoryItem)</FrameworkDir>
    <FrameworkDir Condition="'$(FrameworkDir)' == ''">@(_TargetFramework40DirectoryItem)</FrameworkDir>
    <TargetedFrameworkDir Condition="'$(TargetedFrameworkDir)' == ''">@(_TargetedFrameworkDirectoryItem)</TargetedFrameworkDir>
    <FrameworkSDKDir Condition="'$(FrameworkSDKDir)' == ''">@(_TargetFrameworkSDKDirectoryItem)</FrameworkSDKDir>
    <GetFrameworkPathsDependsOn />
  </PropertyGroup>
  <!-- This is a generally overriden target, for example it is overriden in the Microsoft.NETFramework.targets file -->
  <Target Name="GetFrameworkPaths" />
  <!--
    ============================================================
                                        GetReferenceAssemblyPaths

    Get the paths for the Reference Assemblies for the known versions of the
    .NET Framework.

    These paths are used by the build process in order to resolve the correct
    assemblies from the various directories, and to support multi-targeting
    ============================================================
    -->
  <Target Name="GetReferenceAssemblyPaths" DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn)">
    <!-- if TargetFrameworkDirectory doesn't have a custom value, clear it out; that way we can get reference paths and target framework directories all in the right order -->
    <PropertyGroup>
      <TargetFrameworkDirectory Condition="'@(_CombinedTargetFrameworkDirectoriesItem)' == '$(TargetFrameworkDirectory)'" />
    </PropertyGroup>
    <!-- By default if there is no root path set then the task will assume it is Program Files\Reference Assemblies\Microsoft\Framework-->
    <GetReferenceAssemblyPaths Condition="'$(TargetFrameworkMoniker)' != '' and ('$(_TargetFrameworkDirectories)' == '' or '$(_FullFrameworkReferenceAssemblyPaths)' == '')" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)">
      <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories" />
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
      <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <TargetFrameworkDirectory>$(_TargetFrameworkDirectories);$(TargetFrameworkDirectory);$(WinFXAssemblyDirectory)</TargetFrameworkDirectory>
      <TargetFrameworkDirectory Condition="'$(TargetPlatformWinMDLocation)' != '' and Exists('$(TargetPlatformWinMDLocation)')">$(TargetFrameworkDirectory);$(TargetPlatformWinMDLocation)</TargetFrameworkDirectory>
    </PropertyGroup>
    <!-- Remove the AssemblyFolders if no target framework directories could be found. This is to prevent us from
             resolving from the assemblyfolders global location if we are not acutally targeting a framework-->
    <PropertyGroup>
      <RemoveAssemblyFoldersIfNoTargetFramework Condition="'$(RemoveAssemblyFoldersIfNoTargetFramework)' == ''">true</RemoveAssemblyFoldersIfNoTargetFramework>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == '' and '$(AssemblySearchPaths)' != '' and '$(RemoveAssemblyFoldersIfNoTargetFramework)' == 'true'">
      <AssemblySearchPaths>$(AssemblySearchPaths.Replace('{AssemblyFolders}', '').Split(';'))</AssemblySearchPaths>
    </PropertyGroup>
    <ItemGroup Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'">
      <DesignTimeFacadeDirectoryRoots Include="$(TargetFrameworkDirectory)" />
      <DesignTimeFacadeDirectories Include="%(DesignTimeFacadeDirectoryRoots.Identity)Facades\" Condition="Exists('%(DesignTimeFacadeDirectoryRoots.Identity)Facades\')" />
    </ItemGroup>
    <PropertyGroup Condition="'@(DesignTimeFacadeDirectories)' != ''">
      <TargetFrameworkDirectory>$(TargetFrameworkDirectory);@(DesignTimeFacadeDirectories)</TargetFrameworkDirectory>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
      <TargetFrameworkProfile />
    </PropertyGroup>
  </Target>
  <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
  <Target Name="GetTargetFrameworkMoniker" Returns="$(TargetFrameworkMoniker)" />
  <!-- Returns target framework moniker display name. E.g. ".NET Framework 4 Platform Update 1 (KB2478063)" -->
  <Target Name="GetTargetFrameworkMonikerDisplayName" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkMonikerDisplayName)" />
  <!-- Returns semicolon separated list of target framework directories.
  E.g "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0.1\;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\" -->
  <Target Name="GetTargetFrameworkDirectories" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkDirectory)" />
  <!--
    ============================================================
                                        AssignLinkMetadata

       For items of a certain set of whitelisted types, make sure that
       if they are defined in a file other than the project file, that 
       they have "Link" metadata set to an appropriate default. 
    ============================================================
    -->
  <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' ">
    <!-- NONE ITEMS -->
    <AssignLinkMetadata Items="@(None)" Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <None Remove="@(_Temp)" />
      <None Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- CONTENT ITEMS -->
    <AssignLinkMetadata Items="@(Content)" Condition="'@(Content)' != '' and '%(Content.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Content Remove="@(_Temp)" />
      <Content Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- PAGE ITEMS -->
    <AssignLinkMetadata Items="@(Page)" Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Page Remove="@(_Temp)" />
      <Page Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- APPLICATIONDEFINITION ITEMS -->
    <AssignLinkMetadata Items="@(ApplicationDefinition)" Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <ApplicationDefinition Remove="@(_Temp)" />
      <ApplicationDefinition Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- EMBEDDEDRESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(EmbeddedResource)" Condition="'@(EmbeddedResource)' != '' and '%(EmbeddedResource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temp)" />
      <EmbeddedResource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PreBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PreBuildEvent

    Run the pre-build event if there is one.
    ============================================================
    -->
  <PropertyGroup>
    <PreBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PreBuildEvent" Condition="'$(PreBuildEvent)'!=''" DependsOnTargets="$(PreBuildEventDependsOn)">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedUnregistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedUnregistration

    If the main assembly had previously been registered for COM interop, unregister it now.
    We will re-register the new version after it has been built.
    ============================================================
    -->
  <PropertyGroup>
    <UnmanagedUnregistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedUnregistration" Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or&#xD;&#xA;                    ('$(_AssemblyTimestampBeforeCompile)' == '')) and&#xD;&#xA;                   Exists('@(_UnmanagedRegistrationCache)')" DependsOnTargets="$(UnmanagedUnregistrationDependsOn)">
    <PropertyGroup>
      <UnregisterAssemblyMSBuildArchitecture Condition="'$(UnregisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</UnregisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(UnregisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to 
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the 
           corresponding comment in GenerateResource. -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == '' and &#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(UnregisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</UnregisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)" MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)" MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveReferences Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                     GetTargetFrameworkVersion

    This stand-alone target returns the target framework version (i.e. v3.5, v4.0, etc.)
    that would be used if we built this project.

    ============================================================
    -->
  <Target Name="GetTargetFrameworkVersion" Returns="$(TargetFrameworkVersion)" />
  <!--
    ============================================================
                                        ResolveReferences
    ============================================================
    -->
  <PropertyGroup>
    <ResolveReferencesDependsOn>
      BeforeResolveReferences;
      AssignProjectConfiguration;
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      ResolveNativeReferences;
      ResolveAssemblyReferences;
      GenerateBindingRedirects;
      ResolveComReferences;
      AfterResolveReferences
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveReferences" DependsOnTargets="$(ResolveReferencesDependsOn)" />
  <!--
    ============================================================
                                        BeforeResolveReferences

    Redefine this target in your project in order to run tasks just before ResolveReferences
    ============================================================
    -->
  <Target Name="BeforeResolveReferences" />
  <!--
    ============================================================
                                        AfterResolveReferences

    Redefine this target in your project in order to run tasks just after ResolveReferences
    ============================================================
    -->
  <Target Name="AfterResolveReferences" />
  <!--
    ============================================================
                                        AssignProjectConfiguration

    Assigns the appropriate configuration to each project in the list of project references passed in.
    Adds to the project references passed in any project references implied by dependencies expressed in the solution file, if any.

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(ProjectReferenceWithConfiguration) - the list of project references (MSBuild and potentially VSIP projects)
                                               with metadata values FullConfiguration, Configuration, Platform,
                                               SetConfiguration, and SetPlatform
    ============================================================
    -->
  <Target Name="AssignProjectConfiguration" Condition="'$(CurrentSolutionConfigurationContents)' != '' or '@(ProjectReference)'!=''">
    <PropertyGroup>
      <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration Condition="'$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)' == ''">true</OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildingSolutionFile)' == 'true')">true</ShouldUnsetParentConfigurationAndPlatform>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == ''">false</ShouldUnsetParentConfigurationAndPlatform>
      <!-- Web Application projects can "secretly" reference Silverlight projects, which can take project dependencies on that same Web Application.  If the project 
           dependencies are promoted to project references, this ends up creating a situation where we have a circular reference between the two projects.  We don't 
           want this to happen, so just turn off synthetic project reference generation for Silverlight projects. -->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(TargetFrameworkIdentifier)' == 'Silverlight'">false</AddSyntheticProjectReferencesForSolutionDependencies>
      <!-- Inside VS, we do not need to add synthetic references, as VS already organizes the build per any solution-level dependencies; we only do this on the command line-->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</AddSyntheticProjectReferencesForSolutionDependencies>
    </PropertyGroup>
    <!-- Assign a project configuration to each project reference if we're building a solution file. -->
    <AssignProjectConfiguration ProjectReferences="@(ProjectReference)" CurrentProject="$(MSBuildProjectFullPath)" CurrentProjectConfiguration="$(Configuration)" CurrentProjectPlatform="$(Platform)" DefaultToVcxPlatformMapping="$(DefaultToVcxPlatformMapping)" VcxToDefaultPlatformMapping="$(VcxToDefaultPlatformMapping)" OutputType="$(OutputType)" ResolveConfigurationPlatformUsingMappings="false" SolutionConfigurationContents="$(CurrentSolutionConfigurationContents)" AddSyntheticProjectReferencesForSolutionDependencies="$(AddSyntheticProjectReferencesForSolutionDependencies)" OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration="$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)" ShouldUnsetParentConfigurationAndPlatform="$(ShouldUnsetParentConfigurationAndPlatform)">
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME PROJECTREFERENCEWITHCONFIGURATION INSTEAD -->
      <Output TaskParameter="AssignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="AssignedProjects" ItemName="ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="ProjectReferenceWithConfiguration" />
    </AssignProjectConfiguration>
    <ItemGroup>
      <_ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(_ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(_ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </_ProjectReferenceWithConfiguration>
      <ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </ProjectReferenceWithConfiguration>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SplitProjectReferencesByFileExistence

    Split referenced projects into two lists: those that exist on
    disk and those that don't.
    ============================================================
    -->
  <Target Name="_SplitProjectReferencesByFileExistence">
    <!--
        Use this task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE.  The IDE only includes non-MSBuild projects in the output list.  We'll
        use MSBuild to resolve MSBuild projects.
        This task will resolve VSIP (3rd party) project references and create a new item list with only project references
        to projects in the MSBuild format.
        -->
    <ResolveNonMSBuildProjectOutput ProjectReferences="@(ProjectReferenceWithConfiguration)" PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)" Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(ProjectReferenceWithConfiguration)'!=''">
      <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedProjectReferencePaths" />
      <Output TaskParameter="UnresolvedProjectReferences" ItemName="_MSBuildProjectReference" />
    </ResolveNonMSBuildProjectOutput>
    <!--
       If building from the command line, simply copy the ProjectReferenceWithConfiguration item list to _MSBuildProjectReference,
       since we have to assume all projects are in the MSBuild format. We have no way of building
       VSIP (3rd party) projects from the command line.
       -->
    <ItemGroup>
      <_MSBuildProjectReference Include="@(ProjectReferenceWithConfiguration)" Condition="'$(BuildingInsideVisualStudio)'!='true' and '@(ProjectReferenceWithConfiguration)'!=''" />
    </ItemGroup>
    <!-- Break the project list into two lists: those that exist on disk and those that don't. -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Include="@(_MSBuildProjectReference)" Condition="Exists('%(Identity)')" />
      <_MSBuildProjectReferenceNonexistent Include="@(_MSBuildProjectReference)" Condition="!Exists('%(Identity)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveProjectReferences

    Build referenced projects:

        [IN]
        @(ProjectReferenceWithConfiguration) - The list of project references.

        [OUT]
        @(_ResolvedNativeProjectReferencePaths) - Paths to referenced native projects.
        @(_ResolvedProjectReferencePaths) - Paths to referenced managed projects.
    ============================================================
    -->
  <!-- By default, the outputs of project references are passed to the compiler -->
  <ItemDefinitionGroup>
    <ProjectReference>
      <!-- Target to build in the project reference; by default, this property is blank, indicating the default targets-->
      <Targets>$(ProjectReferenceBuildTargets)</Targets>
      <!-- Extra item type to emit outputs of the destination into. Defaults to blank. To emit only into this list, set the ReferenceOutputAssembly metadata to false as well. -->
      <OutputItemType />
      <ReferenceSourceTarget>ProjectReference</ReferenceSourceTarget>
    </ProjectReference>
  </ItemDefinitionGroup>
  <Target Name="ResolveProjectReferences" DependsOnTargets="AssignProjectConfiguration;_SplitProjectReferencesByFileExistence" Returns="@(_ResolvedNativeProjectReferencePaths);@(_ResolvedProjectReferencePaths)">
    <!--
        When building this project from the IDE, just gather the referenced build outputs.
        The IDE will already have built the project, so there's no need to do it again here.

        The ContinueOnError setting is here so that, during project load, as
        much information as possible will be passed to the compilers.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetPath" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        QUIRKING FOR DEV10

        In the 4.0 version of the targets, we built the targets specified in the Targets metadata in addition to 
        GetTargetPath when building in the IDE.  In 4.5, we changed this to just GetTargetPath because it was 
        causing performance trouble with certain systems that specified targets that did a significant amount of 
        work in the Targets metadata, expecting them to only build when doing a real build.  

        However, that change broke C++ unit testing in Dev10 + 4.5 scenarios, because they required use of the 
        Targets metadata in order to get design time builds to work properly.  Thus, we need to make sure we 
        restore the Dev10 behavior when building on Dev10. 
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="%(_MSBuildProjectReferenceExistent.Targets);GetTargetPath" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' == '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Build referenced projects when building from the command line.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="%(_MSBuildProjectReferenceExistent.Targets)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetNativeManifest" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="NativeReference" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)' == 'true'" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ResolveableAssembly)' == 'false'" />
      <!--
          Copy OriginalItemSpec to OriginalProjectReferenceItemSpec, so that when ResolveAssemblyReferences
          takes these items and resolves them to ReferencePath, we can still recover the _real_ OriginalItemSpec
          for the unresolved reference items.
          -->
      <_ResolvedProjectReferencePaths>
        <OriginalProjectReferenceItemSpec>%(_ResolvedProjectReferencePaths.OriginalItemSpec)</OriginalProjectReferenceItemSpec>
      </_ResolvedProjectReferencePaths>
    </ItemGroup>
    <!-- Issue a warning for each non-existent project. -->
    <Warning Text="The referenced project '%(_MSBuildProjectReferenceNonexistent.Identity)' does not exist." Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != ''" />
  </Target>
  <Target Name="ResolveProjectReferencesDesignTime" Returns="@(_ProjectReferencesFromRAR);@(_ResolvedNativeProjectReferencePaths)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences">
    <!-- We need to do this here because we only want project references which have passed through rar and have not been unresolved due to violating some MT rule
        which means we need to pull the project references out of the referencepath item because they will only exist there if they were correctly resolved.
    -->
    <ItemGroup>
      <_ProjectReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))">
        <OriginalItemSpec>%(ReferencePath.ProjectReferenceOriginalItemSpec)</OriginalItemSpec>
      </_ProjectReferencesFromRAR>
    </ItemGroup>
  </Target>
  <Target Name="ExpandSDKReferencesDesignTime" Returns="@(ReferencesFromSDK)" DependsOnTargets="ExpandSDKReferences" />
  <!--
    ============================================================
                                        GetTargetPath

    This stand-alone target returns the name of the build product (i.e. EXE, DLL)
    that would be produced if we built this project.
    ============================================================
    -->
  <PropertyGroup>
    <GetTargetPathDependsOn>$(GetTargetPathDependsOn)</GetTargetPathDependsOn>
  </PropertyGroup>
  <Target Name="GetTargetPath" DependsOnTargets="$(GetTargetPathDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)">
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetTargetPathWithTargetPlatformMoniker

    This stand-alone target returns the name and version of the target platform for this project.

    NOTE: The functionality of this target has been subsumed by GetTargetPath.  This target is
    provided purely for compat reasons.
    ============================================================
    -->
  <PropertyGroup>
    <GetTargetPathWithTargetPlatformMonikerDependsOn>$(GetTargetPathDependsOn); GetTargetPath</GetTargetPathWithTargetPlatformMonikerDependsOn>
  </PropertyGroup>
  <Target Name="GetTargetPathWithTargetPlatformMoniker" DependsOnTargets="$(GetTargetPathWithTargetPlatformMonikerDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" />
  <!--
    ============================================================
                                        GetNativeManifest

    Compute the manifest item for this project.

        [IN]
        $(_DeploymentApplicationManifestIdentity) - the manifest identity
        @(ApplicationManifest)         - the original application manifest item

        [OUT]
        @(ComputedApplicationManifest) - application manifest item with full hint path, if generated
    ============================================================
    -->
  <Target Name="GetNativeManifest" Returns="@(ComputedApplicationManifest)">
    <ItemGroup>
      <ComputedApplicationManifest Include="$(_DeploymentApplicationManifestIdentity)" Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe' and Exists('%(_ApplicationManifestFinal.FullPath)')">
        <HintPath>%(_ApplicationManifestFinal.FullPath)</HintPath>
      </ComputedApplicationManifest>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveNativeReferences

    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(_DeploymentNativePrerequisite)   - List of native assembly prerequisites contained in the manifest.
        @(ComClassReference)    - List of COM components contained in the manifest.
        @(COMReferenceFromNative) List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(_DeploymentLooseManifestFile)    - List of extra files that should be published.
    ============================================================
    -->
  <Target Name="ResolveNativeReferences" Condition="'@(NativeReference)'!=''" DependsOnTargets="ResolveProjectReferences">
    <ResolveNativeReference NativeReferences="@(NativeReference)" AdditionalSearchPaths="$(ReferencePath);$(OutDir)">
      <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile" />
      <Output TaskParameter="ContainedPrerequisiteAssemblies" ItemName="_DeploymentNativePrerequisite" />
      <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference" />
      <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReferenceFromNative" />
      <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference" />
      <Output TaskParameter="ContainedLooseEtcFiles" ItemName="_DeploymentLooseManifestFile" />
    </ResolveNativeReference>
  </Target>
  <!--
    ============================================================

                                        ResolveAssemblyReferences

    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(_ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to the Copy Local flag in IDE.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(_ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(_ReferenceSerializationAssemblyPaths) - Paths to XML serialization assemblies created by sgen.
        @(_ReferenceScatterPaths) - Paths to scatter files.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    ============================================================
    -->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      PrepareForBuild;
      ResolveSDKReferences;
      ExpandSDKReferences;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveAssemblyReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)">
    <ItemGroup>
      <_ReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
      <_ReferenceInstalledAssemblySubsets Include="$(TargetFrameworkSubset)" />
    </ItemGroup>
    <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
    <PropertyGroup>
      <ResolveAssemblyReferencesStateFile Condition="'$(BuildingProject)'=='true'">$(IntermediateOutputPath)$(MSBuildProjectFile)ResolveAssemblyReference.cache</ResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <!-- Make an App.Config item that exists when AutoUnify is false. -->
    <ItemGroup>
      <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Default in task is true -->
      <_FindDependencies Condition="'$(BuildingProject)' != 'true' and '$(_ResolveReferenceDependencies)' != 'true'">false</_FindDependencies>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == '' and '$(TraceDesignTime)' != 'true' and '$(BuildingProject)' == 'false'">true</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == ''">false</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Warning</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    </PropertyGroup>
    <ItemGroup>
      <!-- Remove any references which we have added as explicit reference so that we do not get duplicates. We need to make sure we do not have duplicates
             because this confuses the IDE  when it tries to compare the list of references passed in to the list of resolved references. If it does not match then the
             ide will show one of the references as not resolved, this will not break the build but is a display issue -->
      <Reference Remove="$(AdditionalExplicitAssemblyReferences)" />
      <Reference Include="$(AdditionalExplicitAssemblyReferences)">
        <Implicit>true</Implicit>
      </Reference>
    </ItemGroup>
    <ResolveAssemblyReference Assemblies="@(Reference)" AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)" TargetFrameworkDirectories="@(_ReferenceInstalledAssemblyDirectory)" InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)" IgnoreDefaultInstalledAssemblyTables="$(IgnoreDefaultInstalledAssemblyTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" CandidateAssemblyFiles="@(Content);@(None)" SearchPaths="$(AssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)" AutoUnify="$(AutoUnifyAssemblyReferences)" SupportsBindingRedirectGeneration="$(GenerateBindingRedirectsOutputType)" IgnoreVersionForFrameworkReferences="$(IgnoreVersionForFrameworkReferences)" FindDependencies="$(_FindDependencies)" FindSatellites="$(BuildingProject)" FindSerializationAssemblies="$(BuildingProject)" FindRelatedFiles="$(BuildingProject)" Silent="$(ResolveAssemblyReferencesSilent)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(ResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" LatestTargetFrameworkDirectories="@(LatestTargetFrameworkDirectories)" CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)" DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)" ResolvedSDKReferences="@(ResolvedSDKReference)" WarnOrErrorOnTargetArchitectureMismatch="$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)" IgnoreTargetFrameworkAttributeVersionMismatch="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)" ContinueOnError="$(ContinueOnError)" Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths" />
      <Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths" />
      <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths" />
      <Output TaskParameter="SerializationAssemblyFiles" ItemName="_ReferenceSerializationAssemblyPaths" />
      <Output TaskParameter="ScatterFiles" ItemName="_ReferenceScatterPaths" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirects
    Inject the binding redirects into the app config file based on suggested redirects as output from
    ResolveAssemblyReferences.

        [IN]
        @(AppConfigWithTargetPath) - Path to the source app config file. This can be null if the project
                                     doesn't contain an app config file.
        $(TargetFileName) -          The file name of the build target.

        [OUT]
        @(OutputAppConfigFile) -     Path to the output app config file in the intermediate directory.
        
    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirects" Inputs="$(MSBuildAllProjects);@(AppConfigFile);$(ResolveAssemblyReferencesStateFile);$(IntermediateOutputPath);@(SuggestedBindingRedirects)" Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'">
    <GenerateBindingRedirects AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)" SuggestedRedirects="@(SuggestedBindingRedirects)">
      <Output TaskParameter="OutputAppConfigFile" ItemName="FileWrites" />
    </GenerateBindingRedirects>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirectsUpdateAppConfig
    Updates the project to use the generated app.config content.  This needs to run regardless of 
    inputs/outputs so it is seperate from GenerateBindingRedirects.
    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirectsUpdateAppConfig" AfterTargets="GenerateBindingRedirects" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">
    <PropertyGroup>
      <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
    </PropertyGroup>
    <ItemGroup>
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="$(AppConfig)">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ===========================================================================================
                                        GetInstalledSDKs

    Gets the list of SDKs installed in the SDKDirectoryRoot and SDKRegistryRoot locations

    These paths are used by the ResolveSDKReference task and the ResolveAssemblyReference task.
    ===========================================================================================
  -->
  <PropertyGroup>
    <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
    <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
    <!-- Manifest driven extension SDK locations -->
    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(MSBuildProgramFiles32)\Windows Kits\10</SDKExtensionDirectoryRoot>
    <!-- UAP projects by default should support Windows 8.1 SDKs -->
    <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
    <TargetPlatformIdentifierWindows81 Condition="'$(TargetPlatformIdentifierWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">Windows</TargetPlatformIdentifierWindows81>
    <TargetPlatformVersionWindows81 Condition="'$(TargetPlatformVersionWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">8.1</TargetPlatformVersionWindows81>
    <!-- Desktop and phone SDKs often have the exact same identifiers, don't enable phone by default -->
    <SupportWindowsPhone81SDKs Condition="'$(SupportWindowsPhone81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">false</SupportWindowsPhone81SDKs>
    <TargetPlatformIdentifierWindowsPhone81 Condition="'$(TargetPlatformIdentifierWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">WindowsPhoneApp</TargetPlatformIdentifierWindowsPhone81>
    <TargetPlatformVersionWindowsPhone81 Condition="'$(TargetPlatformVersionWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">8.1</TargetPlatformVersionWindowsPhone81>
  </PropertyGroup>
  <Target Name="GetInstalledSDKLocations" DependsOnTargets="$(GetInstalledSDKLocationsDependsOn)" Returns="@(InstalledSDKLocations)">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(SDKReference)' != ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <!-- Also lookup 8.1 SDKs if requested -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindows81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindows81)" Condition="'@(SDKReference)' != '' and '$(SupportWindows81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindows81)' != '' and '$(TargetPlatformVersionWindows81)' != ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindowsPhone81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindowsPhone81)" Condition="'@(SDKReference)' != '' and '$(SupportWindowsPhone81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindowsPhone81)' != '' and '$(TargetPlatformVersionWindowsPhone81)' != ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
  </Target>
  <!--
    ============================================================

                                        ResolveSDKReferences

    Given a list of SDKReference items and a list of resolved winmd files which may contain metadata as to which sdk they came from
    we need to find the sdk root folders on disk and populate a ResolvedSDKReference item which has the full path to the SDK ROOT 
    and the sdk identity as a piece of metadata.

        [IN]
        @(SDKReference) - List of sdk references (the identity in the sdk manifest file).
        @(ReferencePath) -List of resolved assemblies, we are interested in the ones which have IsWinMDFile set to true.

        [OUT]
        @(ResolvedSDKReference) - Full path to the root of the SDK
    ============================================================
  -->
  <PropertyGroup>
    <ResolveSDKReferencesDependsOn>
      GetInstalledSDKLocations
    </ResolveSDKReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Debug'">Debug</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Release'">Retail</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == ''">Retail</TargetedSDKConfiguration>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">$(ProcessorArchitecture)</TargetedSDKArchitecture>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">Neutral</TargetedSDKArchitecture>
  </PropertyGroup>
  <PropertyGroup>
    <ShouldMarkCertainSDKReferencesAsRuntimeOnly Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == ''">true</ShouldMarkCertainSDKReferencesAsRuntimeOnly>
  </PropertyGroup>
  <ItemGroup Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == 'true'">
    <!-- Dependencies that are specified as runtime-only dependencies. Therefore the associated files are not used to build Appx package.  -->
    <!-- TODO: Do we need to do anything like this for the new SDK? -->
    <RuntimeReferenceOnlySDKDependencies Condition="'$(TargetPlatformVersion)' == '8.1'" Include="Microsoft.VCLibs, Version=11.0" />
  </ItemGroup>
  <Target Name="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" DependsOnTargets="$(ResolveSDKReferencesDependsOn)">
    <ResolveSDKReference SDKReferences="@(SDKReference)" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(SDKReference)'!=''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedSDKReference" />
    </ResolveSDKReference>
  </Target>
  <Target Name="ResolveSDKReferencesDesignTime" Returns="@(ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferences" />
  <!--
    ============================================================

                                        FindInvalidProjectReferences

    Find project to project references with target platform version higher than the one used by the current project and 
    creates a list of invalid references to be unresolved. It issues a warning for each invalid reference.

        [IN]
        $(TargetPlatformVersion) - Project's target platform version
        @(_ProjectReferenceTargetPlatformMonikers) - List of monikers of all referenced projects gathered by the helper 
                                                     target GetTargetPlatformMonikers.

        [OUT]
    @(InvalidProjectReferences) - List of invalid project references

    ============================================================
    -->
  <PropertyGroup>
    <FindInvalidProjectReferencesDependsOn>
      GetReferenceTargetPlatformMonikers
    </FindInvalidProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="FindInvalidProjectReferences" Condition="'$(FindInvalidProjectReferences)' == 'true'" DependsOnTargets="$(FindInvalidProjectReferencesDependsOn)">
    <FindInvalidProjectReferences TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" ProjectReferences="@(TargetPathWithTargetPlatformMoniker)">
      <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
    </FindInvalidProjectReferences>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(InvalidProjectReferences)" />
    </ItemGroup>
  </Target>
  <Target Name="GetReferenceTargetPlatformMonikers" DependsOnTargets="AssignProjectConfiguration;_SplitProjectReferencesByFileExistence">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Targets="GetTargetPathWithTargetPlatformMoniker" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
    </MSBuild>
  </Target>
  <!--
    ============================================================

                       ExpandSDKReferences

        After we have resolved the sdk refrence we need to make sure that we automatically include the references which are part of the SDK (both winmd and dll)
        as part of the assemblies passed to the compiler.

        Project systems or project which do not want to reference all dlls or winmd files should override this target to do nothing.
   ============================================================
    -->
  <PropertyGroup>
    <ExpandSDKReferencesDependsOn>
      ResolveSDKReferences
    </ExpandSDKReferencesDependsOn>
    <ExpandSDKAllowedReferenceExtensions Condition="'$(ExpandSDKAllowedReferenceExtensions)' == ''">
      .winmd;
      .dll
    </ExpandSDKAllowedReferenceExtensions>
  </PropertyGroup>
  <Target Name="ExpandSDKReferences" Returns="@(ReferencesFromSDK)" DependsOnTargets="$(ExpandSDKReferencesDependsOn)">
    <GetSDKReferenceFiles ResolvedSDKReferences="@(ResolvedSDKReference)" ReferenceExtensions="$(ExpandSDKAllowedReferenceExtensions)" TargetSDKIdentifier="$(SDKIdentifier)" TargetSDKVersion="$(SDKVersion)" LogRedistFilesList="$(GetSDKReferenceFilesLogRedistFilesList)" LogRedistConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogRedistConflictsWithinSDKAsWarning)" LogRedistConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogRedistConflictsBetweenSDKsAsWarning)" LogReferencesList="$(GetSDKReferenceFilesLogReferencesList)" LogReferenceConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsWithinSDKAsWarning)" LogReferenceConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsBetweenSDKsAsWarning)" CacheFileFolderPath="$(GetSDKReferenceFilesCacheFolder)" LogCacheFileExceptions="$(GetSDKReferenceFilesLogCacheFileExceptions)" Condition="'@(ResolvedSDKReference)'!=''">
      <Output TaskParameter="References" ItemName="ReferencePath" />
      <Output TaskParameter="References" ItemName="ReferencesFromSDK" />
      <Output TaskParameter="References" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="RedistFiles" ItemName="ResolvedRedistFiles" />
    </GetSDKReferenceFiles>
  </Target>
  <!--
    ============================================================

                                        ExportWindowsMDFile

    When a project is generating a a winmd file through c# or vb, ect the compiler will create a WinMDModule file. This file needs to be run
    through the winmdexp tool in order to generate the resulting WinMD file.

    ===========================================================
    -->
  <Target Name="ExportWindowsMDFile" DependsOnTargets="Compile" Condition="'$(ExportWinMDFile)' == 'true'" Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePath);$(MSBuildAllProjects)" Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)">
    <PropertyGroup>
      <!-- Will be copied by the "copy WinMD artifacts" step instead -->
      <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>
      <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</WinMdExpToolPath>
      <WinMdExpUTF8Ouput Condition="'$(WinMdExpUTF8Ouput)' == ''">true</WinMdExpUTF8Ouput>
    </PropertyGroup>
    <WinMDExp WinMDModule="@(IntermediateAssembly)" References="@(ReferencePath)" DisabledWarnings="$(WinMdExpNoWarn)" InputDocumentationFile="@(DocFileItem)" OutputDocumentationFile="$(WinMDOutputDocumentationFile)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" InputPDBFile="@(_DebugSymbolsIntermediatePath)" OutputPDBFile="$(WinMDExpOutputPdb)" OutputWindowsMetadataFile="$(_IntermediateWindowsMetadataPath)" EnvironmentVariables="$(WinMDExpEnvironment)" UTF8Output="$(WinMdExpUTF8Ouput)" SdkToolsPath="$(WinMdExpToolPath)" AssemblyUnificationPolicy="$(WinMDExpAssemblyUnificationPolicy)">
      <Output TaskParameter="OutputWindowsMetadataFile" ItemName="FileWrites" />
    </WinMDExp>
    <ItemGroup>
      <WinMDExpArtifacts Include="$(_IntermediateWindowsMetadataPath)" />
      <WinMDExpArtifacts Include="$(WinMDOutputDocumentationFile)" />
      <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)" />
      <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveAssemblyReferencesDesignTime" Returns="@(_ReferencesFromRAR)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences">
    <!-- We need to do this here because we only want references which have been passed into rar but are not project to project references. -->
    <ItemGroup>
      <_ReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ProjectDesignTimeAssemblyResolutionSearchPaths Condition=" '$(ProjectDesignTimeAssemblyResolutionSearchPaths)' == '' ">
      {CandidateAssemblyFiles};
      $(ReferencePath);
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
      {RawFileName};
      $(TargetDir)
    </ProjectDesignTimeAssemblyResolutionSearchPaths>
  </PropertyGroup>
  <!--
    ==============================================================

                                       DesignTimeResolveAssemblyReferences

    Given the list of assemblies, resolve their reference paths.
    This target is called by Visual Studio at run time in order to filter references
    according to the targeted framework.

        [IN]
        @(DesignTimeReference) - List of assembly references as simple/fusion names.


        [OUT]
        @(ReferencePath) - Paths to resolved primary files.

    ==============================================================
    -->
  <PropertyGroup>
    <DesignTimeResolveAssemblyReferencesDependsOn>
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      ResolveReferences
    </DesignTimeResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeResolveAssemblyReferences" Condition="'$(DesignTimeReference)'!=''" DependsOnTargets="$(DesignTimeResolveAssemblyReferencesDependsOn)">
    <ItemGroup>
      <_DesignTimeReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
    </ItemGroup>
    <PropertyGroup>
      <DesignTimeResolveAssemblyReferencesStateFile Condition="'$(BuildingProject)'=='true'">$(IntermediateOutputPath)$(MSBuildProjectFile)DesignTimeResolveAssemblyReferences.cache</DesignTimeResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">
        {CandidateAssemblyFiles};
        $(ReferencePath);
        {HintPathFromItem};
        {TargetFrameworkDirectory};
        {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
        {RawFileName};
        $(OutDir)
      </DesignTimeAssemblySearchPaths>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeFindDependencies Condition=" '$(DesignTimeFindDependencies)' == '' ">false</DesignTimeFindDependencies>
      <DesignTimeIgnoreVersionForFrameworkReferences Condition=" '$(DesignTimeIgnoreVersionForFrameworkReferences)' == '' ">false</DesignTimeIgnoreVersionForFrameworkReferences>
      <DesignTimeFindSatellites Condition=" '$(DesignTimeFindSatellites)' == '' ">false</DesignTimeFindSatellites>
      <DesignTimeFindSerializationAssemblies Condition=" '$(DesignTimeFindSerializationAssemblies)' == '' ">false</DesignTimeFindSerializationAssemblies>
      <DesignTimeFindRelatedFiles Condition=" '$(DesignTimeFindRelatedFiles)' == '' ">false</DesignTimeFindRelatedFiles>
      <DesignTimeSilentResolution Condition=" '$(DesignTimeSilentResolution)' == '' and '$(TraceDesignTime)' != 'true'">true</DesignTimeSilentResolution>
      <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">false</DesignTimeAutoUnify>
    </PropertyGroup>
    <ItemGroup>
      <_DesignTimeReferenceAssemblies Include="$(DesignTimeReference)" />
    </ItemGroup>
    <ItemGroup>
      <_RARResolvedReferencePath Include="@(ReferencePath)" />
      <ReferencePath Remove="@(ReferencePath)" />
    </ItemGroup>
    <ResolveAssemblyReference Assemblies="@(_DesignTimeReferenceAssemblies)" TargetFrameworkDirectories="@(_DesignTimeReferenceInstalledAssemblyDirectory)" SearchPaths="$(DesignTimeAssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" CandidateAssemblyFiles="@(Content);@(None);@(_RARResolvedReferencePath)" FindDependencies="$(DesignTimeFindDependencies)" AutoUnify="$(DesignTimeAutoUnify)" IgnoreVersionForFrameworkReferences="$(DesignTimeIgnoreVersionForFrameworkReferences)" FindSatellites="$(DesignTimeFindSatellites)" FindSerializationAssemblies="$(DesignTimeFindSerializationAssemblies)" FindRelatedFiles="$(DesignTimeFindRelatedFiles)" Silent="$(DesignTimeSilentResolution)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(DesignTimeResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" ResolvedSDKReferences="@(ResolvedSDKReference)" IgnoreTargetFrameworkAttributeVersionMismatch="$(DesignTimeIgnoreTargetFrameworkAttributeVersionMismatch)">
      <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================
                                        ResolveComReferences

    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(BaseIntermediateOutputPath) - The output directory in which to generate wrapper assemblies

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories.
    ============================================================
    -->
  <PropertyGroup>
    <ComReferenceExecuteAsTool Condition="'$(ComReferenceExecuteAsTool)'==''">false</ComReferenceExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResolveComReferences" Condition="'@(COMReference)'!='' or '@(COMFileReference)'!=''" Returns="@(ReferencePath)" DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences">
    <PropertyGroup Condition=" '$(InteropOutputPath)' == '' ">
      <InteropOutputPath>$(IntermediateOutputPath)</InteropOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(InteropOutputPath)" />
    <!--
        Note: This task should not be batched, since it relies on having all the COM references fed into it at once.
        -->
    <PropertyGroup>
      <ResolveComReferenceMSBuildArchitecture Condition="'$(ResolveComReferenceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</ResolveComReferenceMSBuildArchitecture>
      <ResolveComReferenceToolPath Condition="'$(ResolveComReferenceToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResolveComReferenceToolPath>
      <ResolveComReferenceSilent Condition="'$(ResolveComReferenceSilent)' == ''">false</ResolveComReferenceSilent>
    </PropertyGroup>
    <ResolveComReference TypeLibNames="@(COMReference)" TypeLibFiles="@(COMFileReference)" ResolvedAssemblyReferences="@(ReferencePath)" WrapperOutputDirectory="$(InteropOutputPath)" IncludeVersionInInteropName="$(IncludeVersionInInteropName)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" StateFile="@(_ResolveComReferenceCache)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetProcessorArchitecture="$(ProcessorArchitecture)" NoClassMembers="$(ComReferenceNoClassMembers)" Silent="$(ResolveComReferenceSilent)" EnvironmentVariables="$(ResolveComReferenceEnvironment)" SdkToolsPath="$(ResolveComReferenceToolPath)" ExecuteAsTool="$(ComReferenceExecuteAsTool)" MSBuildArchitecture="$(ResolveComReferenceMSBuildArchitecture)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="ComReferenceWrappers" />
      <Output TaskParameter="ResolvedFiles" ItemName="FileWrites" />
      <!-- This output list only includes items with Isolated attribute set to True.  It's done by the task itself. -->
      <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules" />
    </ResolveComReference>
    <ItemGroup>
      <FileWrites Include="@(_ResolveComReferenceCache)" />
      <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveComReferencesDesignTime" Returns="@(ComReferenceWrappers)" DependsOnTargets="ResolveComReferences" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareResources Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareResources

    Prepare resources for the Compile step.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareResourcesDependsOn>
      PrepareResourceNames;
      ResGen;
      CompileLicxFiles
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResources" DependsOnTargets="$(PrepareResourcesDependsOn)" />
  <!--
    ============================================================
                                        PrepareResourceNames

    Prepare the names of resource files.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareResourceNamesDependsOn>
      AssignTargetPaths;
      SplitResourcesByCulture;
      CreateManifestResourceNames;
      CreateCustomManifestResourceNames
    </PrepareResourceNamesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResourceNames" DependsOnTargets="$(PrepareResourceNamesDependsOn)" />
  <!--
    ============================================================
                                        AssignTargetPaths

    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    ============================================================
    -->
  <PropertyGroup>
    <AssignTargetPathsDependsOn />
  </PropertyGroup>
  <Target Name="AssignTargetPaths" DependsOnTargets="$(AssignTargetPathsDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- AssignTargetPath generates TargetPath metadata that is consumed by CreateManifestResourceNames target for manifest name generation -->
    <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
      <EmbeddedResource Remove="@(_Temporary)" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_NoneWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(BaseApplicationManifest)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)" Condition="'@(_DeploymentBaseManifestWithTargetPath)'=='' and '%(None.Extension)'=='.manifest'">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
  </Target>
  <!--
    ============================================================
                                        GetItemTargetPaths

    This target returns all items that have TargetPath metadata assigned by the AssignTargetPaths target.
    ============================================================
    -->
  <Target Name="GetItemTargetPaths" DependsOnTargets="AssignTargetPaths" Returns="&#xD;&#xA;      @(EmbeddedResource);&#xD;&#xA;      @(ContentWithTargetPath);&#xD;&#xA;      @(_NoneWithTargetPath);&#xD;&#xA;      @(_DeploymentBaseManifestWithTargetPath);&#xD;&#xA;      " />
  <!--
    ============================================================
                                        SplitResourcesByCulture

    Split EmbeddedResource items into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized. Also adds Type and Culture
    metadata. Type indicates whether the resource is "Resx" or "Non-Resx".

        [IN]/[OUT]
        @(EmbeddedResource) - The raw list of resources.

        [OUT]
        @(_LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
    ============================================================
    -->
  <Target Name="SplitResourcesByCulture" DependsOnTargets="AssignTargetPaths">
    <Warning Condition="'@(ResxWithNoCulture)'!=''" Code="MSB9000" Text="ResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead." />
    <Warning Condition="'@(ResxWithCulture)'!=''" Code="MSB9001" Text="ResxWithCulture item type is deprecated. Use EmbeddedResource items instead." />
    <Warning Condition="'@(NonResxWithCulture)'!=''" Code="MSB9002" Text="NonResxWithCulture item type is deprecated. Use EmbeddedResource items instead." />
    <Warning Condition="'@(NonResxWithNoCulture)'!=''" Code="MSB9003" Text="NonResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead." />
    <ItemGroup>
      <_LicxFile Include="@(EmbeddedResource)" Condition="'%(Extension)'=='.licx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <EmbeddedResource Include="@(ResxWithNoCulture);@(ResxWithCulture)">
        <Type>Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(NonResxWithCulture);@(NonResxWithNoCulture)">
        <Type>Non-Resx</Type>
      </EmbeddedResource>
    </ItemGroup>
    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'">
      <!-- Create the list of culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture" />
      <!-- Create the list of non-culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_MixedResourceWithNoCulture" />
    </AssignCulture>
    <ItemGroup>
      <!-- Remove EmbeddedResource items that we have processed already
                 i.e. either Licx, or resources that don't have culture info -->
      <EmbeddedResource Remove="@(_MixedResourceWithCulture)" />
      <EmbeddedResource Remove="@(_MixedResourceWithNoCulture)" />
      <EmbeddedResource Remove="@(_LicxFile)" />
      <!-- Add back everything except Licx, so that we have culture info -->
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'=='.resx' or '%(Extension)'=='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'!='.resx' and '%(Extension)'!='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Non-Resx</Type>
      </EmbeddedResource>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ResxWithNoCulture Remove="@(ResxWithNoCulture)" />
      <NonResxWithNoCulture Remove="@(NonResxWithNoCulture)" />
      <ResxWithCulture Remove="@(ResxWithCulture)" />
      <NonResxWithCulture Remove="@(NonResxWithCulture)" />
      <ResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <ResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <!-- Clean up temporary lists -->
      <_MixedResourceWithNoCulture Remove="@(_MixedResourceWithNoCulture)" />
      <_MixedResourceWithCulture Remove="@(_MixedResourceWithCulture)" />
    </ItemGroup>
  </Target>
  <!--
    =======================================================================
                                        CreateCustomManifestResourceNames

    Allows custom manifest resource name generation tasks to plug
    into the build process
    =======================================================================
    -->
  <PropertyGroup>
    <CreateCustomManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateCustomManifestResourceNames" DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)" />
  <!--
    ============================================================
                                        ResGen

    Run GenerateResource on the given resx files.

    ============================================================
    -->
  <PropertyGroup>
    <ResGenDependsOn>ResolveAssemblyReferences;SplitResourcesByCulture;BeforeResGen;CoreResGen;AfterResGen</ResGenDependsOn>
    <CoreResGenDependsOn />
    <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResGen" DependsOnTargets="$(ResGenDependsOn)" />
  <!--
    ============================================================
                                        BeforeResGen

    Redefine this target in your project in order to run tasks just before Resgen.
    ============================================================
    -->
  <Target Name="BeforeResGen" />
  <!--
    ============================================================
                                        AfterResGen

    Redefine this target in your project in order to run tasks just after Resgen.
    ============================================================
    -->
  <Target Name="AfterResGen" />
  <!--
    ============================================================
                                        CoreResGen
    ============================================================
    -->
  <Target Name="CoreResGen" DependsOnTargets="$(CoreResGenDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <PropertyGroup>
      <GenerateResourceMSBuildArchitecture Condition="'$(GenerateResourceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</GenerateResourceMSBuildArchitecture>
      <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(GenerateResourceMSBuildArchitecture)' != ''">
      <!-- In the general case, we want to fail to run the task if the task host it's requesting doesn't exist, because we'd rather let the
           user know there's something wrong than just silently generate something that's probably not quite right. However, in a few 
           circumstances, there are tasks that are already aware of runtime / bitness concerns, in which case even if we go ahead and run 
           the more recent version of the task, it should be able to generate something correct.  GenerateResource is one such task, so 
           we check for the existence of the targeted task host so that we can use it preferentially, but if it can't be found, we'll fall 
           back to the current task since it's still mostly correct.

           In particular, we need to do this because otherwise people with Dev10 on a machine that they upgrade to Win8 will be broken: 
           they'll have ResGen from the 7.0A SDK installed, so launching ResGen will still work, but the CLR2 task host is only installed by 
           the 8.0A SDK, which they won't have installed, and thus without this fallback mechanism, their projects targeting v3.5 will 
           suddenly start failing to build.-->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == '' and &#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(GenerateResourceMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</GenerateResourceMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == ''">CurrentRuntime</GenerateResourceMSBuildRuntime>
    </PropertyGroup>
    <!-- 4.0 task has some new parameters that we want to make use of if we're targeting 4.0 -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' != 'CLR2'" SdkToolsPath="$(ResgenToolPath)" ExecuteAsTool="$(ResGenExecuteAsTool)" EnvironmentVariables="$(ResGenEnvironment)" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <!-- But we can't use those parameters if we're targeting 3.5, since we're using the 3.5 task -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' == 'CLR2'">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temporary)" />
      <!-- Add back the Sources list (with OutputResource metadata) that we output from GenerateResource into EmbeddedResource -->
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithNoCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithNoCulture>
      <ManifestNonResxWithNoCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithNoCultureOnDisk>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithCulture>
      <ManifestNonResxWithCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithCultureOnDisk>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        CompileLicxFiles

    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(_LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    ============================================================
    -->
  <PropertyGroup>
    <CompileLicxFilesDependsOn />
  </PropertyGroup>
  <Target Name="CompileLicxFiles" Condition="'@(_LicxFile)'!=''" DependsOnTargets="$(CompileLicxFilesDependsOn)" Inputs="$(MSBuildAllProjects);@(_LicxFile);@(ReferencePath);@(ReferenceDependencyPaths)" Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses">
    <PropertyGroup>
      <LCMSBuildArchitecture Condition="'$(LCMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</LCMSBuildArchitecture>
    </PropertyGroup>
    <LC Sources="@(_LicxFile)" LicenseTarget="$(TargetFileName)" OutputDirectory="$(IntermediateOutputPath)" OutputLicense="$(IntermediateOutputPath)$(TargetFileName).licenses" ReferencedAssemblies="@(ReferencePath);@(ReferenceDependencyPaths)" NoLogo="$(NoLogo)" ToolPath="$(LCToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(LCEnvironment)" MSBuildArchitecture="$(LCMSBuildArchitecture)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile" />
      <Output TaskParameter="OutputLicense" ItemName="FileWrites" />
    </LC>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveKeySource Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        ResolveKeySource

    Resolve the strong name key used to sign the assembly as well as the certificate used to
    sign the ClickOnce manifests.

        [IN]
        $(AssemblyOriginatorKeyFile)     - The file used to sign the assembly (.snk or .pfx)
        $(ManifestCertificateThumbprint) - The thumbprint used to locate the certificate in the
                                           user's certificate store.
        $(ManifestKeyFile)               - The key file that contains the certificate in case the
                                           certificate is not in the user's store.

        [OUT]
        $(ResolvedAssemblyKeyFile)        - Key used to sign the assembly
        $(_DeploymentResolvedManifestCertificateThumbprint) - Certificate used to sign the manifests
    ============================================================
    -->
  <Target Name="ResolveKeySource" Condition="$(SignManifests) == 'true' or $(SignAssembly) == 'true'">
    <ResolveKeySource KeyFile="$(AssemblyOriginatorKeyFile)" CertificateThumbprint="$(ManifestCertificateThumbprint)" CertificateFile="$(ManifestKeyFile)" SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)" ShowImportDialogDespitePreviousFailures="$(BuildingProject)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ResolvedKeyFile" PropertyName="KeyOriginatorFile" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedKeyContainer" PropertyName="KeyContainerName" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedThumbprint" PropertyName="_DeploymentResolvedManifestCertificateThumbprint" Condition=" '$(SignManifests)' == 'true' " />
    </ResolveKeySource>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Compile Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Compile
    ============================================================
    -->
  <PropertyGroup>
    <CompileDependsOn>
      ResolveReferences;
      ResolveKeySource;
      SetWin32ManifestProperties;
      _GenerateCompileInputs;
      BeforeCompile;
      _TimeStampBeforeCompile;
      CoreCompile;
      _TimeStampAfterCompile;
      AfterCompile;
    </CompileDependsOn>
  </PropertyGroup>
  <Target Name="Compile" DependsOnTargets="$(CompileDependsOn)" />
  <!--
    ============================================================
                                        _GenerateCompileInputs

    Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
    ============================================================
    -->
  <Target Name="_GenerateCompileInputs">
    <Warning Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''" Code="MSB9004" Text="ManifestResourceWithNoCulture item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='false', Type='Resx', and optional LogicalName." />
    <Warning Condition="'@(ManifestNonResxWithNoCultureOnDisk)'!='' and '%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''" Code="MSB9005" Text="ManifestNonResxWithNoCultureOnDisk item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='false', Type='Non-Resx', and optional LogicalName." />
    <ItemGroup>
      <!-- _CoreCompileResourceInputs is the list of TLDA inputs that should trigger CoreCompile, and are listed as inputs to that target -->
      <_CoreCompileResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_CoreCompileResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Non-Resx' " />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_CoreCompileResourceInputs Include="@(ManifestResourceWithNoCulture)" Condition="'%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
      <_CoreCompileResourceInputs Include="@(ManifestNonResxWithNoCultureOnDisk)" Condition="'%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateTargetFrameworkMonikerAttribute

    Emit the target framework moniker attribute as  a code fragment into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
    <!-- Do not clean if we are going to default the path to the temp directory -->
    <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$([System.IO.Path]::GetTempPath())','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateTargetFrameworkAttribute Condition="'$(GenerateTargetFrameworkAttribute)' == '' and '$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">true</GenerateTargetFrameworkAttribute>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == 'true'">
    <Clean Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
  </ItemGroup>
  <Target Name="GenerateTargetFrameworkMonikerAttribute" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets" Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">
    <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
             and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
    <WriteLinesToFile File="$(TargetFrameworkMonikerAssemblyAttributesPath)" Lines="$(TargetFrameworkMonikerAssemblyAttributeText)" Overwrite="true" ContinueOnError="true" Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''" />
    <ItemGroup Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''">
      <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
      <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateAdditionalSources

    Emit any specified code fragments into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(AssemblyAttributesPath)' != ''">
    <GenerateAdditionalSources Condition="'$(GenerateAdditionalSources)' == ''">true</GenerateAdditionalSources>
  </PropertyGroup>
  <ItemGroup Condition="'$(AssemblyAttributesPath)' != ''">
    <Clean Include="$(AssemblyAttributesPath)" Condition="'$(AssemblyAttributesFileClean)' != 'false'" />
  </ItemGroup>
  <Target Name="GenerateAdditionalSources" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildAllProjects)" Outputs="$(AssemblyAttributesPath)" Condition="'@(AssemblyAttributes)' != '' and '$(GenerateAdditionalSources)' == 'true'">
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttributes)" OutputFile="$(AssemblyAttributesPath)" Language="$(Language)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ============================================================
                                        BeforeCompile

    Redefine this target in your project in order to run tasks just before Compile.
    ============================================================
    -->
  <Target Name="BeforeCompile" />
  <!--
    ============================================================
                                        AfterCompile

    Redefine this target in your project in order to run tasks just after Compile.
    ============================================================
    -->
  <Target Name="AfterCompile" />
  <!--
    ============================================================
                                        _TimeStampBeforeCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampBeforeCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">
    <PropertyGroup>
      <_AssemblyTimestampBeforeCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampBeforeCompile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _TimeStampAfterCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampAfterCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">
    <PropertyGroup>
      <_AssemblyTimestampAfterCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampAfterCompile>
    </PropertyGroup>
  </Target>
  <!--
    ================================================================
                                        _ComputeNonExistentFileProperty

    There are certain situations in which we want to always run the CoreCompile target (and
    thus the Csc task), even if the timestamps of the outputs appear to be up-to-date on disk.
    If we're inside the IDE during design-time, then the Csc/Vbc/Vjc task is simply being used to
    initialize the host compiler, so we always want to run it.  Also, if we're inside the IDE, and
    the host compiler is responsible for doing the compilation during an actual build, we want to let
    the host compiler determine whether the output is up-to-date, because there may be source files
    in the IDE's in-memory buffers that we don't know about.

    So, we always run the CoreCompile target if we're in the IDE, and either we're in design-time or
    we're delegating to the host compiler for the actual build.

    We compare against BuildOutOfProcess != true because we cannot assume that the build process will 
    have set BuildOutOfProcess to true or false. Therefore the default behavior should be to do the 
    legacy behavior seen before BuildingOutOfProcess was introduced if the property is not set.
    ================================================================
    -->
  <Target Name="_ComputeNonExistentFileProperty" Condition="('$(BuildingInsideVisualStudio)' == 'true') and ('$(BuildingOutOfProcess)' != 'true') and (('$(BuildingProject)' == 'false') or ('$(UseHostCompilerIfAvailable)' == 'true'))">
    <PropertyGroup>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateSerializationAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <_SGenDllName>$(TargetName).XmlSerializers.dll</_SGenDllName>
    <_SGenDllCreated>false</_SGenDllCreated>
    <_SGenGenerateSerializationAssembliesConfig>$(GenerateSerializationAssemblies)</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(GenerateSerializationAssemblies)' == ''">Auto</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(ConfigurationName)'=='Debug' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto'">Off</_SGenGenerateSerializationAssembliesConfig>
    <SGenUseProxyTypes Condition="'$(SGenUseProxyTypes)' == ''">true</SGenUseProxyTypes>
    <SGenUseKeep Condition="'$(SGenUseKeep)'==''">false</SGenUseKeep>
    <SGenShouldGenerateSerializer Condition="'$(SGenShouldGenerateSerializer)' == ''">true</SGenShouldGenerateSerializer>
  </PropertyGroup>
  <!--
    ============================================================
                                        GenerateSerializationAssemblies

    Run GenerateSerializationAssemblies on the assembly produced by this build.

        [IN]
        @(BuildAssemblyName) - The assembly generated by this build.
        @(BuildAssemblyPath) - The path where the assembly resides.
        @(ReferencePath) - The list of references used by this assembly.

        [OUT]
        @(SerializationAssembly) - The path to the serialization assembly.  Maybe we'll just append to an existing list.
    ============================================================
    -->
  <Target Name="GenerateSerializationAssemblies" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" DependsOnTargets="AssignTargetPaths;Compile;ResolveKeySource" Inputs="$(MSBuildAllProjects);@(IntermediateAssembly)" Outputs="$(IntermediateOutputPath)$(_SGenDllName)">
    <PropertyGroup>
      <SGenMSBuildArchitecture Condition="'$(SGenMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</SGenMSBuildArchitecture>
    </PropertyGroup>
    <SGen BuildAssemblyName="$(TargetFileName)" BuildAssemblyPath="$(IntermediateOutputPath)" References="@(ReferencePath)" ShouldGenerateSerializer="$(SGenShouldGenerateSerializer)" UseProxyTypes="$(SGenUseProxyTypes)" UseKeep="$(SGenUseKeep)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" ToolPath="$(SGenToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(SGenEnvironment)" MSBuildArchitecture="$(SGenMSBuildArchitecture)" SerializationAssembly="$(IntermediateOutputPath)$(_SGenDllName)" Platform="$(SGenPlatformTarget)" Types="$(SGenSerializationTypes)">
      <Output TaskParameter="SerializationAssembly" ItemName="SerializationAssembly" />
    </SGen>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                CreateSatelliteAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CreateSatelliteAssemblies

    Create one satellite assembly for every unique culture in the resources.
    ============================================================
    -->
  <PropertyGroup>
    <CreateSatelliteAssembliesDependsOn>
      _GenerateSatelliteAssemblyInputs;
      ComputeIntermediateSatelliteAssemblies;
      GenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="CreateSatelliteAssemblies" DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" />
  <!--
    ============================================================
                                        _GenerateSatelliteAssemblyInputs

    Create the _SatelliteAssemblyResourceInputs list of inputs to the CreateSatelliteAssemblies target.
    ============================================================
    -->
  <Target Name="_GenerateSatelliteAssemblyInputs">
    <Warning Condition="'@(ManifestResourceWithCulture)'!='' and '%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''" Code="MSB9006" Text="ManifestResourceWithCulture item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='true', Type='Resx', and optional LogicalName." />
    <Warning Condition="'@(ManifestNonResxWithCultureOnDisk)'!='' and '%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''" Code="MSB9007" Text="ManifestNonResxWithCultureOnDisk item type is deprecated. Emit EmbeddedResource items instead, with metadata WithCulture='true', Type='Non-Resx', and optional LogicalName." />
    <ItemGroup>
      <!-- _SatelliteAssemblyResourceInputs is the list of TLDA inputs that should trigger CreateSatelliteAssemblies, so listed as inputs to that target -->
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_SatelliteAssemblyResourceInputs Include="@(ManifestResourceWithCulture)" Condition="'%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
      <_SatelliteAssemblyResourceInputs Include="@(ManifestNonResxWithCultureOnDisk)" Condition="'%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    Actually run al.exe to create the satellite assemblies.
    ============================================================
    -->
  <Target Name="GenerateSatelliteAssemblies" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != ''">
    <MakeDir Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
    <AL AlgorithmId="$(Satellite_AlgorithmId)" BaseAddress="$(Satellite_BaseAddress)" CompanyName="$(Satellite_CompanyName)" Configuration="$(Satellite_Configuration)" Copyright="$(Satellite_Copyright)" Culture="%(Culture)" DelaySign="$(DelaySign)" Description="$(Satellite_Description)" EmbedResources="@(_SatelliteAssemblyResourceInputs)" EnvironmentVariables="$(AlEnvironment)" EvidenceFile="$(Satellite_EvidenceFile)" FileVersion="$(Satellite_FileVersion)" Flags="$(Satellite_Flags)" GenerateFullPaths="$(Satellite_GenerateFullPaths)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LinkResources="@(Satellite_LinkResource)" MainEntryPoint="$(Satellite_MainEntryPoint)" OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Platform="$(PlatformTarget)" ProductName="$(Satellite_ProductName)" ProductVersion="$(Satellite_ProductVersion)" ResponseFiles="@(AlResponseFile)" SourceModules="@(Satellite_SourceModule)" TargetType="$(Satellite_TargetType)" TemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Title="$(Satellite_Title)" ToolPath="$(AlToolPath)" ToolExe="$(AlToolExe)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" Trademark="$(Satellite_Trademark)" Version="$(Satellite_Version)" Win32Icon="$(Satellite_Win32Icon)" Win32Resource="$(Satellite_Win32Resource)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </AL>
  </Target>
  <!--
    ============================================================
                                        ComputeIntermediateSatelliteAssemblies

    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place.
    ============================================================
    -->
  <PropertyGroup>
    <ComputeIntermediateSatelliteAssembliesDependsOn>
      CreateManifestResourceNames
    </ComputeIntermediateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="ComputeIntermediateSatelliteAssemblies" Condition="@(EmbeddedResource->'%(WithCulture)') != ''" DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)">
    <ItemGroup>
      <IntermediateSatelliteAssembliesWithTargetPath Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.Culture)' != ''">
        <Culture>%(EmbeddedResource.Culture)</Culture>
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
      </IntermediateSatelliteAssembliesWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                SetWin32ManifestProperties Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <EmbeddedWin32Manifest>$(Win32Manifest)</EmbeddedWin32Manifest>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetWin32ManifestProperties

    Set Win32Manifest and EmbeddedManifest properties to be used later in the build.
    ============================================================
    -->
  <Target Name="SetWin32ManifestProperties" Condition="'$(Win32Manifest)'==''" DependsOnTargets="ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties" />
  <Target Name="_SetExternalWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''">
    <PropertyGroup>
      <!-- set _DeploymentBaseManifest property to the value of $(ApplicationManifest) if the property is set,
                 but use _DeploymentBaseManifestWithTargetPath item-group if the property is not set to support backwards
                 compat with earlier MSBuild versions when manifest files were determined by the item-group. If the newer
                 property is set though, prefer that one be used to specify the manifest. -->
      <_DeploymentBaseManifest>$(ApplicationManifest)</_DeploymentBaseManifest>
      <_DeploymentBaseManifest Condition="'$(_DeploymentBaseManifest)'==''">@(_DeploymentBaseManifestWithTargetPath)</_DeploymentBaseManifest>
      <!-- when using external manifests, always set the NoWin32Manifest property to
                 true if there is no value set in the incoming project file so the
                 compilers that support manifest embedding know not to add
                 a manifest to their built assemblies -->
      <NoWin32Manifest Condition="'$(NoWin32Manifest)'==''">true</NoWin32Manifest>
    </PropertyGroup>
  </Target>
  <Target Name="_SetEmbeddedWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'!='true' and '@(NativeReference)'=='' and '@(ResolvedIsolatedComModules)'==''">
    <PropertyGroup>
      <EmbeddedWin32Manifest>$(ApplicationManifest)</EmbeddedWin32Manifest>
      <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
    </PropertyGroup>
    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true'">
      <Output TaskParameter="FrameworkVersion40Path" PropertyName="_FrameworkVersion40Path" />
    </GetFrameworkPath>
    <PropertyGroup>
      <EmbeddedWin32Manifest Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateManifests Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        GenerateManifests

    Generates ClickOnce application and deployment manifests or a native manifest.
    ============================================================
    -->
  <PropertyGroup>
    <GenerateManifestsDependsOn>
      SetWin32ManifestProperties;
      GenerateApplicationManifest;
      GenerateDeploymentManifest
    </GenerateManifestsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                  _GenerateResolvedDeploymentManifestEntryPoint

    Use the ResolveManifestFiles to generate the GenerateResolvedDeploymentManifestEntryPoint

    ============================================================
    -->
  <Target Name="_GenerateResolvedDeploymentManifestEntryPoint">
    <ItemGroup>
      <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'" />
    </ItemGroup>
    <ResolveManifestFiles TargetFrameworkVersion="$(TargetFrameworkVersion)" SigningManifests="$(SignManifests)" DeploymentManifestEntryPoint="@(ApplicationManifest)" PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
      <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint" />
    </ResolveManifestFiles>
  </Target>
  <Target Name="GenerateManifests" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!='' or '$(GenerateAppxManifest)' == 'true'" DependsOnTargets="$(GenerateManifestsDependsOn)" />
  <!--
    ============================================================
                                        GenerateApplicationManifest

    Generates a ClickOnce or native application manifest.
    An application manifest specifies declarative application identity, dependency and security information.

        [IN]
        $(_DeploymentBaseManifest) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(_DeploymentManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(_DeploymentManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        $(_DeploymentManifestType) - Type of manifest to be generated, either "Native" or "ClickOnce".

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
    ============================================================
    -->
  <Target Name="GenerateApplicationManifest" DependsOnTargets="&#xD;&#xA;            _DeploymentComputeNativeManifestInfo;&#xD;&#xA;            _DeploymentComputeClickOnceManifestInfo;&#xD;&#xA;            ResolveComReferences;&#xD;&#xA;            ResolveNativeReferences;&#xD;&#xA;            _GenerateResolvedDeploymentManifestEntryPoint" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(AppConfigWithTargetPath);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            @(ResolvedIsolatedComModules);&#xD;&#xA;            @(_DeploymentManifestDependencies);&#xD;&#xA;            @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;            @(_DeploymentManifestFiles)" Outputs="@(ApplicationManifest)">
    <RequiresFramework35SP1Assembly ReferencedAssemblies="@(Reference)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" TargetFrameworkVersion="$(TargetFrameworkVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" SigningManifests="$(SignManifests)" Assemblies="@(_DeploymentManifestDependencies)" DeploymentManifestEntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" Files="@(_DeploymentManifestFiles)" SuiteName="$(SuiteName)">
      <Output TaskParameter="RequiresMinimumFramework35SP1" PropertyName="_DeploymentRequiresMinimumFramework35SP1" />
    </RequiresFramework35SP1Assembly>
    <GenerateApplicationManifest AssemblyName="$(_DeploymentApplicationManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" ConfigFile="@(AppConfigWithTargetPath)" ClrVersion="$(ClrVersion)" Dependencies="@(_DeploymentManifestDependencies)" Description="$(Description)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" FileAssociations="@(FileAssociation)" Files="@(_DeploymentManifestFiles)" HostInBrowser="$(HostInBrowser)" IconFile="@(_DeploymentManifestIconFile)" InputManifest="$(_DeploymentBaseManifest)" IsolatedComReferences="@(ResolvedIsolatedComModules)" ManifestType="$(_DeploymentManifestType)" MaxTargetPath="$(MaxTargetPath)" OutputManifest="@(ApplicationManifest)" OSVersion="$(OSVersion)" Platform="$(PlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkSubset="$(TargetFrameworkSubset)" TargetFrameworkProfile="$(TargetFrameworkProfile)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)" UseApplicationTrust="$(UseApplicationTrust)">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateApplicationManifest>
    <PropertyGroup>
      <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeNativeManifestInfo

    Compute info for native manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeNativeManifestInfo" Condition="'$(GenerateClickOnceManifests)'!='true'">
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies" />
    </ResolveManifestFiles>
    <PropertyGroup>
      <_DeploymentManifestType>Native</_DeploymentManifestType>
    </PropertyGroup>
    <!-- Obtain manifest version from the built assembly -->
    <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_IntermediateAssemblyIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_DeploymentManifestVersion>@(_IntermediateAssemblyIdentity->'%(Version)')</_DeploymentManifestVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeClickOnceManifestInfo

    Compute info for  ClickOnce manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeClickOnceManifestInfo" Condition="'$(GenerateClickOnceManifests)'=='true'" DependsOnTargets="&#xD;&#xA;            CleanPublishFolder;&#xD;&#xA;            _DeploymentGenerateTrustInfo">
    <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
    <ItemGroup>
      <_SGenDllsRelatedToCurrentDll Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
      <_SGenDllsRelatedToCurrentDll Include="@(SerializationAssembly->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <!-- Flag primary dependencies-certain warnings emitted during application manifest generation apply only to them. -->
    <ItemGroup>
      <_DeploymentReferencePaths Include="@(ReferencePath)">
        <IsPrimary>true</IsPrimary>
      </_DeploymentReferencePaths>
    </ItemGroup>
    <!-- Copy the application executable from Obj folder to app.publish folder.
    This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
    <Copy SourceFiles="@(_DeploymentManifestEntryPoint)" DestinationFolder="$(PublishDir)">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentClickOnceApplicationExecutable" />
    </Copy>
    <!-- Sign the application executable located in app.publish folder.  Signing this file is done to comply with SmartScreen. -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentClickOnceApplicationExecutable)" Condition="'$(_DeploymentResolvedManifestCertificateThumbprint)'!='' and '$(_DeploymentSignClickOnceManifests)'=='true' and '$(TargetExt)' == '.exe'" />
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles TargetFrameworkVersion="$(TargetFrameworkVersion)" SigningManifests="$(SignManifests)" EntryPoint="@(_DeploymentClickOnceApplicationExecutable)" ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)" Files="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath)" ManagedAssemblies="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly)" NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)" PublishFiles="@(PublishFile)" SatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" TargetCulture="$(TargetCulture)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies" />
      <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles" />
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentResolvedManifestEntryPoint" />
    </ResolveManifestFiles>
    <PropertyGroup>
      <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
    </PropertyGroup>
    <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion" />
    </FormatVersion>
    <FormatUrl InputUrl="$(_DeploymentUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedDeploymentUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(SupportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedSupportUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(ErrorReportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedErrorReportUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateTrustInfo

    Generates the application permission set for inclusion in the generated ClickOnce application manifest.
    ============================================================
    -->
  <Target Name="_DeploymentGenerateTrustInfo" Condition="'$(TargetZone)'!=''" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            " Outputs="@(_DeploymentIntermediateTrustInfoFile)">
    <GenerateTrustInfo BaseManifest="$(_DeploymentBaseManifest)" ApplicationDependencies="@(ReferencePath);@(ReferenceDependencyPaths)" ExcludedPermissions="$(ExcludedPermissions)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetZone="$(TargetZone)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)">
      <Output TaskParameter="TrustInfoFile" ItemName="FileWrites" />
    </GenerateTrustInfo>
  </Target>
  <!--
    ============================================================
                                        GenerateDeploymentManifest

    Generates a ClickOnce deployment manifest.
    An deployment manifest specifies declarative application identity and application update information.
    ============================================================
    -->
  <Target Name="GenerateDeploymentManifest" DependsOnTargets="GenerateApplicationManifest" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(ApplicationManifest)&#xD;&#xA;            " Outputs="@(DeployManifest)">
    <GenerateDeploymentManifest AssemblyName="$(_DeploymentDeployManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" DeploymentUrl="$(_DeploymentFormattedDeploymentUrl)" Description="$(Description)" DisallowUrlActivation="$(DisallowUrlActivation)" EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" Install="$(Install)" MapFileExtensions="$(MapFileExtensions)" MaxTargetPath="$(MaxTargetPath)" MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)" OutputManifest="@(DeployManifest)" Platform="$(PlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TrustUrlParameters="$(TrustUrlParameters)" UpdateEnabled="$(UpdateEnabled)" UpdateInterval="$(_DeploymentBuiltUpdateInterval)" UpdateMode="$(UpdateMode)" UpdateUnit="$(_DeploymentBuiltUpdateIntervalUnits)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateDeploymentManifest>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForRun Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <SkipCopyUnchangedFiles Condition="'$(SkipCopyUnchangedFiles)' == ''">true</SkipCopyUnchangedFiles>
    <UseCommonOutputDirectory Condition="'$(UseCommonOutputDirectory)' == ''">false</UseCommonOutputDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepareForRun

    Copy the build outputs to the final directory if they have changed.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      CopyFilesToOutputDirectory
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForRun" DependsOnTargets="$(PrepareForRunDependsOn)" />
  <!--
    ============================================================
                                        CopyFilesToOutputDirectory

    Copy all build outputs, satellites and other necessary files to the final directory.
    ============================================================
    -->
  <PropertyGroup>
    <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
    <CreateHardLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateHardLinksForCopyAdditionalFilesIfPossible>
  </PropertyGroup>
  <Target Name="CopyFilesToOutputDirectory" DependsOnTargets="&#xD;&#xA;            ComputeIntermediateSatelliteAssemblies;&#xD;&#xA;            _CopyFilesMarkedCopyLocal;&#xD;&#xA;            _CopySourceItemsToOutputDirectory;&#xD;&#xA;            _CopyAppConfigFile;&#xD;&#xA;            _CopyManifestFiles;&#xD;&#xA;            _CheckForCompileOutputs;&#xD;&#xA;            _SGenCheckForOutputs">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
    </PropertyGroup>
    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
    </PropertyGroup>
    <!-- Copy the build product (.dll or .exe). -->
    <Copy SourceFiles="@(IntermediateAssembly)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="MainAssembly" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)'!='true'" />
    <!-- Copy the additional modules. -->
    <Copy SourceFiles="@(AddModules)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" Condition="'@(AddModules)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the serialization assembly if it exists. -->
    <Copy SourceFiles="$(IntermediateOutputPath)$(_SGenDllName)" DestinationFiles="$(OutDir)$(_SGenDllName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'$(_SGenDllCreated)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the debug information file (.pdb), if any -->
    <Copy SourceFiles="@(_DebugSymbolsIntermediatePath)" DestinationFiles="@(_DebugSymbolsOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the resulting XML documentation file, if any. -->
    <Copy SourceFiles="@(DocFileItem)" DestinationFiles="@(FinalDocFile)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'$(_DocumentationFileProduced)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy satellite assemblies. -->
    <Copy SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath)" DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'@(IntermediateSatelliteAssembliesWithTargetPath)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!--
        Copy COM reference wrappers, isolated COM references, COM references included by
        native (manifest) references, native (manifest) reference files themselves.
        -->
    <Copy SourceFiles="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" Condition="'@(ReferenceComWrappersToCopyLocal)' != '' or '@(ResolvedIsolatedComModules)' != '' or '@(_DeploymentLooseManifestFile)' != '' or '@(NativeReferenceFile)' != '' ">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
    <!-- Copy the build product of WinMDExp. -->
    <Copy SourceFiles="@(WinMDExpArtifacts)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '@(WinMDExpArtifacts)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
      <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
    </Copy>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
  </Target>
  <!--
    ============================================================
                                        _CopyFilesMarkedCopyLocal

    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    ============================================================
    -->
  <Target Name="_CopyFilesMarkedCopyLocal" Condition="'@(ReferenceCopyLocalPaths)' != ''">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyLocalIfPossible)' == ''">false</CreateHardLinksForCopyLocalIfPossible>
    </PropertyGroup>
    <Copy SourceFiles="@(ReferenceCopyLocalPaths)" DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyLocalIfPossible)" Condition="'$(UseCommonOutputDirectory)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopySourceItemsToOutputDirectory
    ============================================================
    -->
  <Target Name="_CopySourceItemsToOutputDirectory" DependsOnTargets="&#xD;&#xA;            GetCopyToOutputDirectoryItems;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectory;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectoryAlways" />
  <!--
    ============================================================
                                        GetCopyToOutputDirectoryItems

    Get all project items that may need to be transferred to the output directory.
    This includes baggage items from transitively referenced projects. It would appear
    that this target computes full transitive closure of content items for all referenced
    projects; however that is not the case. It only collects the content items from its
    immediate children and not children of children. The reason this happens is that
    the ProjectReferenceWithConfiguration list that is consumed by _SplitProjectReferencesByFileExistence
    is only populated in the current project and is empty in the children. The empty list
    causes _MSBuildProjectReferenceExistent to be empty and terminates the recursion.
    ============================================================
    -->
  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsDependsOn>
      AssignTargetPaths;
      _SplitProjectReferencesByFileExistence
    </GetCopyToOutputDirectoryItemsDependsOn>
  </PropertyGroup>
  <Target Name="GetCopyToOutputDirectoryItems" Returns="@(AllItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' " DependsOnTargets="$(GetCopyToOutputDirectoryItemsDependsOn)">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those 
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToOutputDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' ">
      <_GCTODIKeepDuplicates>false</_GCTODIKeepDuplicates>
      <_GCTODIKeepMetadata>CopyToOutputDirectory;TargetPath</_GCTODIKeepMetadata>
    </PropertyGroup>
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetCopyToOutputDirectoryItems" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_SourceItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Remove="@(_AllChildProjectItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Get items from this project last so that they will be copied last. -->
    <ItemGroup>
      <_SourceItemsToCopyToOutputDirectoryAlways KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToOutputDirectoryAlways KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="'%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_SourceItemsToCopyToOutputDirectoryAlways KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToOutputDirectoryAlways KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <AllItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToOutputDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectory->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'PreserveNewest'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectory)' != '' " Inputs="@(_SourceItemsToCopyToOutputDirectory)" Outputs="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')">
    <!--
        Not using SkipUnchangedFiles="true" because the application may want to change
        one of these files and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectory)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectoryAlways

    Copy files that have the CopyToOutputDirectory attribute set to 'Always'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectoryAlways" Condition=" '@(_SourceItemsToCopyToOutputDirectoryAlways)' != '' ">
    <!--
        Not using SkipUnchangedFiles="true" because the application may want to change
        one of these files and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryAlways)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyAppConfigFile

    Copy the application config file.
    ============================================================
    -->
  <Target Name="_CopyAppConfigFile" Condition=" '@(AppConfigWithTargetPath)' != '' " Inputs="@(AppConfigWithTargetPath)" Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')">
    <!--
        Copy the application's .config file, if any.
        Not using SkipUnchangedFiles="true" because the application may want to change
        the app.config and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(AppConfigWithTargetPath)" DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ================================================================
                                         _CopyManifestFiles
    ================================================================

    Copy the built manifests (.exe.manifest, .application/.xbap) to the final directory.
    -->
  <Target Name="_CopyManifestFiles" Condition=" '$(_DeploymentCopyApplicationManifest)'=='true' or '$(GenerateClickOnceManifests)'=='true' " DependsOnTargets="PrepareForBuild">
    <Copy SourceFiles="@(ApplicationManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true' or '$(_DeploymentCopyApplicationManifest)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainApplicationManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(_DeploymentCopyApplicationManifest)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainApplicationManifest->'%(FullPath)')" />
    <Copy SourceFiles="@(DeployManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainDeployManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(GenerateClickOnceManifests)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainDeployManifest->'%(FullPath)')" />
  </Target>
  <!--
    ================================================================
                                         _CheckForCompileOutputs

    Checks each file output from the main "Compile" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_CheckForCompileOutputs">
    <!--Record the main compile outputs.-->
    <ItemGroup>
      <FileWrites Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')" />
    </ItemGroup>
    <!-- Record the .xml if one was produced. -->
    <PropertyGroup>
      <_DocumentationFileProduced Condition="!Exists('@(DocFileItem)')">false</_DocumentationFileProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(DocFileItem)" Condition="'$(_DocumentationFileProduced)'=='true'" />
    </ItemGroup>
    <!-- Record the .pdb if one was produced. -->
    <PropertyGroup>
      <_DebugSymbolsProduced Condition="!Exists('@(_DebugSymbolsIntermediatePath)')">false</_DebugSymbolsProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SGenCheckForOutputs

    Checks each file output from the "GenerateSerializationAssemblies" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_SGenCheckForOutputs" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
    <!-- Record the serializer .dll if one was produced.-->
    <PropertyGroup>
      <_SGenDllCreated Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')">true</_SGenDllCreated>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(_SGenDllName)" Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedRegistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedRegistration

    Registers the main assembly for COM interop.
    ============================================================
    -->
  <PropertyGroup>
    <UnmanagedRegistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedRegistration" Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'" DependsOnTargets="$(UnmanagedRegistrationDependsOn)">
    <PropertyGroup>
      <RegisterAssemblyMSBuildArchitecture Condition="'$(RegisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</RegisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(RegisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to 
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the 
           corresponding comment in GenerateResource. -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == '' and &#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(RegisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</RegisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</RegisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <RegisterAssembly Assemblies="@(_OutputPathItem->'%(FullPath)$(TargetFileName)')" TypeLibFiles="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" AssemblyListFile="@(_UnmanagedRegistrationCache)" CreateCodeBase="true" MSBuildRuntime="$(RegisterAssemblyMSBuildRuntime)" MSBuildArchitecture="$(RegisterAssemblyMSBuildArchitecture)" Condition="!Exists('@(_UnmanagedRegistrationCache)')" />
    <ItemGroup>
      <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                IncrementalClean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        IncrementalClean

    Remove files that were produced in a prior build but weren't produced in the current build.
    The reason is that if, for example, the name of the .exe has changed we want to delete the
    old copy.

    Leave the Clean cache file containing only the files produced in the current build.
    ============================================================
    -->
  <Target Name="IncrementalClean" DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">
    <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
    <ItemGroup>
      <_CleanOrphanFileWrites Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanCurrentFileWrites)" />
    </ItemGroup>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_CleanOrphanFileWritesInIntermediate);@(_CleanOrphanFileWritesInOutput)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanOrphanFilesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted or was outside
             the current final output and intermediate output directories. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterIncrementalClean Include="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)" Exclude="@(_CleanOrphanFilesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterIncrementalClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWritesAfterIncrementalClean" />
    </RemoveDuplicates>
    <!-- Write new list of current files back to disk, replacing the existing list.-->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)" Condition="'@(_CleanUnfilteredPriorFileWrites)'!='@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)'" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
  <Target Name="_CleanGetCurrentAndPriorFileWrites" DependsOnTargets="_CheckForCompileOutputs;_SGenCheckForOutputs">
    <!-- Read the list of files produced by a prior builds from disk. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites" />
    </ReadLinesFromFile>
    <!--
        Convert the list of references to the absolute paths so we can make valid comparisons
        across two lists
         -->
    <ConvertToAbsolutePath Paths="@(_ResolveAssemblyReferenceResolvedFiles)">
      <Output TaskParameter="AbsolutePaths" ItemName="_ResolveAssemblyReferenceResolvedFilesAbsolute" />
    </ConvertToAbsolutePath>
    <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
    <ItemGroup>
      <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
    <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="FileWrites" />
    </FindUnderPath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate" />
    </FindUnderPath>
    <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
    <ItemGroup>
      <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!-- Remove duplicates from files produced in this build. -->
    <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)">
      <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Clean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Clean

    Delete all intermediate and final build outputs.
    ============================================================
    -->
  <PropertyGroup>
    <CleanDependsOn>
      BeforeClean;
      UnmanagedUnregistration;
      CoreClean;
      CleanReferencedProjects;
      CleanPublishFolder;
      AfterClean
    </CleanDependsOn>
  </PropertyGroup>
  <Target Name="Clean" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(CleanDependsOn)" />
  <!--
    ============================================================
                                        BeforeClean

    Redefine this target in your project in order to run tasks just before Clean.
    ============================================================
    -->
  <Target Name="BeforeClean" />
  <!--
    ============================================================
                                        AfterClean

    Redefine this target in your project in order to run tasks just after Clean.
    ============================================================
    -->
  <Target Name="AfterClean" />
  <!--
    ============================================================
                                        CleanReferencedProjects

    Call Clean target on all Referenced Projects.
    ============================================================
    -->
  <Target Name="CleanReferencedProjects" DependsOnTargets="AssignProjectConfiguration; _SplitProjectReferencesByFileExistence">
    <!--
        When building the project directly from the command-line, clean those referenced projects
        that exist on disk.  For IDE builds and command-line .SLN builds, the solution build manager
        takes care of this.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="Clean" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" BuildInParallel="$(BuildInParallel)" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)" />
  </Target>
  <!--
    ============================================================
                                        CoreClean
    ============================================================
    -->
  <PropertyGroup>
    <CoreCleanDependsOn />
  </PropertyGroup>
  <Target Name="CoreClean" DependsOnTargets="$(CoreCleanDependsOn)">
    <!-- First clean any explicitly specified cleanable files.
             Declare items of this type if you want Clean to delete them. -->
    <Delete Files="@(Clean)" TreatErrorsAsWarnings="true" />
    <!-- Read in list of files that were written to disk in past builds. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites" />
    </ReadLinesFromFile>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete those files. -->
    <Delete Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
  <Target Name="_CleanRecordFileWrites" DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">
    <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
    <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write merged file list back to disk, replacing existing contents. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueFileWrites)" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        CleanPublishFolder
    ============================================================
    -->
  <Target Name="CleanPublishFolder">
    <RemoveDir Directories="$(PublishDir)" Condition="'$(PublishDir)'=='$(OutputPath)app.publish\' and Exists('$(PublishDir)')" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PostBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PostBuildEvent

    Run the post-build event. This step is driven by two parameters:

    (1) The $(RunPostBuildEvent) property is set by the user through the IDE and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The $(_AssemblyTimestampBeforeCompile) and $(_AssemblyTimestampAfterCompile) values are
        set by the _TimeStampBeforeCompile and _TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    ============================================================
    -->
  <PropertyGroup>
    <PostBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PostBuildEvent" Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')" DependsOnTargets="$(PostBuildEventDependsOn)">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Publish Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Publish

    This target is only called when doing ClickOnce publishing outside the IDE, which implicitly builds before publishing.
    ============================================================
    -->
  <PropertyGroup>
    <PublishDependsOn Condition="'$(PublishableProject)'=='true'">
      SetGenerateManifests;
      Build;
      PublishOnly
    </PublishDependsOn>
    <PublishDependsOn Condition="'$(PublishableProject)'!='true'">
      _DeploymentUnpublishable
    </PublishDependsOn>
  </PropertyGroup>
  <Target Name="Publish" DependsOnTargets="$(PublishDependsOn)" />
  <!--
    ============================================================
                                        _DeploymentUnpublishable

    This target is used to block an attempt to ClickOnce publish a non-publishable project, such as a ClassLibrary, when building outside the IDE.
    ============================================================
    -->
  <Target Name="_DeploymentUnpublishable">
    <Message Text="Skipping unpublishable project." />
  </Target>
  <!--
    ============================================================
                                        SetGenerateManifests

    This target simply assures the GenerateClickOnceManifests property is set whenever the publish target is invoked.
    ============================================================
    -->
  <Target Name="SetGenerateManifests">
    <Error Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'" Text="Publish is only valid for 'Windows Application' or 'Console Application' project types." />
    <Error Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(ManifestCertificateThumbprint)'=='' and '$(ManifestKeyFile)'==''" Text="A signing key is required in order to publish this project. Please specify a ManifestKeyFile or ManifestCertificateThumbprint value. Publishing from Visual Studio will automatically configure a signing key for this project." />
    <PropertyGroup>
      <GenerateClickOnceManifests>true</GenerateClickOnceManifests>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PublishOnly

    The "PublishOnly" target is intended for ClickOnce publishing inside the IDE, where the build has already been done
    by the BuildManager.
    ============================================================
    -->
  <PropertyGroup>
    <PublishOnlyDependsOn>
      SetGenerateManifests;
      PublishBuild;
      BeforePublish;
      GenerateManifests;
      CopyFilesToOutputDirectory;
      _CopyFilesToPublishFolder;
      _DeploymentGenerateBootstrapper;
      ResolveKeySource;
      _DeploymentSignClickOnceDeployment;
      AfterPublish
    </PublishOnlyDependsOn>
  </PropertyGroup>
  <Target Name="PublishOnly" DependsOnTargets="$(PublishOnlyDependsOn)" />
  <!--
    ============================================================
                                        BeforePublish

    Redefine this target in your project in order to run tasks just before Publish.
    ============================================================
    -->
  <Target Name="BeforePublish" />
  <!--
    ============================================================
                                        AfterPublish

    Redefine this target in your project in order to run tasks just after Publish.
    ============================================================
    -->
  <Target Name="AfterPublish" />
  <!--
    ============================================================
                                        PublishBuild

    Defines the set of targets that publishing is directly dependent on.
    ============================================================
    -->
  <PropertyGroup>
    <PublishBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
    </PublishBuildDependsOn>
  </PropertyGroup>
  <Target Name="PublishBuild" DependsOnTargets="$(PublishBuildDependsOn)" />
  <!--
    ============================================================
                                        _CopyFilesToPublishFolder
    ============================================================
    -->
  <Target Name="_CopyFilesToPublishFolder">
    <!-- Compute name of application folder, which includes the assembly name plus formatted application version.
             The application version is formatted to use "_" in place of "." chars (i.e. "1_0_0_0" instead of "1.0.0.0").
             This is done because some servers misinterpret "." as a file extension. -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)" FormatType="Path">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentApplicationVersionFragment" />
    </FormatVersion>
    <PropertyGroup>
      <_DeploymentApplicationFolderName>Application Files\$(AssemblyName)_$(_DeploymentApplicationVersionFragment)</_DeploymentApplicationFolderName>
      <_DeploymentApplicationDir>$(PublishDir)$(_DeploymentApplicationFolderName)\</_DeploymentApplicationDir>
    </PropertyGroup>
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the publish directory, and never when building in VS -->
      <CreateHardLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForPublishFilesIfPossible)' == ''">false</CreateHardLinksForPublishFilesIfPossible>
    </PropertyGroup>
    <!-- Copy files to publish folder -->
    <Copy SourceFiles="@(_ApplicationManifestFinal);&#xD;&#xA;                @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;                @(_DeploymentManifestFiles);&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal);&#xD;&#xA;                @(ResolvedIsolatedComModules);&#xD;&#xA;                @(_DeploymentLooseManifestFile)" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xD;&#xA;                @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentManifestFiles->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ResolvedIsolatedComModules->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentLooseManifestFile->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <Copy SourceFiles="@(_DeploymentManifestDependencies)" DestinationFiles="@(_DeploymentManifestDependencies->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" Condition="'%(_DeploymentManifestDependencies.DependencyType)'=='Install'" />
    <Copy SourceFiles="@(_ReferenceScatterPaths)" DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" />
    <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(_DeploymentComponentsUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedComponentsUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateBootstrapper
    ============================================================
    -->
  <Target Name="_DeploymentGenerateBootstrapper">
    <!-- Build setup.exe bootstrapper and copy referenced packages -->
    <GenerateBootstrapper ApplicationFile="$(TargetDeployManifestFileName)" ApplicationName="$(AssemblyName)" ApplicationUrl="$(_DeploymentFormattedApplicationUrl)" BootstrapperItems="@(BootstrapperPackage)" ComponentsLocation="$(BootstrapperComponentsLocation)" ComponentsUrl="$(_DeploymentFormattedComponentsUrl)" Culture="$(TargetCulture)" FallbackCulture="$(FallbackCulture)" OutputPath="$(PublishDir)" SupportUrl="$(_DeploymentFormattedSupportUrl)" Path="$(GenerateBootstrapperSdkPath)" VisualStudioVersion="$(VisualStudioVersion)" Condition="'$(BootstrapperEnabled)'=='true'" />
  </Target>
  <!--
    ============================================================
                                        _DeploymentSignClickOnceDeployment
    ============================================================
    -->
  <Target Name="_DeploymentSignClickOnceDeployment">
    <!-- Sign manifests and the bootstrapper -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkVersion="$(TargetFrameworkVersion)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Update entry point path in deploy manifest -->
    <UpdateManifest ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkVersion="$(TargetFrameworkVersion)" ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" InputManifest="$(OutDir)$(TargetDeployManifestFileName)" OutputManifest="$(PublishDir)$(TargetDeployManifestFileName)">
      <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest" />
    </UpdateManifest>
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(PublishDir)$(TargetDeployManifestFileName)" TargetFrameworkVersion="$(TargetFrameworkVersion)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(PublishDir)\setup.exe" Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroups Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        AllProjectOutputGroups

    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    ============================================================
    -->
  <Target Name="AllProjectOutputGroups" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroup;&#xD;&#xA;            DebugSymbolsProjectOutputGroup;&#xD;&#xA;            DocumentationProjectOutputGroup;&#xD;&#xA;            SatelliteDllsProjectOutputGroup;&#xD;&#xA;            SourceFilesProjectOutputGroup;&#xD;&#xA;            ContentFilesProjectOutputGroup;&#xD;&#xA;            SGenFilesOutputGroup" />
  <!--
    This is the key output for the BuiltProjectOutputGroup and is meant to be read directly from the IDE.
    Reading an item is faster than invoking a target.
    -->
  <ItemGroup Condition=" '$(OutputType)' != 'winmdobj' ">
    <BuiltProjectOutputGroupKeyOutput Include="@(IntermediateAssembly->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
      <COM2REG Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'">true</COM2REG>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <ItemGroup Condition=" '$(OutputType)' == 'winmdobj' ">
    <WinMDExpOutputWindowsMetadataFileItem Include="$(_IntermediateWindowsMetadataPath)" Condition="'$(_IntermediateWindowsMetadataPath)' != ''" />
    <BuiltProjectOutputGroupKeyOutput Include="@(WinMDExpOutputWindowsMetadataFileItem->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <!--
    ============================================================
                                        BuiltProjectOutputGroup
    ============================================================
    -->
  <PropertyGroup>
    <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
    <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroup" Returns="@(BuiltProjectOutputGroupOutput)" DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)">
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="@(BuiltProjectOutputGroupKeyOutput)" />
    </ItemGroup>
    <!-- This item represents the app.config file -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)" Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
        <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
        <TargetPath>$(TargetFileName).config</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' " />
      <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' " />
    </ItemGroup>
    <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="'@(NativeReference)'!='' or '@(_IsolatedComReference)'!=''">
        <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
      </BuiltProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroup

    This target performs population of the Debug Symbols project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DebugSymbolsProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'">
    <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
      <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'">
    <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
    <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
    <DebugSymbolsProjectOutputGroupOutput Include="@(WinMDExpOutputPdbItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputPdbItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DebugSymbolsProjectOutputGroup" Returns="@(DebugSymbolsProjectOutputGroupOutput)" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        DocumentationProjectOutputGroup

    This target performs population of the Documentation project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DocumentationProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'">
    <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
      <FinalOutputPath>@(FinalDocFile)</FinalOutputPath>
      <IsKeyOutput>true</IsKeyOutput>
      <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'">
    <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
    <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
    <DocumentationProjectOutputGroupOutput Include="@(WinMDOutputDocumentationFileItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputDocItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DocumentationProjectOutputGroup" Returns="@(DocumentationProjectOutputGroupOutput)" DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroup

    This target performs population of the Satellite Files project output group.
    ============================================================
    -->
  <PropertyGroup>
    <SatelliteDllsProjectOutputGroupDependsOn>PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroup" Returns="@(SatelliteDllsProjectOutputGroupOutput)" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependsOn)">
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutputIntermediate Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(WithCulture)' == 'true'">
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
      </SatelliteDllsProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>%(SatelliteDllsProjectOutputGroupOutputIntermediate.Identity)</OriginalItemSpec>
      </SatelliteDllsProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SourceFilesProjectOutputGroup

    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".
    ============================================================
    -->
  <PropertyGroup>
    <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SourceFilesProjectOutputGroup" Returns="@(SourceFilesProjectOutputGroupOutput)" DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)">
    <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
      <SourceFilesProjectOutputGroupOutput Include="@(_CompileWithTargetPath->'%(FullPath)');@(EmbeddedResource->'%(FullPath)');@(_LicxFile->'%(FullPath)');@(AppConfigWithTargetPath->'%(FullPath)')" />
      <!-- Include the project file -->
      <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
        <TargetPath>$(ProjectFileName)</TargetPath>
      </SourceFilesProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- Get just the compile items -->
  <Target Name="GetCompile" Returns="@(Compile)" />
  <!--
    ============================================================
                                        ContentFilesProjectOutputGroup

    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    ============================================================
    -->
  <PropertyGroup>
    <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ContentFilesProjectOutputGroup" Returns="@(ContentFilesProjectOutputGroupOutput)" DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)">
    <!-- Convert items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <ContentFilesProjectOutputGroupOutput Include="@(ContentWithTargetPath->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroup

    This target performs population of the GenerateSerializationAssemblies Files project output group.
    GenerateSerializationAssemblies files are those generated by the GenerateSerializationAssemblies target and task.
    ============================================================
    -->
  <PropertyGroup>
    <SGenFilesOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
    <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
      <FinalOutputPath>@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')</FinalOutputPath>
      <TargetPath>$(_SGenDllName)</TargetPath>
    </SGenFilesOutputGroupOutput>
  </ItemGroup>
  <Target Name="SGenFilesOutputGroup" Returns="@(SGenFilesOutputGroupOutput)" DependsOnTargets="$(SGenFilesOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        SDKRelated Output groups

    These targets are to gather information from the SDKs.
    ============================================================
   -->
  <!-- Get the resolved SDK reference items -->
  <Target Name="GetResolvedSDKReferences" DependsOnTargets="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" />
  <!--
    ============================================================
                                        PriFilesOutputGroup

    This target performs population of the pri files output group
    ============================================================
    -->
  <Target Name="PriFilesOutputGroup" Condition="'@(_ReferenceRelatedPaths)' != ''" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(PriFilesOutputGroupOutput)">
    <!-- This item represents dependent pri file's -->
    <ItemGroup>
      <PriFilesOutputGroupOutput Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <SDKRedistOutputGroupDependsOn>ResolveSDKReferences;ExpandSDKReferences</SDKRedistOutputGroupDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        SDKRedistOutputGroup

    This target gathers the Redist folders from the SDKs which have been resolved.
    ============================================================
  -->
  <Target Name="SDKRedistOutputGroup" Returns="@(SDKRedistOutputGroupOutput)" DependsOnTargets="$(SDKRedistOutputGroupDependsOn)">
    <!-- This list starts with the least specific files to the most specific so that later files can overwrite earlier files-->
    <ItemGroup>
      <SDKRedistOutputGroupOutput Include="@(ResolvedRedistFiles)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroupsDependencies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        AllProjectOutputGroupsDependencies
    ============================================================
    -->
  <Target Name="AllProjectOutputGroupsDependencies" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroupDependencies;&#xD;&#xA;            DebugSymbolsProjectOutputGroupDependencies;&#xD;&#xA;            SatelliteDllsProjectOutputGroupDependencies;&#xD;&#xA;            DocumentationProjectOutputGroupDependencies;&#xD;&#xA;            SGenFilesOutputGroupDependencies" />
  <!--
    ============================================================
                                        BuiltProjectOutputGroupDependencies

    This target performs population of the Built project output group dependencies.
    ============================================================
    -->
  <Target Name="BuiltProjectOutputGroupDependencies" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(BuiltProjectOutputGroupDependency)">
    <ItemGroup>
      <BuiltProjectOutputGroupDependency Include="@(ReferencePath->'%(FullPath)');&#xD;&#xA;                                                         @(ReferenceDependencyPaths->'%(FullPath)');&#xD;&#xA;                                                         @(NativeReferenceFile->'%(FullPath)');&#xD;&#xA;                                                         @(_DeploymentLooseManifestFile->'%(FullPath)');&#xD;&#xA;                                                         @(ResolvedIsolatedComModules->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroupDependencies

    This target performs population of the dependencies for the debug symbols project output group.
    ============================================================
    -->
  <Target Name="DebugSymbolsProjectOutputGroupDependencies" Condition="'$(DebugSymbols)'!='false'" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(DebugSymbolsProjectOutputGroupDependency)">
    <!-- This item represents dependent PDB's -->
    <ItemGroup>
      <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroupDependencies

    This target performs population of the dependencies for the satellite files project output group.
    ============================================================
    -->
  <Target Name="SatelliteDllsProjectOutputGroupDependencies" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(SatelliteDllsProjectOutputGroupDependency)">
    <!-- This item represents dependent satellites -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupDependency Include="@(ReferenceSatellitePaths->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DocumentationProjectOutputGroupDependencies

    This target performs population of the dependencies for the documentation project output group.
    ============================================================
    -->
  <Target Name="DocumentationProjectOutputGroupDependencies" Condition="'$(DocumentationFile)'!=''" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(DocumentationProjectOutputGroupDependency)">
    <!-- This item represents dependent XMLs -->
    <ItemGroup>
      <DocumentationProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.xml'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroupDependencies

    This target performs population of the dependencies for the GenerateSerializationAssemblies project output group.
    ============================================================
    -->
  <Target Name="SGenFilesOutputGroupDependencies" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(SGenFilesOutputGroupDependency)">
    <!-- This item represents sgen xml serializer dll's -->
    <ItemGroup>
      <SGenFilesOutputGroupDependency Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeAnalysis\Microsoft.CodeAnalysis.targets</CodeAnalysisTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CodeAnalysisTargets)" Condition="Exists('$(CodeAnalysisTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\CodeAnalysis\Microsoft.CodeAnalysis.targets
============================================================================================================================================
-->
  <UsingTask TaskName="SetEnvironmentVariable" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v12.0.dll">
    <ParameterGroup>
      <EnvKey ParameterType="System.String" Required="true" />
      <EnvValue ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Code Type="Fragment" Language="cs"><![CDATA[
            try {
                Environment.SetEnvironmentVariable(EnvKey, EnvValue, System.EnvironmentVariableTarget.Process);
            }
            catch  {
            }
        ]]></Code>
    </Task>
  </UsingTask>
  <!-- Global properties for all analyzers -->
  <PropertyGroup>
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VisualStudio\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the first registry path, assume we're in a 64bit process. -->
    <!-- read registry from Wow6432Node -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VisualStudio\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- if we didn't find the registry path yet, then try Win8 Express location -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VSWinExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the registry path yet, then try Win8 Express 64-bit location -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VSWinExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the registry path yet, try WP Express locations -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VPDExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the registry path yet, try WP Express 64-bit locations -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VPDExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the registry path yet, try WD Express locations -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\WDExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- If we didn't find the registry path yet, try WD Express 64-bit locations -->
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\WDExpress\14.0\Setup\EDev@StanDir)</CodeAnalysisStaticAnalysisDirectory>
    <!-- Default rule set search paths -->
    <CodeAnalysisRuleSetDirectories Condition="'$(CodeAnalysisIgnoreBuiltInRuleSets)'!='true' and&#xD;&#xA;             '$(CodeAnalysisStaticAnalysisDirectory)'!=''">$(CodeAnalysisRuleSetDirectories);$(CodeAnalysisStaticAnalysisDirectory)\Rule Sets</CodeAnalysisRuleSetDirectories>
    <!-- 
         In scenario where we run CA from command-line , we don't get "CodeAnalysisVSSku" variable passed by the IDE, so in case of Express-only installation
         we attempt to load rule sets that are only present on Pro and above - and fail. Let's assume we're in "Express" mode if the Pro+ rule set doesn't exist.
     -->
    <CodeAnalysisVSSku Condition="'$(CodeAnalysisVSSku)'=='' and !Exists('$(CodeAnalysisStaticAnalysisDirectory)\Rule Sets\NativeRecommendedRules.ruleset')">Express</CodeAnalysisVSSku>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RunCodeAnalysis)'=='true' or '$(RunCodeAnalysisOnce)'=='true'">
    <!-- 
       - Checking whether we should run Code Analysis only on specific project in the solution
       - Combine all variables into one "master" control variable to simplify conditions further below  
   -->
    <RunCodeAnalysisOnThisProject>true</RunCodeAnalysisOnThisProject>
    <RunCodeAnalysisOnThisProject Condition="'$(CodeAnalysisProjectFullPath)'!='' and '$(MSBuildProjectFullPath)'!='' and '$(MSBuildProjectFullPath)'!='$(CodeAnalysisProjectFullPath)'">false</RunCodeAnalysisOnThisProject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RunCodeAnalysisOnThisProject)'=='true'">
    <!-- Define the CODE_ANALYSIS constant -->
    <DefineConstants Condition="'$(Language)'=='C#' ">CODE_ANALYSIS;$(DefineConstants)</DefineConstants>
    <FinalDefineConstants Condition="'$(Language)'=='VB' ">CODE_ANALYSIS=-1,$(FinalDefineConstants)</FinalDefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition="'$(LocalEspcPath)'=='' and '$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true' and '$(CodeAnalysisVSSku)'!='Express'">
    <!-- use 32-bit version by default -->
    <LocalEspcPath>$(VCInstallDir)\bin\localespc.dll</LocalEspcPath>
    <!-- use 64-bit version if 64-bit cl.exe is used -->
    <LocalEspcPath Condition="'$(VCToolArchitecture)'=='Native64Bit'">$(VCInstallDir)\bin\amd64\localespc.dll</LocalEspcPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'">
    <ClCompile>
      <PreprocessorDefinitions>CODE_ANALYSIS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <!-- For the native x64 case, use the 64-bit DLL. -->
      <PREfastAdditionalPlugins Condition="Exists('$(LocalEspcPath)')">$(LocalEspcPath);%(PREfastAdditionalPlugins)</PREfastAdditionalPlugins>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Global properties for all analyzers -->
  <!-- FxCop analyzer properties -->
  <PropertyGroup>
    <!-- FxCopDir must be considered for backwards compatibility with the Visual Studio 2005 task, except within the context of a Team Build build. -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'=='' and '$(FxCopDir)'!='' and '$(TeamBuildConstants)'==''">$(FxCopDir)</CodeAnalysisPath>
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VisualStudio\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <!-- If we didn't find the first registry path, assume we're in a 64bit process. -->
    <!-- read registry from Wow6432Node -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VisualStudio\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <!-- If we didn't find the registry path yet, try Win8 Express locations -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VSWinExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VSWinExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <!-- If we didn't find the registry path yet, try WP Express locations -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\VPDExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\VPDExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <!-- If we didn't find the registry path yet, try WD Express locations -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\WDExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'==''">$(Registry:HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\WDExpress\14.0\Setup\EDev@FxCopDir)</CodeAnalysisPath>
    <!-- Default FxCop settings -->
    <CodeAnalysisApplyLogFileXsl Condition="'$(CodeAnalysisApplyLogFileXsl)'==''">false</CodeAnalysisApplyLogFileXsl>
    <CodeAnalysisFailOnMissingRules Condition="'$(CodeAnalysisFailOnMissingRules)'==''">false</CodeAnalysisFailOnMissingRules>
    <CodeAnalysisForceOutput Condition="'$(CodeAnalysisForceOutput)'==''">true</CodeAnalysisForceOutput>
    <CodeAnalysisGenerateSuccessFile Condition="'$(CodeAnalysisGenerateSuccessFile)'==''">true</CodeAnalysisGenerateSuccessFile>
    <CodeAnalysisIgnoreGeneratedCode Condition="'$(CodeAnalysisIgnoreGeneratedCode)'==''">true</CodeAnalysisIgnoreGeneratedCode>
    <CodeAnalysisIgnoreInvalidTargets Condition="'$(CodeAnalysisIgnoreInvalidTargets)'==''">true</CodeAnalysisIgnoreInvalidTargets>
    <CodeAnalysisIgnoreMissingIndirectReferences Condition="'$(CodeAnalysisIgnoreMissingIndirectReferences)'==''">false</CodeAnalysisIgnoreMissingIndirectReferences>
    <CodeAnalysisInputAssembly Condition="'$(CodeAnalysisInputAssembly)'==''">$(OutDir)$(TargetFileName)</CodeAnalysisInputAssembly>
    <CodeAnalysisLogFile Condition="'$(CodeAnalysisLogFile)'==''">$(CodeAnalysisInputAssembly).CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisModuleSuppressionsFile Condition="'$(CodeAnalysisModuleSuppressionsFile)'==''">GlobalSuppressions$(DefaultLanguageSourceExtension)</CodeAnalysisModuleSuppressionsFile>
    <CodeAnalysisOverrideRuleVisibilities Condition="'$(CodeAnalysisOverrideRuleVisibilities)'==''">false</CodeAnalysisOverrideRuleVisibilities>
    <CodeAnalysisOutputToConsole Condition="'$(CodeAnalysisOutputToConsole)'==''">false</CodeAnalysisOutputToConsole>
    <CodeAnalysisQuiet Condition="'$(CodeAnalysisQuiet)'==''">false</CodeAnalysisQuiet>
    <!--
             Do not add the built-in rule directories in any of the following conditions:
             1. CodeAnalysisRuleAssemblies is not empty, CodeAnalysisRuleDirectories is empty, and CodeAnalysisRuleSet is empty. (This is the case when CodeAnalysisRuleAssemblies will be used.)
             2. CodeAnalysisIgnoreBuiltInRules is true.
             3. CodeAnalysisPath is empty.
             4. CodeAnalysisProject is not empty (i.e., an FxCop project file is used).

             The condition below checks ensures none of these four are true.
        -->
    <CodeAnalysisRuleDirectories Condition="('$(CodeAnalysisRuleAssemblies)'=='' or '$(CodeAnalysisRuleDirectories)'!='' or '$(CodeAnalysisRuleSet)'!='') and &#xD;&#xA;            '$(CodeAnalysisIgnoreBuiltInRules)'!='true' and &#xD;&#xA;            '$(CodeAnalysisPath)'!='' and &#xD;&#xA;            '$(CodeAnalysisProject)'==''">$(CodeAnalysisRuleDirectories);$(CodeAnalysisPath)\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisSaveMessagesToReport Condition="'$(CodeAnalysisSaveMessagesToReport)'==''">Active</CodeAnalysisSaveMessagesToReport>
    <CodeAnalysisSearchGlobalAssemblyCache Condition="'$(CodeAnalysisSearchGlobalAssemblyCache)'==''">true</CodeAnalysisSearchGlobalAssemblyCache>
    <CodeAnalysisSucceededFile Condition="'$(CodeAnalysisSucceededFile)'==''">$(CodeAnalysisInputAssembly).lastcodeanalysissucceeded</CodeAnalysisSucceededFile>
    <CodeAnalysisSummary Condition="'$(CodeAnalysisSummary)'==''">false</CodeAnalysisSummary>
    <CodeAnalysisTimeout Condition="'$(CodeAnalysisTimeout)'==''">120</CodeAnalysisTimeout>
    <CodeAnalysisTreatWarningsAsErrors Condition="'$(CodeAnalysisTreatWarningsAsErrors)'==''">false</CodeAnalysisTreatWarningsAsErrors>
    <CodeAnalysisUpdateProject Condition="'$(CodeAnalysisUpdateProject)'==''">false</CodeAnalysisUpdateProject>
    <CodeAnalysisUseTypeNameInSuppression Condition="'$(CodeAnalysisUseTypeNameInSuppression)'==''">true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisVerbose Condition="'$(CodeAnalysisVerbose)'==''">false</CodeAnalysisVerbose>
  </PropertyGroup>
  <!-- Select appropriate default rule set depending on project type and VS Sku-->
  <Choose>
    <When Condition="!Exists('$(CodeAnalysisRuleSet)') and ('$(CodeAnalysisVSSku)'=='Express' or ('$(CodeAnalysisRules)'=='' and '$(CodeAnalysisRuleAssemblies)'=='' and '$(CodeAnalysisRuleSet)'==''))">
      <Choose>
        <When Condition="'$(Language)'=='C++' and '$(CLRSupport)'=='true' and '$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>MixedMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++' and '$(CLRSupport)'=='true'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>MixedRecommendedRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++' and '$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>NativeMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>ManagedMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <Otherwise>
          <PropertyGroup>
            <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </Otherwise>
      </Choose>
    </When>
  </Choose>
  <!-- C#/VB specific properties -->
  <PropertyGroup Condition="'$(Language)'=='C#' or '$(Language)'=='VB'">
    <!-- Run Code Analysis after the build, but before running the application-->
    <PrepareForRunDependsOn>$(PrepareForRunDependsOn);RunCodeAnalysis</PrepareForRunDependsOn>
    <RunCodeAnalysisDependsOn>$(RunCodeAnalysisDependsOn);Compile</RunCodeAnalysisDependsOn>
  </PropertyGroup>
  <!-- C++ specific properties -->
  <PropertyGroup Condition="'$(Language)'=='C++'">
    <!-- Run Code Analysis after the build, but before running the application-->
    <AfterBuildLinkTargets>$(AfterBuildLinkTargets);RunMergeNativeCodeAnalysis;RunNativeCodeAnalysis</AfterBuildLinkTargets>
    <AfterBuildLinkTargets Condition="'$(CLRSupport)'=='true'">$(AfterBuildLinkTargets);RunCodeAnalysis</AfterBuildLinkTargets>
    <RunMergeNativeCodeAnalysisDependsOn>ClCompile</RunMergeNativeCodeAnalysisDependsOn>
    <RunMergeNativeCodeAnalysisDependsOn Condition="'$(RunCodeAnalysisDependsOn)'!=''">$(RunCodeAnalysisDependsOn);$(RunMergeNativeCodeAnalysisDependsOn)</RunMergeNativeCodeAnalysisDependsOn>
    <RunCodeAnalysisDependsOn>$(RunCodeAnalysisDependsOn);ClCompile;RunMergeNativeCodeAnalysis</RunCodeAnalysisDependsOn>
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);SetCABuildNativeEnvironmentVariables</PrepareForBuildDependsOn>
    <ExtensionsToDeleteOnClean>$(ExtensionsToDeleteOnClean);$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)</ExtensionsToDeleteOnClean>
    <CodeAnalysisTLogFile>$(IntDir)CodeAnalysis.read.1.tlog</CodeAnalysisTLogFile>
    <NativeCodeAnalysisTLogFile>$(IntDir)NativeCodeAnalysis.read.1.tlog</NativeCodeAnalysisTLogFile>
    <CAExcludePath Condition="'$(WindowsSDK_IncludePath)'!=''">$(WindowsSDK_IncludePath);$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="Exists('$(VCInstallDir)include')">$(VCInstallDir)include;$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="Exists('$(VCInstallDir)atlmfc\include')">$(VCInstallDir)atlmfc\include;$(CAExcludePath)</CAExcludePath>
  </PropertyGroup>
  <Target Name="SetCABuildNativeEnvironmentVariables">
    <SetEnvironmentVariable Condition="'$(Language)'=='C++' and '$(CAExcludePath)' != ''" EnvValue="$(CAExcludePath)" EnvKey="CAExcludePath" />
  </Target>
  <ItemDefinitionGroup Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'">
    <ClCompile>
      <EnablePREFast>true</EnablePREFast>
      <!-- In Dev11 we enable quiet output since we don't show results in the Error List, but in the new CA window,
           however for the projects using v10 toolset, we want the results to go to the Error List 
           (otherwise they will be swallowed, since new CA window doesn't support older-style CA output) -->
      <AdditionalOptions Condition="'$(PlatformToolsetVersion)'&lt;'110'">%(ClCompile.AdditionalOptions)</AdditionalOptions>
      <AdditionalOptions Condition="'$(PlatformToolsetVersion)'&gt;='110'">%(ClCompile.AdditionalOptions)  /analyze:quiet</AdditionalOptions>
      <PREfastLog Condition="'$(PlatformToolsetVersion)'&lt;'120'">$(IntDir)%(FileName)%(Extension).nativecodeanalysis.xml</PREfastLog>
      <PREfastLogFile Condition="'$(PlatformToolsetVersion)'&gt;='120'">%(ObjectFileName)%(FileName).nativecodeanalysis.xml</PREfastLogFile>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Make CodeAnalysisDictionary available as a Build Action in Visual Studio -->
  <ItemGroup>
    <AvailableItemName Include="CodeAnalysisDictionary" />
  </ItemGroup>
  <!-- FxCop analyzer properties -->
  <!-- Managed analyzer targets -->
  <PropertyGroup>
    <RunCodeAnalysisInputs>$(CodeAnalysisInputAssembly)</RunCodeAnalysisInputs>
    <RunCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and Exists('$(CodeAnalysisRuleSet)')">$(RunCodeAnalysisInputs);$(CodeAnalysisRuleSet)</RunCodeAnalysisInputs>
    <RunCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and !Exists('$(CodeAnalysisRuleSet)') and Exists('$(ProjectDir)$(CodeAnalysisRuleSet)')">$(RunCodeAnalysisInputs);$(ProjectDir)$(CodeAnalysisRuleSet)</RunCodeAnalysisInputs>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.Build.Tasks.CodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <Target Name="RunCodeAnalysis" Condition="'$(RunCodeAnalysisOnThisProject)'=='true'" Inputs="$(RunCodeAnalysisInputs)" Outputs="$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)" DependsOnTargets="$(RunCodeAnalysisDependsOn)">
    <!-- Build CodeAnalysisReferencePath inside of the RunCodeAnalysis target to ensure that ReferencePath -->
    <!-- has already been populated by the ResolveReferences target prior to using it. -->
    <ItemGroup>
      <CodeAnalysisReferencePath Include="@(ReferencePath)" />
      <CodeAnalysisReferencePath Condition="'$(Language)'=='VB' and '$(VBRuntimePath)'!=''" Include="$(VBRuntimePath)" />
    </ItemGroup>
    <!-- Add AdditionalUsingDirectories as reference assembly paths for C++ projects -->
    <ItemGroup>
      <CodeAnalysisDependentAssemblyPaths Condition="'$(Language)'=='C++'" Include="%(ClCompile.AdditionalUsingDirectories)" />
    </ItemGroup>
    <!-- If it is winmd file than we want to analyze winmdobj instead of winmd file -->
    <PropertyGroup>
      <CodeAnalysisInputAssembly Condition="'$(OutputType)'=='winmdobj'">@(IntermediateAssembly)</CodeAnalysisInputAssembly>
      <CodeAnalysisInputAssembly Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'">$(IntermediateOutputPath)\TempCA\$(TargetName)$(TargetExt)</CodeAnalysisInputAssembly>
    </PropertyGroup>
    <!-- VBCompiler issue: fix the name of PDB file for winmdobj assembly -->
    <Copy Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'" DestinationFiles="$(IntermediateOutputPath)\TempCA\$(TargetName).pdb" SourceFiles="$(PdbFile)" OverwriteReadOnlyFiles="True" />
    <Copy Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'" DestinationFolder="$(IntermediateOutputPath)\TempCA\" SourceFiles="@(IntermediateAssembly)" OverwriteReadOnlyFiles="True" />
    <CodeAnalysis Condition="'$(RunCodeAnalysisOnThisProject)'=='true'" AdditionalOptions="$(CodeAnalysisAdditionalOptions)" AlternativeToolName="$(CodeAnalysisAlternativeToolName)" AnalysisTimeout="$(CodeAnalysisTimeout)" ApplyLogFileXsl="$(CodeAnalysisApplyLogFileXsl)" Assemblies="$(CodeAnalysisInputAssembly)" ConsoleXsl="$(CodeAnalysisConsoleXsl)" Culture="$(CodeAnalysisCulture)" DependentAssemblyPaths="@(CodeAnalysisDependentAssemblyPaths)" Dictionaries="@(CodeAnalysisDictionary)" DisableReferenceSwitchGeneration="$(CodeAnalysisDisableReferenceSwitchGeneration)" FailOnMissingRules="$(CodeAnalysisFailOnMissingRules)" FilesWritten="$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)" ForceOutput="$(CodeAnalysisForceOutput)" GenerateSuccessFile="$(CodeAnalysisGenerateSuccessFile)" IgnoreBuildTaskWarnings="$(CodeAnalysisIgnoreBuildTaskWarnings)" IgnoreGeneratedCode="$(CodeAnalysisIgnoreGeneratedCode)" IgnoreInvalidTargets="$(CodeAnalysisIgnoreInvalidTargets)" IgnoreMissingIndirectReferences="$(CodeAnalysisIgnoreMissingIndirectReferences)" Imports="@(CodeAnalysisImport)" LogFile="$(CodeAnalysisLogFile)" LogFileXsl="$(CodeAnalysisLogFileXsl)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" OutputToConsole="$(CodeAnalysisOutputToConsole)" OverrideRuleVisibilities="$(CodeAnalysisOverrideRuleVisibilities)" NeverReportRuleErrors="$(CodeAnalysisNeverReportRuleErrors)" PlatformPath="$(CodeAnalysisPlatformPath)" Project="$(CodeAnalysisProject)" Quiet="$(CodeAnalysisQuiet)" References="@(CodeAnalysisReferencePath)" RuleAssemblies="$(CodeAnalysisRuleAssemblies)" RuleDirectories="$(CodeAnalysisRuleDirectories)" Rules="$(CodeAnalysisRules)" RuleSet="$(CodeAnalysisRuleSet)" RuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" RuleSetOverrides="$(CodeAnalysisRuleSetOverrides)" SaveMessagesToReport="$(CodeAnalysisSaveMessagesToReport)" SearchGlobalAssemblyCache="$(CodeAnalysisSearchGlobalAssemblyCache)" SuccessFile="$(CodeAnalysisSucceededFile)" Summary="$(CodeAnalysisSummary)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TLogFile="$(CodeAnalysisTLogFile)" ToolPath="$(CodeAnalysisPath)" TreatWarningsAsErrors="$(CodeAnalysisTreatWarningsAsErrors)" UpdateProject="$(CodeAnalysisUpdateProject)" Verbose="$(CodeAnalysisVerbose)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </CodeAnalysis>
  </Target>
  <!-- Managed analyzer targets -->
  <!-- Native analyzer targets -->
  <PropertyGroup>
    <RunNativeCodeAnalysisInputs>$(OutputFile)</RunNativeCodeAnalysisInputs>
    <RunNativeCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and Exists('$(CodeAnalysisRuleSet)')">$(RunNativeCodeAnalysisInputs);$(CodeAnalysisRuleSet)</RunNativeCodeAnalysisInputs>
    <RunNativeCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and !Exists('$(CodeAnalysisRuleSet)') and Exists('$(ProjectDir)$(CodeAnalysisRuleSet)')">$(RunNativeCodeAnalysisInputs);$(ProjectDir)$(CodeAnalysisRuleSet)</RunNativeCodeAnalysisInputs>
    <MergedOutputCodeAnalysisFile>$(IntDir)vc.nativecodeanalysis.all.xml</MergedOutputCodeAnalysisFile>
  </PropertyGroup>
  <Choose>
    <When Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'">
      <Choose>
        <When Condition="'$(PlatformToolsetVersion)'&lt;'120'">
          <PropertyGroup>
            <MergeInputCodeAnalysisFiles>@(ClCompile->'%(PREfastLog)')</MergeInputCodeAnalysisFiles>
          </PropertyGroup>
        </When>
        <Otherwise>
          <PropertyGroup>
            <MergeInputCodeAnalysisFiles>@(ClCompile->'%(PREfastLogFile)')</MergeInputCodeAnalysisFiles>
          </PropertyGroup>
        </Otherwise>
      </Choose>
    </When>
  </Choose>
  <UsingTask TaskName="Microsoft.Build.Tasks.NativeCodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <Target Name="RunNativeCodeAnalysis" Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'" Inputs="$(RunCodeAnalysisInputs);$(MergedOutputCodeAnalysisFile)" Outputs="$(CodeAnalysisSucceededFile);$(NativeCodeAnalysisTLogFile)" DependsOnTargets="$(RunCodeAnalysisDependsOn)">
    <NativeCodeAnalysis Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'" IgnoreBuildTaskWarnings="$(CodeAnalysisIgnoreBuildTaskWarnings)" NativeCodeAnalysisLogFiles="$(MergedOutputCodeAnalysisFile)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" NeverReportRuleErrors="$(CodeAnalysisNeverReportRuleErrors)" RuleSet="$(CodeAnalysisRuleSet)" RuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" StaticAnalysisDirectory="$(CodeAnalysisStaticAnalysisDirectory)" TLogFile="$(NativeCodeAnalysisTLogFile)" TreatWarningsAsErrors="$(CodeAnalysisTreatWarningsAsErrors)" VisualStudioSku="$(CodeAnalysisVSSku)" CodeAnalysisSucceededFile="$(CodeAnalysisSucceededFile)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </NativeCodeAnalysis>
  </Target>
  <!-- Native analyzer targets -->
  <!-- Merge native results targets -->
  <UsingTask TaskName="Microsoft.Build.Tasks.MergeNativeCodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <Target Name="RunMergeNativeCodeAnalysis" Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'" Inputs="$(RunCodeAnalysisInputs);$(MergeInputCodeAnalysisFiles)" Outputs="$(CodeAnalysisSucceededFile);$(NativeCodeAnalysisTLogFile);$(MergedOutputCodeAnalysisFile)" DependsOnTargets="$(RunMergeNativeCodeAnalysisDependsOn)">
    <MergeNativeCodeAnalysis Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true'" InputNativeResultFiles="$(MergeInputCodeAnalysisFiles)" OutputCodeAnalysisFile="$(MergedOutputCodeAnalysisFile)" />
  </Target>
  <ItemGroup>
    <Clean Include="$(IntermediateOutputPath)\TempCA\$(TargetName).pdb" />
    <Clean Include="$(IntermediateOutputPath)\TempCA\$(TargetName)$(TargetExt)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(ReportingServicesTargets)" Condition="Exists('$(ReportingServicesTargets)')" />-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.NETFramework.targets" Condition="('$(TargetFrameworkIdentifier)' == ''  or '$(TargetFrameworkIdentifier)' == '.NETFramework') and ('$(TargetRuntime)' == 'Managed')" />-->
  <PropertyGroup>
    <ImportXamlTargets Condition="'$(ImportXamlTargets)'=='' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.Xaml.targets')">true</ImportXamlTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Xaml.targets" Condition="('$(ImportXamlTargets)' == 'true')">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!-- 
        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  

        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
   -->
  <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer 
        the .NET Framework directory and thus will no longer be the right answer. Override it to point
        to the correct .NET Framework location. -->
  <PropertyGroup>
    <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildFrameworkToolsPath)</XamlBuildTaskPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets">

C:\windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Xaml.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <LoadTimeSensitiveTargets>
      $(LoadTimeSensitiveTargets);
      XamlMarkupCompilePass1;
    </LoadTimeSensitiveTargets>
    <LoadTimeSensitiveProperties>
      $(LoadTimeSensitiveProperties);
    </LoadTimeSensitiveProperties>
    <TaskVersion>4.0.0.0</TaskVersion>
    <TaskKeyToken>31bf3856ad364e35</TaskKeyToken>
    <XamlBuildTaskAssemblyName Condition="'$(XamlBuildTaskAssemblyName)'==''">XamlBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</XamlBuildTaskAssemblyName>
    <XamlRequiresCompilationPass2 Condition="'$(XamlRequiresCompilationPass2)'==''">false</XamlRequiresCompilationPass2>
    <XamlTemporaryAssemblyName Condition="'$(XamlTemporaryAssemblyName)'==''">$(AssemblyName)</XamlTemporaryAssemblyName>
    <CompileTargetNameForTemporaryAssembly Condition="'$(CompileTargetNameForTemporaryAssembly)' == ''">CompileTemporaryAssembly</CompileTargetNameForTemporaryAssembly>
    <!-- Microsoft.Xaml.targets needs to be included after Microsoft.Fx.targets and Microsoft.DevDiv.targets
       to have a chance to add these tasks to the PrepareResources target's dependencies. 
       Unfortunately, Microsoft.DevDiv.targets completely overwrites the PrepareResourcesDependsOnProperty 
       (as a bug workaround-see comment there).
  -->
    <PrepareResourcesDependsOn>
      XamlMarkupCompilePass1;
      XamlMarkupCompilePass2;
      $(PrepareResourcesDependsOn) 
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <XamlBuildTaskLocation Condition="'$(XamlBuildTaskPath)'==''">$(MSBuildBinPath)</XamlBuildTaskLocation>
    <XamlBuildTaskLocation Condition="'$(XamlBuildTaskPath)'!=''">$(XamlBuildTaskPath)</XamlBuildTaskLocation>
  </PropertyGroup>
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildToolsPath)\Microsoft.Xaml.targets</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <XamlGenCodeFileNames Condition="'$(XamlGenCodeFileNames)'==''">$(MSBuildProjectFile).XamlGeneratedCodeFileListAbsolute.txt</XamlGenCodeFileNames>
    <XamlGenMarkupFileNames Condition="'$(XamlGenMarkupFileNames)'==''">$(MSBuildProjectFile).XamlGeneratedXamlFileListAbsolute.txt</XamlGenMarkupFileNames>
    <XamlPass2FlagFile Condition="'$(XamlPass2FlagFile)'==''">$(MSBuildProjectFile).XamlPass2Flag.txt</XamlPass2FlagFile>
  </PropertyGroup>
  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="XamlAppDef" />
  </ItemGroup>
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.GenerateTemporaryAssemblyTask" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.GenerateTemporaryAssemblyTask" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.CompilationPass2Task" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.CompilationPass2Task" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <!--
  ================================================================
                         DesignTimeXamlMarkupCompilation
  ================================================================
  -->
  <PropertyGroup>
    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true'">
        DesignTimeXamlMarkupCompilation;
        $(CoreCompileDependsOn)
    </CoreCompileDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <DesignTimeIntermediateOutputPath Condition="'$(DesignTimeIntermediateOutputPath)' == ''">$(IntermediateOutputPath)InProcessTempFiles\</DesignTimeIntermediateOutputPath>
  </PropertyGroup>
  <Target Name="DesignTimeXamlMarkupCompilation">
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(DesignTimeIntermediateOutputPath)" Condition="'@(XamlAppDef)' != ''" />
    <CallTarget Condition="'$(BuildingProject)' != 'true' and '@(XamlAppDef)' != ''" Targets="InProcessXamlMarkupCompilePass1" />
  </Target>
  <!--
  ================================================================
                         InProcessXamlMarkupCompilePass1
  ================================================================
  -->
  <Target Name="InProcessXamlMarkupCompilePass1" Condition="'@(XamlAppDef)' != '' and '$(BuildingProject)' != 'true'">
    <PartialClassGenerationTask BuildTaskPath="$(XamlBuildTaskLocation)" OutputPath="$(DesignTimeIntermediateOutputPath)" Language="$(Language)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" RootNamespace="$(RootNamespace)" SourceCodeFiles="@(Compile)" AssemblyName="$(AssemblyName)" IsInProcessXamlMarkupCompile="true" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)" XamlBuildTypeGenerationExtensionNames="@(XamlBuildTaskTypeGenerationExtensionName)">
      <Output ItemName="XamlInProcessGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="XamlInProcessGeneratedResources" TaskParameter="GeneratedResources" />
      <!-- This property is not required. However we need to populate it as the output of the task. -->
      <Output PropertyName="XamlInProcessRequiresCompilationPass2" TaskParameter="RequiresCompilationPass2" />
    </PartialClassGenerationTask>
    <ItemGroup>
      <Compile Include="@(XamlInProcessGeneratedCodeFiles)" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         CleanInProcessXamlGeneratedFiles
  ================================================================
  -->
  <Target Name="CleanInProcessXamlGeneratedFiles" Condition="'@(XamlAppDef)' != ''" AfterTargets="DesignTimeXamlMarkupCompilation">
    <ItemGroup>
      <FileWrites Include="$(DesignTimeIntermediateOutputPath)\*" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileReadGeneratedFileList
  ================================================================
  -->
  <Target Name="XamlMarkupCompileReadGeneratedFileList" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" BeforeTargets="XamlMarkupCompilePass1">
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)">
      <Output TaskParameter="Lines" ItemName="XamlOutputCodeFilesList" />
    </ReadLinesFromFile>
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlGenMarkupFileNames)">
      <Output TaskParameter="Lines" ItemName="XamlOutputMarkupFilesList" />
    </ReadLinesFromFile>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompilePass1
  ================================================================
  -->
  <Target Name="XamlMarkupCompilePass1" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" Inputs="@(XamlAppDef);@(Compile);$(MSBuildAllProjects);@(ReferencePath)" Outputs="@(XamlOutputMarkupFilesList);&#xD;&#xA;                  @(XamlOutputCodeFilesList);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlGenCodeFileNames);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlGenMarkupFileNames);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlPass2FlagFile);">
    <Message Text="(in) XamlPage: '@(XamlPage)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) XamlAppDef: '@(XamlAppDef)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) SourceCodeFiles: '@(Compile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <ItemGroup>
      <XamlGeneratedResources Remove="@(XamlGeneratedResources)" />
      <XamlGeneratedCodeFiles Remove="@(XamlGeneratedCodeFiles)" />
    </ItemGroup>
    <PartialClassGenerationTask BuildTaskPath="$(XamlBuildTaskLocation)" OutputPath="$(IntermediateOutputPath)" Language="$(Language)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" RootNamespace="$(RootNamespace)" SourceCodeFiles="@(Compile)" AssemblyName="$(AssemblyName)" IsInProcessXamlMarkupCompile="false" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" XamlBuildTypeGenerationExtensionNames="@(XamlBuildTaskTypeGenerationExtensionName)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)">
      <Output ItemName="XamlGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="XamlGeneratedResources" TaskParameter="GeneratedResources" />
      <Output ItemName="XamlFileNames" TaskParameter="ApplicationMarkup" />
      <Output PropertyName="XamlRequiresCompilationPass2" TaskParameter="RequiresCompilationPass2" />
    </PartialClassGenerationTask>
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)" Lines="@(XamlGeneratedCodeFiles)" Overwrite="true" />
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenMarkupFileNames)" Lines="@(XamlGeneratedResources)" Overwrite="true" />
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)" Lines="@(XamlRequiresCompilationPass2)" Overwrite="true" />
    <Message Text="(out) XamlGeneratedCodeFiles: '@(XamlGeneratedCodeFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(out) XamlGeneratedResources: '@(XamlGeneratedResources)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(out) XamlRequiresCompilationPass2 : '$(XamlRequiresCompilationPass2)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileAddFilesGenerated
  ================================================================
  -->
  <Target Name="XamlMarkupCompileAddFilesGenerated" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" AfterTargets="XamlMarkupCompilePass1">
    <ItemGroup>
      <XamlGeneratedCodeFiles Condition="'@(XamlGeneratedCodeFiles)' == ''" Include="@(XamlOutputCodeFilesList)" />
    </ItemGroup>
    <ItemGroup>
      <XamlGeneratedResources Condition="'@(XamlGeneratedResources)' == ''" Include="@(XamlOutputMarkupFilesList)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(XamlGeneratedResources);&#xD;&#xA;                           @(XamlGeneratedCodeFiles);&#xD;&#xA;                           $(IntermediateOutputPath)$(XamlGenCodeFileNames);&#xD;&#xA;                           $(IntermediateOutputPath)$(XamlGenMarkupFileNames)" />
    </ItemGroup>
    <ItemGroup>
      <Compile Include="@(XamlGeneratedCodeFiles)" />
    </ItemGroup>
    <ItemGroup>
      <EmbeddedResource Include="@(XamlGeneratedResources)">
        <GenerateResource>false</GenerateResource>
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </EmbeddedResource>
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileReadPass2Flag
  ================================================================
  -->
  <Target Name="XamlMarkupCompileReadPass2Flag" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" BeforeTargets="XamlMarkupCompilePass2;XamlTemporaryAssemblyGeneration">
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)">
      <Output TaskParameter="Lines" ItemName="XamlRequiresCompilationPass2" />
    </ReadLinesFromFile>
  </Target>
  <!--
  ================================================================
                         XamlTemporaryAssemblyGeneration
  ================================================================
  -->
  <Target Name="XamlTemporaryAssemblyGeneration" Condition="'$(XamlRequiresCompilationPass2)' == 'true' " Inputs="@(XamlAppDef);@(Compile);$(MSBuildAllProjects);@(XamlGeneratedCodeFiles);@(ReferencePath)" Outputs="$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).dll;&#xD;&#xA;                   $(IntermediateOutputPath)$(XamlTemporaryAssemblyName).pdb" DependsOnTargets="XamlMarkupCompilePass1;MarkupCompilePass1">
    <Message Text="(in) MSBuildProjectFile: '$(MSBuildProjectFile)'" Condition="'$(MSBuildTargetsVerbose)' == 'true'" />
    <Message Text="(in) CompileTargetName: '$(CompileTargetName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) SourceCodeFiles: '@(XamlGeneratedCodeFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <GenerateTemporaryAssemblyTask OutputPath="$(IntermediateOutputPath)" CurrentProject="$(MSBuildProjectFullPath)" SourceCodeFiles="@(XamlGeneratedCodeFiles);@(_GeneratedCodeFiles)" AssemblyName="$(XamlTemporaryAssemblyName)" ApplicationMarkupTypeName="XamlAppDef" CompileTargetName="$(CompileTargetNameForTemporaryAssembly)" ReferencePaths="@(ReferencePath)" GeneratedResourcesFiles="@(XamlGeneratedResources)" />
    <PropertyGroup>
      <_XamlTemporaryAssemblyPath_>$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).dll</_XamlTemporaryAssemblyPath_>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).*" />
    </ItemGroup>
  </Target>
  <Target Name="CompileTemporaryAssembly" DependsOnTargets="BuildOnlySettings;ResolveKeySource;_GenerateCompileInputs;CoreCompile" />
  <!--
  ================================================================
                         XamlMarkupCompilePass2
  ================================================================
  -->
  <Target Name="XamlMarkupCompilePass2" Condition="'$(XamlRequiresCompilationPass2)' == 'true' " Outputs="@(ExtensionGeneratedCodeFiles)" DependsOnTargets="XamlTemporaryAssemblyGeneration">
    <Message Text="(in) XamlPage: '@(XamlPage)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) XamlAppDef: '@(XamlAppDef)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) References: '@(ReferencePath);$(_XamlTemporaryAssemblyPath_)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <CompilationPass2Task BuildTaskPath="$(XamlBuildTaskLocation)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" LocalAssemblyReference="$(_XamlTemporaryAssemblyPath_)" AssemblyName="$(AssemblyName)" RootNamespace="$(RootNamespace)" OutputPath="$(IntermediateOutputPath)" Language="$(Language)" SourceCodeFiles="@(Compile)" IsInProcessXamlMarkupCompile="false" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" MSBuildArchitecture="$(PlatformTargetAsMSBuildArchitecture)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)" ApplicationMarkupWithTypeName="@(XamlFileNames)">
      <Output ItemName="ExtensionGeneratedCodeFiles" TaskParameter="ExtensionGeneratedCodeFiles" />
    </CompilationPass2Task>
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)" Lines="false" Overwrite="true" />
    <Message Text="(out) ExtensionGeneratedCodeFiles: '@(ExtensionGeneratedCodeFiles)'" />
    <!-- Add extension files to the list of generated files so that they can be monitored and cleaned up -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)" Lines="@(ExtensionGeneratedCodeFiles)" Overwrite="false" />
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileAddFilesGenerated
  ================================================================
  -->
  <Target Name="XamlMarkupCompileAddExtensionFilesGenerated" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" AfterTargets="XamlMarkupCompilePass2">
    <ItemGroup>
      <FileWrites Include="@(ExtensionGeneratedCodeFiles)" />
    </ItemGroup>
    <ItemGroup>
      <Compile Include="@(ExtensionGeneratedCodeFiles)" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                 GetCopyToOutputDirectoryXamlAppDefs

  Get all XamlAppDefs that may need to be transferred to the output directory.
  Compare GetCopyToOutputDirectoryItems in Microsoft.Common.targets
  ================================================================
  -->
  <Target Name="GetCopyToOutputDirectoryXamlAppDefs" BeforeTargets="GetCopyToOutputDirectoryItems">
    <ItemGroup>
      <_XamlAppDefItemsToCopy Include="@(XamlAppDef->'%(FullPath)')" Condition="'%(XamlAppDef.CopyToOutputDirectory)'=='Always' or '%(XamlAppDef.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <AssignTargetPath Files="@(_XamlAppDefItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_XamlAppDefItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <!-- The _SourceItems properties are internal to Microsoft.Common.targets,
         but necessary to use here because there is no public equivalent -->
    <ItemGroup>
      <AllItemsFullPathWithTargetPath Include="@(_XamlAppDefItemsToCopyWithTargetPath)" />
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_XamlAppDefItemsToCopyWithTargetPath)" Condition="'%(_XamlAppDefItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory Include="@(_XamlAppDefItemsToCopyWithTargetPath)" Condition="'%(_XamlAppDefItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- imports Microsoft.WorkflowBuildExtensions.targets only if TargetFrameworkVersion is v4.5 or above or TargetFrameworkfVersion specified does not conform to the format of vX.X[.X.X] -->
  <!-- Underlying assumption is that there shouldn't be any other versions between v4.0.* and v4.5 -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5' and (!$([System.String]::IsNullOrEmpty('$(TargetFrameworkVersion)')) and !$(TargetFrameworkVersion.StartsWith('v4.0')))) and Exists('$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets')">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.WorkflowBuildExtensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.WorkflowBuildExtensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- 
        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  

        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
   -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets">

C:\windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.WorkflowBuildExtensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.WorkflowBuildExtensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <PrepareResourcesDependsOn>
      ValidationExtension;
      ExpressionBuildExtension;
      $(PrepareResourcesDependsOn)
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true'">
        GenerateCompiledExpressionsTempFile;
        $(CoreCompileDependsOn)
    </CoreCompileDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <WorkflowBuildExtensionVersion Condition="'$(WorkflowBuildExtensionVersion)'==''">4.0.0.0</WorkflowBuildExtensionVersion>
    <WorkflowBuildExtensionKeyToken Condition="'$(WorkflowBuildExtensionKeyToken)'==''">31bf3856ad364e35</WorkflowBuildExtensionKeyToken>
    <WorkflowBuildExtensionAssemblyName Condition="'$(WorkflowBuildExtensionAssemblyName)'==''">Microsoft.Activities.Build, Version=$(WorkflowBuildExtensionVersion), Culture=neutral, PublicKeyToken=$(WorkflowBuildExtensionKeyToken)</WorkflowBuildExtensionAssemblyName>
    <GenerateCompiledExpressionsTempFilePathForEditing Condition="'$(MSBuildProjectExtension)' == '.csproj'">$(IntermediateOutputPath)\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs</GenerateCompiledExpressionsTempFilePathForEditing>
    <GenerateCompiledExpressionsTempFilePathForValidation Condition="'$(MSBuildProjectExtension)' == '.csproj'">$(IntermediateOutputPath)\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs</GenerateCompiledExpressionsTempFilePathForValidation>
    <GenerateCompiledExpressionsTempFilePathForTypeInfer Condition="'$(MSBuildProjectExtension)' == '.csproj'">$(IntermediateOutputPath)\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs</GenerateCompiledExpressionsTempFilePathForTypeInfer>
    <DeferredValidationErrorsFileName>$(IntermediateOutputPath)\AC2C1ABA-CCF6-44D4-8127-588FD4D0A860-DeferredValidationErrors.xml</DeferredValidationErrorsFileName>
  </PropertyGroup>
  <UsingTask TaskName="WorkflowBuildMessageTask" AssemblyName="$(WorkflowBuildExtensionAssemblyName)" />
  <UsingTask TaskName="ReportDeferredValidationErrorsTask" AssemblyName="$(WorkflowBuildExtensionAssemblyName)" />
  <UsingTask TaskName="DeferredValidationTask" AssemblyName="$(WorkflowBuildExtensionAssemblyName)" />
  <ItemGroup>
    <XamlBuildTaskTypeGenerationExtensionName Include="Microsoft.Activities.Build.BeforeInitializeComponentExtension">
      <AssemblyName>$(WorkflowBuildExtensionAssemblyName)</AssemblyName>
      <Visible>false</Visible>
    </XamlBuildTaskTypeGenerationExtensionName>
    <XamlBuildTaskTypeGenerationExtensionName Include="Microsoft.Activities.Build.Debugger.DebugBuildExtension">
      <AssemblyName>$(WorkflowBuildExtensionAssemblyName)</AssemblyName>
      <Visible>false</Visible>
    </XamlBuildTaskTypeGenerationExtensionName>
  </ItemGroup>
  <Target Name="ExpressionBuildExtension">
    <WorkflowBuildMessageTask ResourceName="InvalidValueForDisableWorkflowCompiledExpressions" MessageType="Warning" Condition="'$(DisableWorkflowCompiledExpressions)'!='' and '$(DisableWorkflowCompiledExpressions)'!='true' and '$(DisableWorkflowCompiledExpressions)'!='false'" />
    <ItemGroup>
      <XamlBuildTaskTypeInspectionExtensionName Include="Microsoft.Activities.Build.Expressions.ExpressionsBuildExtension" Condition="$(DisableWorkflowCompiledExpressions)!=true">
        <AssemblyName>$(WorkflowBuildExtensionAssemblyName)</AssemblyName>
        <Visible>false</Visible>
      </XamlBuildTaskTypeInspectionExtensionName>
    </ItemGroup>
  </Target>
  <!-- XBT Validation Extension-->
  <Target Name="ValidationExtension">
    <WorkflowBuildMessageTask ResourceName="InvalidValueForSkipWorkflowValidation" MessageType="Warning" Condition="'$(SkipWorkflowValidation)'!='' and '$(SkipWorkflowValidation)'!='true' and '$(SkipWorkflowValidation)'!='false'" />
    <ItemGroup>
      <XamlBuildTaskTypeInspectionExtensionName Include="Microsoft.Activities.Build.Validation.ValidationBuildExtension" Condition="$(SkipWorkflowValidation)!=true">
        <AssemblyName>$(WorkflowBuildExtensionAssemblyName)</AssemblyName>
        <Visible>false</Visible>
      </XamlBuildTaskTypeInspectionExtensionName>
    </ItemGroup>
  </Target>
  <Target Name="GenerateCompiledExpressionsTempFile" Condition="'$(GenerateCompiledExpressionsTempFilePathForEditing)' != ''">
    <WriteLinesToFile File="$(GenerateCompiledExpressionsTempFilePathForEditing)" Condition="!Exists('$(GenerateCompiledExpressionsTempFilePathForEditing)')" />
    <WriteLinesToFile File="$(GenerateCompiledExpressionsTempFilePathForValidation)" Condition="!Exists('$(GenerateCompiledExpressionsTempFilePathForValidation)')" />
    <WriteLinesToFile File="$(GenerateCompiledExpressionsTempFilePathForTypeInfer)" Condition="!Exists('$(GenerateCompiledExpressionsTempFilePathForTypeInfer)')" />
    <ItemGroup>
      <Compile Include="$(GenerateCompiledExpressionsTempFilePathForEditing)" />
      <Compile Include="$(GenerateCompiledExpressionsTempFilePathForValidation)" />
      <Compile Include="$(GenerateCompiledExpressionsTempFilePathForTypeInfer)" />
    </ItemGroup>
  </Target>
  <Target Name="AddDeferredValidationErrorsFileToFileWrites" AfterTargets="XamlMarkupCompilePass2" Condition="Exists('$(DeferredValidationErrorsFileName)')">
    <ItemGroup>
      <FileWrites Include="$(DeferredValidationErrorsFileName)" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                 ReportValidationBuildExtensionErrors
        Report deferred validation extension errors.
  ================================================================
  -->
  <Target Name="ReportValidationBuildExtensionErrors" AfterTargets="XamlMarkupCompilePass2" Condition="'$(SkipWorkflowValidation)' != 'true' and ('@(XamlPage)' != '' or '@(XamlAppDef)' != '')">
    <ReportDeferredValidationErrorsTask DeferredValidationErrorsFilePath="$(DeferredValidationErrorsFileName)" />
  </Target>
  <!--
  ==================================================================
                 DeferredValidation
        Fail the entire build process in case any validation errors
        been previously reported, but after Compile succeeded.
  ==================================================================
  -->
  <Target Name="DeferredValidation" AfterTargets="Compile" Condition="'$(SkipWorkflowValidation)' != 'true' and ('@(XamlPage)' != '' or '@(XamlAppDef)' != '')">
    <DeferredValidationTask DeferredValidationErrorsFilePath="$(DeferredValidationErrorsFileName)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.WorkflowBuildExtensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')" />-->
  <PropertyGroup>
    <MsTestToolsTargets Condition="'$(MsTestToolsTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TeamTest\Microsoft.TeamTest.targets</MsTestToolsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\TeamTest\Microsoft.TeamTest.targets
============================================================================================================================================
-->
  <UsingTask TaskName="BuildShadowTask" AssemblyFile="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v14.0\TeamTest\Microsoft.VisualStudio.TestTools.BuildShadowsTask.dll" />
  <PropertyGroup>
    <ResolveReferencesDependsOn>
      $(ResolveReferencesDependsOn);
      ResolveTestReferences
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <!--
       The condition here ensures that we aren't needlessly loaded into projects
       that don't actually have shadow items in them
  -->
  <Target Name="ResolveTestReferences" Condition="'@(Shadow)'!=''">
    <BuildShadowTask ExecuteAsTool="False" CurrentResolvedReferences="@(ReferencePath)" CurrentCopyLocalFiles="@(ReferenceCopyLocalPaths)" Shadows="@(Shadow)" ProjectPath="$(ProjectDir)" IntermediatePath="$(IntermediateOutputPath)" SignAssembly="$(SignAssembly)" KeyFile="$(AssemblyOriginatorKeyFile)" DelaySign="$(DelaySign)">
      <Output TaskParameter="FixedUpReferences" ItemName="ReferencePath" />
      <Output TaskParameter="NewCopyLocalAssemblies" ItemName="ReferenceCopyLocalPaths" />
    </BuildShadowTask>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- App packaging support -->
  <!-- 
    Following two targets are needed to be present in every project being built
    because the app packaging targets recursively scan all projects referenced
    from projects that generate app packages for them.
  -->
  <Target Name="CleanAppxPackage" />
  <Target Name="GetPackagingOutputs" />
  <PropertyGroup>
    <MsAppxPackageTargets Condition="'$(MsAppxPackageTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\Microsoft.AppXPackage.Targets</MsAppxPackageTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MsAppxPackageTargets)" Condition="'$(WindowsAppContainer)' == 'true' and Exists('$(MsAppxPackageTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\AppxPackage\Microsoft.AppXPackage.Targets
============================================================================================================================================
-->
  <!-- ========================================================================== -->
  <!-- Note: After updating this file, make sure that                             -->
  <!-- %DepotRoot%\xmake\XmakeCommandLine\Microsoft.Build.CommonTypes.xsd         -->
  <!-- is updated to reflect changes.                                             -->
  <!--                                                                            -->
  <!-- To test whether schema changes are OK, copy changed XSD file to            -->
  <!-- %ProgramFiles(x86)%\Microsoft Visual Studio 14.0\Xml\Schemas\1033\MSBuild, -->
  <!-- then open this file in Visual Studio.                                      -->
  <!-- It should not display any schema warnings in error list window.            -->
  <!-- ========================================================================== -->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <AppxMSBuildToolsPath Condition="'$(AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</AppxMSBuildToolsPath>
    <AppxMSBuildTaskAssembly Condition="'$(AppxMSBuildTaskAssembly)' == ''">$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</AppxMSBuildTaskAssembly>
  </PropertyGroup>
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppStoreContainer" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForFullIndex" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForMainPackageFileMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForSplitting" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriFilesForPortableLibraries" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPayloadDirectories" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPriContent" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExtractStoreAssociationInformation" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterOutUnusedLanguagesResourceFileMaps" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxPackageRecipe" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxSymbolPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GeneratePriConfigurationFiles" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectArchitecturesFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectPriFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetDefaultResourceLanguage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetPackageArchitecture" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkPropertyValue" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkFileFullPath" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetUnionWinmdPropertyValues" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetWindowsDesktopSdkDir" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxPack" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ParsePlatformSpecificBundleArtifactsLists" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemovePayloadDuplicates" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicatePriFiles" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicateSDKReferences" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateAppxManifestForBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateMainPackageFileMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifestItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateStoreManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.VerifyAppxBundlePlatforms" />
  <!-- Adjust AppxPackage to be true Boolean flag. -->
  <PropertyGroup>
    <AppxPackage Condition="'$(AppxPackage)' != 'true'">false</AppxPackage>
  </PropertyGroup>
  <!-- Flags controlling certain features -->
  <PropertyGroup>
    <AppxUseHardlinksIfPossible Condition="'$(AppxUseHardlinksIfPossible)' == ''">true</AppxUseHardlinksIfPossible>
    <AppxSkipUnchangedFiles Condition="'$(AppxSkipUnchangedFiles)' == ''">true</AppxSkipUnchangedFiles>
    <AppxGeneratePriEnabled Condition="'$(AppxGeneratePriEnabled)' == ''">true</AppxGeneratePriEnabled>
    <AppxGetPackagePropertiesEnabled Condition="'$(AppxGetPackagePropertiesEnabled)' == ''">true</AppxGetPackagePropertiesEnabled>
    <AppxPackageIncludePrivateSymbols Condition="'$(AppxPackageIncludePrivateSymbols)' == ''">false</AppxPackageIncludePrivateSymbols>
    <AppxSymbolPackageEnabled Condition="'$(AppxSymbolPackageEnabled)' == ''">true</AppxSymbolPackageEnabled>
    <AppxTestLayoutEnabled Condition="'$(AppxTestLayoutEnabled)' == ''">true</AppxTestLayoutEnabled>
    <AppxPackageValidationEnabled Condition="'$(AppxPackageValidationEnabled)' == ''">true</AppxPackageValidationEnabled>
    <AppxHarvestWinmdRegistration Condition="'$(AppxHarvestWinmdRegistration)' == ''">true</AppxHarvestWinmdRegistration>
    <AutoIncrementPackageRevision Condition="'$(AutoIncrementPackageRevision)' == ''">true</AutoIncrementPackageRevision>
    <AppxPrependPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == ''">true</AppxPrependPriInitialPath>
    <EnableSigningChecks Condition=" '$(EnableSigningChecks)' == '' ">true</EnableSigningChecks>
    <AppxStrictManifestValidationEnabled Condition="'$(AppxStrictManifestValidationEnabled)' == ''">true</AppxStrictManifestValidationEnabled>
    <AppxFilterOutUnusedLanguagesResourceFileMaps Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == ''">true</AppxFilterOutUnusedLanguagesResourceFileMaps>
    <AppxGeneratePrisForPortableLibrariesEnabled Condition="'$(AppxGeneratePrisForPortableLibrariesEnabled)' == ''">true</AppxGeneratePrisForPortableLibrariesEnabled>
    <AppxGeneratePackageRecipeEnabled Condition="'$(AppxGeneratePackageRecipeEnabled)' == ''">true</AppxGeneratePackageRecipeEnabled>
  </PropertyGroup>
  <PropertyGroup>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'Windows Phone'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'WindowsPhoneApp'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(_TargetPlatformIsWindowsPhone)' == ''">false</_TargetPlatformIsWindowsPhone>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AppxPackageSigningEnabled)' == ''">
    <AppxPackageSigningEnabled Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">false</AppxPackageSigningEnabled>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' == ''">true</AppxPackageSigningEnabled>
  </PropertyGroup>
  <!-- Various properties not intended for overriding. -->
  <PropertyGroup>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and  '$(SDKIdentifier)' != ''">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(_TargetPlatformIsWindowsPhone)' == 'true'">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(TargetPlatformIdentifier)' == 'Windows'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == ''">6.2.1</AppxOSMinVersion>
  </PropertyGroup>
  <PropertyGroup>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(SDKIdentifier)' != ''">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == ''">$(AppxOSMinVersion)</AppxOSMaxVersionTested>
  </PropertyGroup>
  <PropertyGroup>
    <AppxPackageDirName Condition="'$(AppxPackageDirName)' == ''">AppPackages</AppxPackageDirName>
    <AppxPackageDirWasSpecified Condition="'$(AppxPackageDir)' != ''">true</AppxPackageDirWasSpecified>
    <AppxPackageDirInProjectDir>$(ProjectDir)$(AppxPackageDirName)\</AppxPackageDirInProjectDir>
    <PlatformSpecificBundleArtifactsListDirName Condition="'$(PlatformSpecificBundleArtifactsListDirName)' == ''">BundleArtifacts</PlatformSpecificBundleArtifactsListDirName>
    <PlatformSpecificBundleArtifactsListDirWasSpecified Condition="'$(PlatformSpecificBundleArtifactsListDir)' != ''">true</PlatformSpecificBundleArtifactsListDirWasSpecified>
    <PlatformSpecificBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDirInProjectDir>
    <PlatformSpecificUploadBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)Upload\</PlatformSpecificUploadBundleArtifactsListDirInProjectDir>
  </PropertyGroup>
  <!-- Various overridable properties. -->
  <PropertyGroup>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(AppxPackageDirName)\</AppxPackageDir>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(AppxPackageDirInProjectDir)</AppxPackageDir>
    <AppxPackageDir Condition="!HasTrailingSlash('$(AppxPackageDir)')">$(AppxPackageDir)\</AppxPackageDir>
    <AppxPackageArtifactsDir Condition="'$(AppxPackageArtifactsDir)' == ''" />
    <AppxUploadPackageArtifactsDir Condition="'$(AppxUploadPackageArtifactsDir)' == ''">Upload\</AppxUploadPackageArtifactsDir>
    <FinalAppxManifestName Condition="'$(FinalAppxManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)AppxManifest.xml</FinalAppxManifestName>
    <FinalAppxUploadManifestName Condition="'$(FinalAppxUploadManifestName)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)AppxManifest.xml</FinalAppxUploadManifestName>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' == ''">true</AppxValidateAppxManifest>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' != 'true'">false</AppxValidateAppxManifest>
    <StoreManifestName Condition="'$(StoreManifestName)' == ''">StoreManifest.xml</StoreManifestName>
    <!-- AppxValidateStoreManifest isn't defined here, because the default depends on the TargetPlatform/Version -->
    <MakePriExeFullPath Condition="'$(MakePriExeFullPath)' == ''" />
    <MakeAppxExeFullPath Condition="'$(MakeAppxExeFullPath)' == ''" />
    <SignAppxPackageExeFullPath Condition="'$(SignAppxPackageExeFullPath)' == ''" />
    <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    <PdbCopyExeFullPath Condition="'$(PdbCopyExeFullPath)' == ''">$(AppxMSBuildToolsPath)PDBCopy.exe</PdbCopyExeFullPath>
    <AppxSymbolStrippedDir Condition="'$(AppxSymbolStrippedDir)' == ''">$(IntermediateOutputPath)Stripped</AppxSymbolStrippedDir>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' != 'true'" />
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' == 'true' and '$(AppxPriInitialPath)' == ''" />
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</AppxPriInitialPath>
    <ProjectPriFileName Condition="'$(AppxPackage)' == 'true' and '$(ProjectPriFileName)' == ''">resources.pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == ''">$(AppxPriInitialPath).pri</ProjectPriFileName>
    <ProjectPriFullPath Condition="'$(ProjectPriFullPath)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriFullPath>
    <ProjectPriUploadFullPath Condition="'$(ProjectPriUploadFullPath)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriUploadFullPath>
    <AppxPackageRecipe Condition="'$(AppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxPackageRecipe>
    <AppxUploadPackageRecipe Condition="'$(AppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxUploadPackageRecipe>
    <FinalAppxPackageRecipe Condition="'$(FinalAppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxPackageRecipe>
    <FinalAppxUploadPackageRecipe Condition="'$(FinalAppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxUploadPackageRecipe>
    <AllowLocalNetworkLoopback Condition="'$(AllowLocalNetworkLoopback)' == ''">true</AllowLocalNetworkLoopback>
    <AppxDefaultHashAlgorithmId Condition="'$(AppxDefaultHashAlgorithmId)' == ''">sha256</AppxDefaultHashAlgorithmId>
    <AppxPackageFileMap Condition="'$(AppxPackageFileMap)' == ''">$(IntermediateOutputPath)package.map.txt</AppxPackageFileMap>
    <AppxUploadPackageFileMap Condition="'$(AppxUploadPackageFileMap)' == ''">$(IntermediateOutputPath)upload.package.map.txt</AppxUploadPackageFileMap>
    <LayoutDir Condition="'$(LayoutDir)'==''">$(TargetDir)AppX</LayoutDir>
    <ManagedWinmdInprocImplementation Condition="'$(ManagedWinmdInprocImplementation)' == ''">CLRHost.dll</ManagedWinmdInprocImplementation>
    <UseIncrementalAppxRegistration Condition="'$(UseIncrementalAppxRegistration)' == ''">true</UseIncrementalAppxRegistration>
    <AppxPackagingInfoFile Condition="'$(AppxPackagingInfoFile)' == ''">$(IntermediateOutputPath)_pkginfo.txt</AppxPackagingInfoFile>
    <AppxUploadPackagingInfoFile Condition="'$(AppxUploadPackagingInfoFile)' == ''">$(IntermediateUploadOutputPath)_pkginfo.txt</AppxUploadPackagingInfoFile>
    <AppxOSMinVersionReplaceManifestVersion Condition="'$(AppxOSMinVersionReplaceManifestVersion)' == ''">true</AppxOSMinVersionReplaceManifestVersion>
    <AppxOSMaxVersionTestedReplaceManifestVersion Condition="'$(AppxOSMaxVersionTestedReplaceManifestVersion)' == ''">true</AppxOSMaxVersionTestedReplaceManifestVersion>
    <PackagingFileWritesLogPath Condition="'$(PackagingFileWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingFileWrites.log</PackagingFileWritesLogPath>
    <PackagingDirectoryWritesLogPath Condition="'$(PackagingDirectoryWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingDirectoryWrites.log</PackagingDirectoryWritesLogPath>
    <AppxCopyLocalFilesOutputGroupIncludeXmlFiles Condition="'$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' != 'true'">false</AppxCopyLocalFilesOutputGroupIncludeXmlFiles>
    <AppxPriConfigXmlPackagingSnippetPath Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''" />
    <AppxPriConfigXmlDefaultSnippetPath Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''" />
    <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == ''" />
    <TargetPlatformResourceVersion Condition="'$(TargetPlatformResourceVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformResourceVersion>
    <AppxPackageExtension>.appx</AppxPackageExtension>
    <AppxSymbolPackageExtension>.appxsym</AppxSymbolPackageExtension>
    <AppxBundleExtension>.appxbundle</AppxBundleExtension>
    <AppxStoreContainerExtension>.appxupload</AppxStoreContainerExtension>
    <AppxIntermediateExtension>.intermediate</AppxIntermediateExtension>
    <AppxBundle Condition="'$(TargetPlatformVersion)' == '8.0'">Never</AppxBundle>
    <AppxBundle Condition="'$(AppxBundle)' == ''">Auto</AppxBundle>
    <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''" />
    <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''" />
    <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''" />
    <AppxLayoutFolderName Condition="'$(AppxLayoutFolderName)' == ''">PackageLayout</AppxLayoutFolderName>
    <IntermediateUploadOutputPath Condition="'$(IntermediateUploadOutputPath)' == ''">$(IntermediateOutputPath)Upload\</IntermediateUploadOutputPath>
    <AppxLayoutDir Condition="'$(AppxLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxLayoutFolderName)\</AppxLayoutDir>
    <AppxLayoutDir Condition="!HasTrailingSlash('$(AppxLayoutDir)')">$(AppxLayoutDir)\</AppxLayoutDir>
    <AppxUploadLayoutFolderName Condition="'$(AppxUploadLayoutFolderName)' == ''">PackageUploadLayout</AppxUploadLayoutFolderName>
    <AppxUploadLayoutDir Condition="'$(AppxUploadLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxUploadLayoutFolderName)</AppxUploadLayoutDir>
    <AppxUploadLayoutDir Condition="!HasTrailingSlash('$(AppxUploadLayoutDir)')">$(AppxUploadLayoutDir)\</AppxUploadLayoutDir>
    <AppxBundleSplitResourcesPriPrefix Condition="'$(AppxBundleSplitResourcesPriPrefix)' == ''">split</AppxBundleSplitResourcesPriPrefix>
    <AppxBundlePriConfigXmlForSplittingFileName Condition="'$(AppxBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxBundlePriConfigXmlForSplittingFileName>
    <AppxUploadBundlePriConfigXmlForSplittingFileName Condition="'$(AppxUploadBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxUploadBundlePriConfigXmlForSplittingFileName>
    <AppxBundleAutoResourcePackageQualifiers Condition="'$(AppxBundleAutoResourcePackageQualifiers)' == ''">Language|Scale|DXFeatureLevel</AppxBundleAutoResourcePackageQualifiers>
    <AppxBundleSplitResourcesPriPath Condition="'$(AppxBundleSplitResourcesPriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxBundleSplitResourcesPriPath>
    <AppxBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxBundleSplitResourcesGeneratedFilesListPath>
    <AppxBundleSplitResourcesQualifiersPath Condition="'$(AppxBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxBundleSplitResourcesQualifiersPath>
    <AppxUploadBundleSplitResourcesPriPath Condition="'$(AppxUploadBundleSplitResourcesPriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxUploadBundleSplitResourcesPriPath>
    <AppxUploadBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxUploadBundleSplitResourcesGeneratedFilesListPath>
    <AppxUploadBundleSplitResourcesQualifiersPath Condition="'$(AppxUploadBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxUploadBundleSplitResourcesQualifiersPath>
    <AppxBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateOutputPath)filemap.priconfig.xml</AppxBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateUploadOutputPath)filemap.priconfig.xml</AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxBundleMainPackageFileMapIntermediatePrefix Condition="'$(AppxBundleMainPackageFileMapIntermediatePrefix)' == ''">filemap</AppxBundleMainPackageFileMapIntermediatePrefix>
    <AppxBundleMainPackageFileMapSuffix Condition="'$(AppxBundleMainPackageFileMapSuffix)' == ''">.map</AppxBundleMainPackageFileMapSuffix>
    <AppxBundleMainPackageFileMapIntermediatePath Condition="'$(AppxBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapIntermediatePath>
    <AppxBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxBundleMainPackageFileMapIntermediatePriPath>
    <AppxBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxBundleMainPackageFileMapPrefix Condition="'$(AppxBundleMainPackageFileMapPrefix)' == ''">main</AppxBundleMainPackageFileMapPrefix>
    <AppxBundleMainPackageFileMapPath Condition="'$(AppxBundleMainPackageFileMapPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapPath>
    <AppxUploadBundleMainPackageFileMapIntermediatePath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapIntermediatePath>
    <AppxUploadBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxUploadBundleMainPackageFileMapIntermediatePriPath>
    <AppxUploadBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxUploadBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxUploadBundleMainPackageFileMapPath Condition="'$(AppxUploadBundleMainPackageFileMapPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapPath>
    <AppxBundleFolderSuffix Condition="'$(AppxBundleFolderSuffix)' == ''">_Bundle</AppxBundleFolderSuffix>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificBundleArtifactsListDir Condition="!HasTrailingSlash('$(PlatformSpecificBundleArtifactsListDir)')">$(PlatformSpecificBundleArtifactsListDir)\</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificUploadBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    <UapDefaultAssetScale Condition="'$(UapDefaultAssetScale)' == ''">200</UapDefaultAssetScale>
  </PropertyGroup>
  <PropertyGroup>
    <AppxDefaultResourceQualifiers_Windows_80>Language={DefaultResourceLanguage}</AppxDefaultResourceQualifiers_Windows_80>
    <AppxDefaultResourceQualifiers_Windows_81>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_81>
    <AppxDefaultResourceQualifiers_Windows_Phone>Language={DefaultResourceLanguage}|Contrast=standard|Scale=240|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Theme=Dark|AlternateForm=</AppxDefaultResourceQualifiers_Windows_Phone>
    <AppxDefaultResourceQualifiers_Windows_82>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_82>
    <AppxDefaultResourceQualifiers_UAP>Language={DefaultResourceLanguage}|Contrast=standard|Scale=$(UapDefaultAssetScale)|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=|Platform=UAP</AppxDefaultResourceQualifiers_UAP>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">$(AppxDefaultResourceQualifiers_Windows_80)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.1'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.2'">$(AppxDefaultResourceQualifiers_Windows_82)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Portable'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(SDKIdentifier)' != ''">$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">$(AppxDefaultResourceQualifiers_Windows_Phone)</AppxDefaultResourceQualifiers>
  </PropertyGroup>
  <!-- If value is still not set, it is a platform yet unknown to us. -->
  <!-- Default to same value as for latest version of Windows.        -->
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers>$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
  </PropertyGroup>
  <ItemGroup>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha256">
      <Id>SHA256</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha384">
      <Id>SHA384</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha512">
      <Id>SHA512</Id>
    </AppxHashUri>
  </ItemGroup>
  <PropertyGroup>
    <StandardBuildPipeline>1.0</StandardBuildPipeline>
    <UapBuildPipeline>2.0</UapBuildPipeline>
    <AppxPackagePipelineVersion>$(StandardBuildPipeline)</AppxPackagePipelineVersion>
    <AppxPackagePipelineVersion Condition="'$(SDKIdentifier)' != ''">$(UapBuildPipeline)</AppxPackagePipelineVersion>
  </PropertyGroup>
  <!-- Combined checks to see if we should run the store-publishing steps added for the UAP flow. -->
  <PropertyGroup>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == '' and&#xD;&#xA;                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and&#xD;&#xA;                                             '$(UseDotNetNativeToolchain)' == 'true' and&#xD;&#xA;                                             '$(AppxPackageIsForStore)' == 'true'">true</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == ''">false</BuildAppxUploadPackageForUap>
  </PropertyGroup>
  <!-- Calculate whether to allow debug framework references in app manifest.    -->
  <!-- Allow overriding this from command line or user config file if necessary. -->
  <PropertyGroup Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">
    <!-- If inside Visual Studio, if not packaging for store, allow debug framework references. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(BuildingInsideVisualStudio)' == 'true'&#xD;&#xA;                                                                   and '$(AppxPackageIsForStore)' != 'true'">true</AppxPackageAllowDebugFrameworkReferencesInManifest>
    <!-- On command line, if building with Debug SDK configuration, allow debug framework references. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(BuildingInsideVisualStudio)' != 'true'&#xD;&#xA;                                                                   and '$(TargetedSDKConfiguration)' == 'Debug'">true</AppxPackageAllowDebugFrameworkReferencesInManifest>
    <!-- All other cases, do not allow debug framework references. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">false</AppxPackageAllowDebugFrameworkReferencesInManifest>
  </PropertyGroup>
  <!--
        When building on the command line or in TFS (determined by looking at the $(BuildingInsideVisualStudio) property), if build is invoked on an
        app package-producing project, the package for the project will be produced as part of building the project without specifying any additional
        flags or targets. This is control by an MSBuild property named GenerateAppxPackageOnBuild which is set to true by default.
    
        If $(BuildingInsideVisualStudio) = false and $(GenerateAppxPackageOnBuild) = true, then build will also produce a package.
    -->
  <PropertyGroup>
    <GenerateAppxPackageOnBuild Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</GenerateAppxPackageOnBuild>
  </PropertyGroup>
  <!-- Names of the files which are allways present on the machine and should not be part of the payload. -->
  <ItemGroup>
    <AppxSystemBinary Include="CLRHost.dll" />
    <AppxSystemBinary Include="CLRHost.exe" />
    <AppxSystemBinary Include="WWAHost.exe" />
  </ItemGroup>
  <!-- Reserved file names which cannot appear in the package. -->
  <ItemGroup>
    <AppxReservedFileName Include="AppxManifest.xml" />
    <AppxReservedFileName Include="AppxBlockMap.xml" />
    <AppxReservedFileName Include="[Content_Types].xml" />
    <AppxReservedFileName Include="AppxSignature.p7x" />
    <AppxReservedFileName Include="Microsoft.System.Package.Metadata" />
  </ItemGroup>
  <!-- XPath queries used to extract file names from the manifest. -->
  <ItemGroup>
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:InProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:OutOfProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:ProxyStub/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:GameExplorer/@GameDefinitionContainer" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:Certificates/m:Certificate/@Content" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/@Executable" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/m:Extensions/m:Extension/@Executable" />
  </ItemGroup>
  <!-- XPath queries used to extract image file names from the manifest. -->
  <ItemGroup>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Properties/m:Logo">
      <DescriptionID>StoreLogo</DescriptionID>
      <ExpectedScaleDimensions>100:50x50;140:70x70;180:90x90;240:120x120</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/@Logo">
      <DescriptionID>TileLogo</DescriptionID>
      <ExpectedScaleDimensions>80:120x120;100:150x150;140:210x210;180:270x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/@SmallLogo">
      <DescriptionID>SmallLogo</DescriptionID>
      <ExpectedScaleDimensions>80:24x24;100:30x30;140:42x42;180:54x54</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;32;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:DefaultTile/@WideLogo">
      <DescriptionID>WideLogo</DescriptionID>
      <ExpectedScaleDimensions>80:248x120;100:310x150;140:434x210;180:558x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;180:43x43</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:620x300;140:868x420;180:1116x540</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>
  <ItemGroup Condition="'$(TargetPlatformVersion)' != '8.0' or '$(SDKIdentifier)' != ''">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/@Square30x30Logo">
      <DescriptionID>Square30x30Logo</DescriptionID>
      <ExpectedScaleDimensions>80:24x24;100:30x30;140:42x42;180:54x54</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;32;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>80:120x120;100:150x150;140:210x210;180:270x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>80:248x120;100:310x150;140:434x210;180:558x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>80:248x248;100:310x310;140:434x434;180:558x558</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Square70x70Logo">
      <DescriptionID>Square70x70Logo</DescriptionID>
      <ExpectedScaleDimensions>80:56x56;100:70x70;140:98x98;180:126x126</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;180:43x43</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:620x300;140:868x420;180:1116x540</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>
  <ItemGroup Condition="'$(TargetPlatformIdentifier)' != 'Windows' and '$(SDKIdentifier)' == ''">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>100:310x150;140:434x210;240:744x360</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>100:310x310;140:434x434;240:744x744</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Square71x71Logo">
      <DescriptionID>Square71x71Logo</DescriptionID>
      <ExpectedScaleDimensions>100:71x71;140:99x99;240:170x170</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/@Square44x44Logo">
      <DescriptionID>Square44x44Logo</DescriptionID>
      <ExpectedScaleDimensions>100:44x44;140:62x62;240:106x106</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>100:150x150;140:210x210;240:360x360</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:480x800;140:672x1120;240:1152x1920</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;240:58x58</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>
  <!-- The reverse map needs to be added only in appx bundles and only on F5. -->
  <PropertyGroup Condition="'$(InsertReverseMap)' == ''">
    <InsertReverseMap Condition="'$(AppxBundle)' == 'Always' or '$(AppxBundle)' == 'Auto'">true</InsertReverseMap>
    <InsertReverseMap Condition="'$(InsertReverseMap)' == '' or '$(GenerateAppxPackageOnBuild)' == 'true' or '$(OutputType)' != 'WindowsWebApplication'">false</InsertReverseMap>
  </PropertyGroup>
  <PropertyGroup>
    <_ProjectPriFullPathOriginal>$(ProjectPriFullPath)</_ProjectPriFullPathOriginal>
  </PropertyGroup>
  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true'">
    <_ReverseMapProjectPriDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriFullPath)'))\ReverseMap\</_ReverseMapProjectPriDirectory>
    <_ReverseMapProjectPriFileName>$([System.IO.Path]::GetFileName('$(ProjectPriFullPath)'))</_ReverseMapProjectPriFileName>
    <ProjectPriFullPath>$(_ReverseMapProjectPriDirectory)$(_ReverseMapProjectPriFileName)</ProjectPriFullPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <_ReverseMapProjectPriUploadDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriUploadFullPath)'))\ReverseMap\</_ReverseMapProjectPriUploadDirectory>
    <_ReverseMapProjectPriUploadFileName>$([System.IO.Path]::GetFileName('$(ProjectPriUploadFullPath)'))</_ReverseMapProjectPriUploadFileName>
    <ProjectPriUploadFullPath>$(_ReverseMapProjectPriUploadDirectory)$(_ReverseMapProjectPriUploadFileName)</ProjectPriUploadFullPath>
  </PropertyGroup>
  <!-- This property is used to trigger a perf optimization in the CreatePriFilesForPortableLibraries task. -->
  <!-- When true we will skip generating an intermediate pri file in certain cases and instead just specify -->
  <!-- the resource file when generating the project's final pri file.                                      -->
  <PropertyGroup Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</SkipIntermediatePriGenerationForResourceFiles>
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">false</SkipIntermediatePriGenerationForResourceFiles>
  </PropertyGroup>
  <!-- Manifest metadata items. -->
  <!-- Those will be transformed into Name/Value or Name/Version pairs as follows:                         -->
  <!--                                                                                                     -->
  <!-- If identity of the item (attribute 'Include') points to existing file and there is                  -->
  <!-- no supplied value or version, file version of given file will be extracted and stored               -->
  <!-- as Version attribute of metadata with name equal to file name and extension.                        -->
  <!--                                                                                                     -->
  <!-- If item has metadata 'Value', then it is directly stored in the manifest as name/value pair.        -->
  <!-- If item has metadata 'Version', then it is directly stored in the manifest as name/version pair.    -->
  <!--                                                                                                     -->
  <!-- If metadata 'Name' is supplied, it will be used instead of identity of the item. This is useful     -->
  <!-- if we use binary to extract file version, but want to give it different name in generated manifest. -->
  <ItemGroup Label="AppxManifestMetadata">
    <AppxManifestMetaData Include="SharedGUID" Condition="'$(SharedGUID)' != ''">
      <Value>$(SharedGUID)</Value>
    </AppxManifestMetaData>
    <AppxManifestMetaData Include="CodeSharingProject" Condition=" '$(HasSharedItems)' == 'true' or '$(CodeSharingProject)' != '' ">
      <Value Condition=" '$(CodeSharingProject)' != '' ">$(CodeSharingProject)</Value>
      <Value Condition=" '$(CodeSharingProject)' == '' ">248F659F-DAC5-46E8-AC09-60EC9FC95053</Value>
    </AppxManifestMetaData>
    <AppxManifestMetadata Include="TargetFrameworkMoniker" Condition="'$(TargetFrameworkMoniker)' != ''">
      <Value>$(TargetFrameworkMoniker)</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="VisualStudio">
      <Version>$(VisualStudioVersion)</Version>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="VisualStudioEdition" Condition="'$(VisualStudioEdition)' != ''">
      <Value>$(VisualStudioEdition)</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="$(ComSpec)">
      <Name>OperatingSystem</Name>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll" />
    <AppxManifestMetaData Include="ProjectGUID" Condition="'$(ProjectGUID)' != ''">
      <Value>$(ProjectGUID)</Value>
    </AppxManifestMetaData>
  </ItemGroup>
  <!--<Import Project="$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props" Condition="EXISTS( '$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props' )" />-->
  <!-- Mapping between OS version (6.*) and marketing version string. -->
  <!-- There is no guarantee that NTVersion always consists of first two parts of OSVersion, hence a separate field. -->
  <ItemGroup>
    <PlatformVersionDescription Include="Windows 8.0">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.0</TargetPlatformVersion>
      <OSDescription>Windows 8.0</OSDescription>
      <OSVersion>6.2.1</OSVersion>
      <NTVersion>6.2</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.1">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows 8.1</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone 8.1">
      <TargetPlatformIdentifier>WindowsPhoneApp</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone Silverlight 8.1">
      <TargetPlatformIdentifier>Windows Phone</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.2">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.2</TargetPlatformVersion>
      <OSDescription>Windows 8.2</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="UAP 1.0">
      <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
      <TargetPlatformVersion>0.8.0.0</TargetPlatformVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
  </ItemGroup>
  <!-- Packaging output group default values -->
  <PropertyGroup>
    <IncludeBuiltProjectOutputGroup Condition="'$(IncludeBuiltProjectOutputGroup)' == ''">true</IncludeBuiltProjectOutputGroup>
    <IncludeDebugSymbolsProjectOutputGroup Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == ''">true</IncludeDebugSymbolsProjectOutputGroup>
    <IncludeDocumentationProjectOutputGroup Condition="'$(IncludeDocumentationProjectOutputGroup)' == ''">false</IncludeDocumentationProjectOutputGroup>
    <IncludeSatelliteDllsProjectOutputGroup Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == ''">false</IncludeSatelliteDllsProjectOutputGroup>
    <IncludeSourceFilesProjectOutputGroup Condition="'$(IncludeSourceFilesProjectOutputGroup)' == ''">false</IncludeSourceFilesProjectOutputGroup>
    <IncludeContentFilesProjectOutputGroup Condition="'$(IncludeContentFilesProjectOutputGroup)' == ''">true</IncludeContentFilesProjectOutputGroup>
    <IncludeSGenFilesOutputGroup Condition="'$(IncludeSGenFilesOutputGroup)' == ''">false</IncludeSGenFilesOutputGroup>
    <IncludeCopyLocalFilesOutputGroup Condition="'$(IncludeCopyLocalFilesOutputGroup)' == ''">true</IncludeCopyLocalFilesOutputGroup>
    <IncludeComFilesOutputGroup Condition="'$(IncludeComFilesOutputGroup)' == ''">false</IncludeComFilesOutputGroup>
    <IncludeCustomOutputGroupForPackaging Condition="'$(IncludeCustomOutputGroupForPackaging)' == ''">false</IncludeCustomOutputGroupForPackaging>
    <IncludeCopyWinmdArtifactsOutputGroup Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == ''">true</IncludeCopyWinmdArtifactsOutputGroup>
    <IncludeSDKRedistOutputGroup Condition="'$(IncludeSDKRedistOutputGroup)' == ''">true</IncludeSDKRedistOutputGroup>
    <IncludePriFilesOutputGroup Condition="'$(IncludePriFilesOutputGroup)' == ''">true</IncludePriFilesOutputGroup>
    <IncludeGetResolvedSDKReferences Condition="'$(IncludeGetResolvedSDKReferences)' == ''">true</IncludeGetResolvedSDKReferences>
    <IncludeProjectPriFile Condition="'$(IncludeProjectPriFile)' == ''">true</IncludeProjectPriFile>
  </PropertyGroup>
  <!-- Entry points for the project systems. -->
  <PropertyGroup Condition="'$(AppxPackage)' == 'true'">
    <CleanPackageAction>_CleanAppxPackage</CleanPackageAction>
    <PackageAction>_GenerateAppxPackage</PackageAction>
    <RebuildPackageAction>_RebuildAppxPackage</RebuildPackageAction>
  </PropertyGroup>
  <!-- Tie into rebuild sequence, to set flag if we are doing rebuilding. -->
  <Target Name="_BeforeBeforeRebuild" BeforeTargets="BeforeRebuild">
    <PropertyGroup>
      <_Rebuilding>true</_Rebuilding>
    </PropertyGroup>
  </Target>
  <!-- Alter behavior of task ResolveAssemblyReferences to error on architecture mismatch. -->
  <PropertyGroup>
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>Error</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
  </PropertyGroup>
  <!-- ============================================================================================ -->
  <!-- Overriding Publish target from Microsoft.Common.targets to tie into command-line publishing. -->
  <!-- ============================================================================================ -->
  <Target Name="Publish" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="Build;$(PackageAction)" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
        Actions happening during the build
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _GetAppxManifestSchemaItems;
      _GetSdkToolPaths;
      _GetPriConfigXmlSnippets;
      _ValidatePresenceOfAppxManifestItems;
      GetPackagingOutputs;
      _GetPackageProperties;
      _AddUnionWinmd;
      _GenerateProjectPriFile;
      _ComputeAppxPackagePayload;
      _GenerateAppxManifest;
      _ValidateStoreManifest;
      _GenerateAppxPackageRecipe;
      _GenerateAppxUploadPackageRecipe;
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn Condition=" '$(GenerateAppxPackageOnBuild)' == 'true'">
      $(PrepareForRunDependsOn);
      $(PackageAction)
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _AppendToReadTlogFile;
      _AppendToWriteTlogFile;
      _AppendToPackagingWriteLogs
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <!-- Calculates AppxManifestSchema items. -->
  <Target Name="_GetAppxManifestSchemaItems" Condition="'@(AppxManifestSchema)' == ''">
    <GetSdkPropertyValue Condition="'$(TargetPlatformIdentifier)' == 'Windows' or '$(SDKIdentifier)' != ''" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <GetSdkPropertyValue Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsPhoneSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' != '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(SDKIdentifier)' != '' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v3.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013_v2.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2014.xsd">
        <NamespaceAlias>m3</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxPhoneManifestSchema2014.xsd">
        <NamespaceAlias>mp</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/phone/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <_StoreManifestSchemaDir>$(_TargetPlatformSdkDir)\Include\WinRT\</_StoreManifestSchemaDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and !Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@14.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@14.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@14.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@14.0)</CURRENTVSINSTALLDIR>
      <_StoreManifestSchemaDir>$(CURRENTVSINSTALLDIR)Xml\Schemas\</_StoreManifestSchemaDir>
    </PropertyGroup>
    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <StoreManifestSchema Include="$(_StoreManifestSchemaDir)StoreManifest.xsd">
        <NamespaceAlias>store</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/StoreManifest</NamespaceUri>
      </StoreManifestSchema>
    </ItemGroup>
    <!--
            Define AppxValidateStoreManifest based on whether we ended up with any
            StoreManifestSchemas or not.  This keeps the logic agnostic about which
            TargetPlatform/Version supports validating the Store manifest.
        -->
    <PropertyGroup>
      <AppxValidateStoreManifest Condition="'$(AppxValidateStoreManifest)' == '' and '@(StoreManifestSchema)' != ''">true</AppxValidateStoreManifest>
    </PropertyGroup>
    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == '' and '$(SDKIdentifier)' != ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2012/build</MetadataNamespaceUri>
    </PropertyGroup>
  </Target>
  <!-- Finds SDK tool executables paths. -->
  <Target Name="_GetSdkToolPaths">
    <PropertyGroup>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' == ''">false</MSBuildExtensionsPath64Exists>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' != ''">true</MSBuildExtensionsPath64Exists>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(AppxGeneratePriEnabled)' == 'true' or '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'" FileName="MakePri.exe" FullFilePath="$(MakePriExeFullPath)" FileArchitecture="$(MakePriArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakePriExeFullPath" />
      <Output TaskParameter="ActualFileArchitecture" PropertyName="MakePriArchitecture" />
    </GetSdkFileFullPath>
    <Message Importance="low" Text="MakePriExeFullPath: $(MakePriExeFullPath)" />
    <Message Importance="low" Text="MakePriArchitecture: $(MakePriArchitecture)" />
    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true'" FileName="MakeAppx.exe" FullFilePath="$(MakeAppxExeFullPath)" FileArchitecture="$(MakeAppxArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakeAppxExeFullPath" />
    </GetSdkFileFullPath>
    <Message Importance="low" Text="MakeAppxExeFullPath: $(MakeAppxExeFullPath)" />
    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true'" FileName="signtool.exe" FullFilePath="$(SignAppxPackageExeFullPath)" FileArchitecture="$(SignToolArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="SignAppxPackageExeFullPath" />
    </GetSdkFileFullPath>
    <Message Importance="low" Text="SignAppxPackageExeFullPath: $(SignAppxPackageExeFullPath)" />
    <PropertyGroup Condition="'$(AppxPackagingArchitecture)' == ''">
      <AppxPackagingArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</AppxPackagingArchitecture>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''" FileName="Microsoft.Windows.Build.Appx.AppxPackaging.dll.manifest" FullFilePath="$(AppxPackagingComponentManifestPath)" FileArchitecture="$(AppxPackagingArchitecture)" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="AppxPackagingComponentManifestPath" />
    </GetSdkFileFullPath>
    <Message Importance="low" Text="AppxPackagingComponentManifestPath: $(AppxPackagingComponentManifestPath)" />
    <PropertyGroup Condition="'$(MrmSupportLibraryArchitecture)' == ''">
      <MrmSupportLibraryArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</MrmSupportLibraryArchitecture>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''" FileName="MrmSupport.dll" FullFilePath="$(MrmSupportLibraryPath)" FileArchitecture="$(MrmSupportLibraryArchitecture)" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MrmSupportLibraryPath" />
    </GetSdkFileFullPath>
    <Message Importance="low" Text="MrmSupportLibraryPath: $(MrmSupportLibraryPath)" />
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="MakePriExtensionPath" Condition="'$(MakePriExtensionPath)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath" />
    </GetSdkPropertyValue>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="MakePriExtensionPath_x64" Condition="'$(MakePriExtensionPath_x64)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath_x64" />
    </GetSdkPropertyValue>
    <!--Clear out MakePriExtensionPath for UAP projects since it should never be used.-->
    <PropertyGroup Condition="'$(SDKIdentifier)' != ''">
      <MakePriExtensionPath />
      <MakePriExtensionPath_x64 />
    </PropertyGroup>
    <Message Importance="low" Text="MakePriExtensionPath: $(MakePriExtensionPath)" />
    <Message Importance="low" Text="MakePriExtensionPath_x64: $(MakePriExtensionPath_x64)" />
    <PropertyGroup>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' != 'amd64'">$(MakePriExtensionPath)</OutOfProcessMakePriExtensionPath>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' == 'amd64'">$(MakePriExtensionPath_x64)</OutOfProcessMakePriExtensionPath>
    </PropertyGroup>
    <Message Importance="low" Text="OutOfProcessMakePriExtensionPath: $(OutOfProcessMakePriExtensionPath)" />
    <PropertyGroup>
      <InProcessMakePriExtensionPath Condition="!$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath)</InProcessMakePriExtensionPath>
      <InProcessMakePriExtensionPath Condition="$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath_x64)</InProcessMakePriExtensionPath>
    </PropertyGroup>
    <Message Importance="low" Text="InProcessMakePriExtensionPath: $(InProcessMakePriExtensionPath)" />
  </Target>
  <!-- Calculates paths to priconfig.xml snippets -->
  <Target Name="_GetPriConfigXmlSnippets">
    <ItemGroup Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''">
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.packaging.xml'" />
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.packaging.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition="'@(_AppxPriConfigXmlPackagingSnippetItem)' != ''">
      <AppxPriConfigXmlPackagingSnippetPath>%(_AppxPriConfigXmlPackagingSnippetItem.FullPath)</AppxPriConfigXmlPackagingSnippetPath>
    </PropertyGroup>
    <ItemGroup Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''">
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.default.xml'" />
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.default.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition="'@(_AppxPriConfigXmlDefaultSnippetItem)' != ''">
      <AppxPriConfigXmlDefaultSnippetPath>%(_AppxPriConfigXmlDefaultSnippetItem.FullPath)</AppxPriConfigXmlDefaultSnippetPath>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <ValidatePresenceOfAppxManifestItemsDependsOn>
      $(ValidatePresenceOfAppxManifestItemsDependsOn);
    </ValidatePresenceOfAppxManifestItemsDependsOn>
  </PropertyGroup>
  <!-- Finds out if there is a custom AppxManifest override item, -->
  <!-- validates that one and only one manifest exists,           -->
  <!-- extracts identity name and version out of the manifest,    -->
  <!-- defines ProjectPriIndexName,                               -->
  <!-- and defines SourceAppxManifest item.                       -->
  <Target Name="_ValidatePresenceOfAppxManifestItems" DependsOnTargets="$(ValidatePresenceOfAppxManifestItemsDependsOn)">
    <ItemGroup>
      <CustomAppxManifest Include="@(Content)" Condition="'%(Identity)' == 'AppxManifest.xml'" />
    </ItemGroup>
    <ValidateAppxManifestItems AppxPackageProject="$(AppxPackage)" AppxManifestItems="@(AppxManifest)" CustomAppxManifestItems="@(CustomAppxManifest)">
      <Output TaskParameter="IdentityName" PropertyName="AppxManifestIdentityName" />
      <Output TaskParameter="IdentityVersion" PropertyName="AppxManifestIdentityVersion" />
    </ValidateAppxManifestItems>
    <ItemGroup>
      <SourceAppxManifest Include="@(AppxManifest)" Condition="'@(AppxManifest)' != ''" />
      <SourceAppxManifest Include="@(CustomAppxManifest)" Condition="'@(CustomAppxManifest)' != ''" />
    </ItemGroup>
    <PropertyGroup Condition="'$(ProjectPriIndexName)' == ''">
      <ProjectPriIndexName Condition="'$(AppxPackage)' == 'true'">$(AppxManifestIdentityName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)</ProjectPriIndexName>
    </PropertyGroup>
    <PropertyGroup>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' == ''">false</_CustomAppxManifestUsed>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' != ''">true</_CustomAppxManifestUsed>
    </PropertyGroup>
  </Target>
  <!-- ============================ -->
  <!-- Generating project PRI file. -->
  <!-- ============================ -->
  <PropertyGroup>
    <_GenerateProjectPriFileDependsOn>
      $(_GenerateProjectPriFileDependsOn);
      BeforeGenerateProjectPriFile;
      _GeneratePrisForPortableLibraries;
      _GetPriFilesFromPayload;
      _ComputeInputPriFiles;
      _GenerateProjectPriConfigurationFiles;
      _CalculateInputsForGenerateProjectPriFileCore;
      _GenerateProjectPriFileCore;
      _AddFileReadsAndFileWritesForProjectPri;
      _CreateProjectPriFileItem;
      _ExpandProjectPriFile;
      _ExpandPriFiles;
      _ExpandPriUploadFiles;
      AfterGenerateProjectPriFile
    </_GenerateProjectPriFileDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <_SupportEmbedFileResources Condition="'$(_SupportEmbedFileResources)' =='' AND '$(TargetPlatformIdentifier)' == 'UAP'">true</_SupportEmbedFileResources>
    <_SupportXbfAsEmbedFileResources Condition="'$(DisableEmbeddedXbf)' == 'true'">false</_SupportXbfAsEmbedFileResources>
    <_SupportXbfAsEmbedFileResources Condition="'$(_SupportXbfAsEmbedFileResources)' == '' AND '$(_SupportEmbedFileResources)' == 'true'">true</_SupportXbfAsEmbedFileResources>
    <_PriConfigXmlPath>$(IntermediateOutputPath)priconfig.xml</_PriConfigXmlPath>
    <_LayoutResfilesPath>$(IntermediateOutputPath)layout.resfiles</_LayoutResfilesPath>
    <_ResourcesResfilesPath>$(IntermediateOutputPath)resources.resfiles</_ResourcesResfilesPath>
    <_PriResfilesPath>$(IntermediateOutputPath)pri.resfiles</_PriResfilesPath>
    <_EmbedFileResfilePath Condition="'$(_SupportEmbedFileResources)' == 'true'">$(IntermediateOutputPath)embed.resfiles</_EmbedFileResfilePath>
    <_QualifiersPath>$(IntermediateOutputPath)qualifiers.txt</_QualifiersPath>
    <_MultipleQualifiersPerDimensionFoundPath>$(IntermediateOutputPath)MultipleQualifiersPerDimensionFound.txt</_MultipleQualifiersPerDimensionFoundPath>
  </PropertyGroup>
  <Target Name="_GenerateProjectPriFile" Condition="'$(AppxGeneratePriEnabled)' == 'true'" DependsOnTargets="$(_GenerateProjectPriFileDependsOn)" />
  <!-- Override to specify actions to happen before generating project PRI file. -->
  <Target Name="BeforeGenerateProjectPriFile" />
  <!-- Generates a PRI file for all managed libraries that contain .resources files   -->
  <!-- in them (and their satellites).  This allows a .NET Portable Library to be     -->
  <!-- built with only .resources files, yet still be localized when compiled into    -->
  <!-- an AppX package where the ResourceManager uses the WinRT resource manager.     -->
  <Target Name="_GeneratePrisForPortableLibraries" Condition="'$(AppxPackage)' == 'true' and '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'">
    <!-- 
    Do not rename or delete the item groups _LibrariesUnfiltered and CreatedResWFiles

    In case of compiling Universal app, the item group _LibrariesUnfiltered will get initialized with the filtered list of 
    the app assemblies excluding the framework assemblies. 
    the initialization will occur in the target _GetLibrariesToGeneratePrisForUWPApps in the file Microsoft.Net.CoreRuntime.targets. 
    also _GetLibrariesToGeneratePrisForUWPApps will fill the initial list of CreatedResWFiles. 
    -->
    <ItemGroup Condition="'@(_LibrariesUnfiltered)' == '' and '@(CreatedResWFiles)' == ''">
      <_LibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_LibrariesUnfiltered)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_Libraries" />
    </RemovePayloadDuplicates>
    <GenerateResource SdkToolsPath="$(ResgenToolPath)" ExtractResWFiles="true" Sources="@(_Libraries)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache" OutputDirectory="$(IntermediateOutputPath)" ExecuteAsTool="false" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="ExtractedFileWrites" />
      <Output TaskParameter="OutputResources" ItemName="CreatedResWFiles" />
    </GenerateResource>
    <ItemGroup>
      <FileWrites Include="@(ExtractedFileWrites)" />
    </ItemGroup>
    <Message Importance="low" Text="Created resource files: @(CreatedResWFiles)" />
    <!-- Now generate a PRI file for each set of ResW files (ie, a main assembly + all satellites). -->
    <!-- Note: The task relies on some metadata set on each ITaskItem, set by GenerateResource.  -->
    <CreatePriFilesForPortableLibraries MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" ContentToIndex="@(CreatedResWFiles)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxCreatePriFilesForPortableLibrariesAdditionalMakepriExeParameters)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" SkipIntermediatePriGenerationForResourceFiles="$(SkipIntermediatePriGenerationForResourceFiles)">
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
      <Output TaskParameter="CreatedPriFiles" ItemName="_PortableLibraryCreatedPriFiles" />
      <Output TaskParameter="UnprocessedReswFiles" ItemName="_UnprocessedReswFiles" />
    </CreatePriFilesForPortableLibraries>
    <Message Importance="low" Text="Created PRI files: @(_PortableLibraryCreatedPriFiles)" />
    <!-- Add all resw files we didn't generate a pri file for to the PRIResource group so they get included during         -->
    <!-- final pri generation.  This group will always be empty if SkipIntermediatePriGenerationForResourceFiles is false. -->
    <ItemGroup>
      <PRIResource Include="@(_UnprocessedReswFiles)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>
  </Target>
  <!-- Get list of PRI files from the payload. -->
  <Target Name="_GetPriFilesFromPayload" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.pri' &#xD;&#xA;                                            and '%(ProjectName)' != '$(ProjectName)'" />
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.pri' &#xD;&#xA;                                            and '%(ProjectName)' == '$(ProjectName)' &#xD;&#xA;                                            and '%(OutputGroup)' != 'ProjectPriFile'" />
    </ItemGroup>
    <RemoveDuplicatePriFiles Inputs="@(_PriFilesFromPayloadRaw)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_PriFilesFromPayload" />
    </RemoveDuplicatePriFiles>
  </Target>
  <!-- Compute final list of input PRI files. -->
  <Target Name="_ComputeInputPriFiles" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <_PriFile Include="@(_PriFilesFromPayload)" />
      <_PriFile Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>
  </Target>
  <!-- Generates configuration files for makepri.exe. -->
  <Target Name="_GenerateProjectPriConfigurationFiles" Inputs="$(MSBuildAllProjects);@(_PriFile);$(AppxPriConfigXmlDefaultSnippetPath);@(PackagingOutputs)" Outputs="$(_PriConfigXmlPath);$(_LayoutResfilesPath);$(_ResourcesResfilesPath);$(_PriResfilesPath)">
    <ItemGroup>
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_EmbedFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'EmbedOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_EmbedFileCopy Include="@(_EmbedFile->'$(IntermediateOutputPath)%(TargetPath)')" />
    </ItemGroup>
    <GeneratePriConfigurationFiles LayoutResfilesPath="$(_LayoutResfilesPath)" ResourcesResfilesPath="$(_ResourcesResfilesPath)" PriResfilesPath="$(_PriResfilesPath)" EmbedFileResfilePath="$(_EmbedFileResfilePath)" LayoutFiles="@(_LayoutFile)" PRIResourceFiles="@(PRIResource)" PriFiles="@(_PriFile)" EmbedFiles="@(_EmbedFile)" IntermediateExtension="$(AppxIntermediateExtension)" />
    <CreatePriConfigXmlForFullIndex PriConfigXmlPath="$(_PriConfigXmlPath)" LayoutResfilesPath="$(_LayoutResfilesPath)" ResourcesResfilesPath="$(_ResourcesResfilesPath)" PriResfilesPath="$(_PriResfilesPath)" EmbedFileResfilePath="$(_EmbedFileResfilePath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" />
    <!-- Copy Embed files to location expected by embed indexer-->
    <Copy SourceFiles="@(_EmbedFile)" DestinationFiles="@(_EmbedFileCopy)" SkipUnchangedFiles="true" />
    <Message Text="$(MSBuildProjectName) -&gt; $(_PriConfigXmlPath)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(_LayoutResfilesPath)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(_ResourcesResfilesPath)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(_PriResfilesPath)" />
    <Message Condition="'$(_SupportEmbedFileResources)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(_EmbedFileResfilePath)" />
  </Target>
  <Target Name="_SuppressDeploymentOnlyFeatures">
    <!-- Disable adding the reverse map to the PRI file. This is necessary when building from the packaging wizard. -->
    <PropertyGroup>
      <InsertReverseMap>false</InsertReverseMap>
      <ProjectPriFullPath>$(_ProjectPriFullPathOriginal)</ProjectPriFullPath>
    </PropertyGroup>
  </Target>
  <!-- Calculate inputs for _GenerateProjectPriFileCore. -->
  <Target Name="_CalculateInputsForGenerateProjectPriFileCore">
    <ItemGroup>
      <_GenerateProjectPriFileCoreInput Include="$(_PriConfigXmlPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_LayoutResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_ResourcesResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_PriResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="@(PRIResource)" />
      <_GenerateProjectPriFileCoreInput Include="@(_PriFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(SourceAppxManifest)" />
      <_GenerateProjectPriFileCoreInput Include="$(_EmbedFileResfilePath)" />
      <_GenerateProjectPriFileCoreInput Include="@(_EmbedFile)" />
    </ItemGroup>
  </Target>
  <!-- Generates intermediate PRI file for the current project. -->
  <Target Name="_GenerateProjectPriFileCore" Inputs="$(MSBuildAllProjects);@(_GenerateProjectPriFileCoreInput)" Outputs="$(ProjectPriFullPath)">
    <MakeDir Condition="'$(InsertReverseMap)' == 'true'" Directories="$(_ReverseMapProjectPriDirectory)" />
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(_PriConfigXmlPath)" IndexFilesForQualifiersCollection="$(_LayoutResfilesPath);$(_ResourcesResfilesPath)" ProjectPriIndexName="$(ProjectPriIndexName)" InsertReverseMap="$(InsertReverseMap)" ProjectDirectory="$(ProjectDir)" OutputFileName="$(ProjectPriFullPath)" QualifiersPath="$(_QualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" MultipleQualifiersPerDimensionFoundPath="$(_MultipleQualifiersPerDimensionFoundPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(ProjectPriFileName)" />
  </Target>
  <!-- Add FileReads and FileWrites done during generation of project PRI file. -->
  <Target Name="_AddFileReadsAndFileWritesForProjectPri">
    <ItemGroup>
      <FileReads Include="@(_GenerateProjectPriFileCoreInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(_PriConfigXmlPath)" />
      <FileWrites Include="$(_PriConfigXmlPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_LayoutResfilesPath)" />
      <FileWrites Include="$(_LayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ResourcesResfilesPath)" />
      <FileWrites Include="$(_ResourcesResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_PriResfilesPath)" />
      <FileWrites Include="$(_PriResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(ProjectPriFullPath)" />
      <FileWrites Include="$(_QualifiersPath)" />
      <FileWrites Include="$(_QualifiersPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_MultipleQualifiersPerDimensionFoundPath)" />
    </ItemGroup>
  </Target>
  <!--Create ProjectPriFile item. -->
  <Target Name="_CreateProjectPriFileItem" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <ProjectPriFile Remove="@(ProjectPriFile)" />
      <ProjectPriFile Include="$(ProjectPriFullPath)">
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <OsVersion>$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)</OsVersion>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi Condition="'$(OsVersion)' &lt; '6.3'">false</AppxUseResourceIndexerApi>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi>true</AppxUseResourceIndexerApi>
    </PropertyGroup>
    <Message Importance="low" Text="AppxUseResourceIndexerApi=$(AppxUseResourceIndexerApi)" />
  </Target>
  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandProjectPriFile" Condition="'$(AppxPackage)' == 'true' and '$(AppxUseResourceIndexerApi)' == 'false'">
    <ExpandPriContent Inputs="@(ProjectPriFile)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)">
      <Output TaskParameter="Expanded" ItemName="IndexedPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandMainPriFile">
    <ExpandPriContent Inputs="$(AppxBundleSplitResourcesPriPath)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)">
      <Output TaskParameter="Expanded" ItemName="IndexedMainPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriFiles">
    <ItemGroup>
      <_PriFilesToExpand Include="@(_PriFilesFromPayload)" Condition="'%(OutputGroup)' != 'ProjectPriFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'" />
    </ItemGroup>
    <ExpandPriContent Inputs="@(_PriFilesToExpand)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)">
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriUploadFiles" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_PriUploadFilesToExpand Include="@(_PriFilesFromPayload)" Condition="'%(OutputGroup)' != 'ProjectPriUploadFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'ProjectPriFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'" />
    </ItemGroup>
    <ExpandPriContent Inputs="@(_PriUploadFilesToExpand)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)">
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriUploadPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Override to specify actions to happen after generating project PRI file. -->
  <Target Name="AfterGenerateProjectPriFile" />
  <PropertyGroup>
    <_ProjectArchitecturesFilePath>$(IntermediateOutputPath)ProjectArchitectures.txt</_ProjectArchitecturesFilePath>
  </PropertyGroup>
  <!-- Add Union winmd to payload if Appx contains managed component to make JITer happy -->
  <Target Name="_AddUnionWinmd" Condition="'$(AppxPackage)' == 'true' AND '$(TargetPlatformIdentifier)' == 'UAP'">
    <ItemGroup>
      <_PackagingOutputWinmd Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'" />
    </ItemGroup>
    <GetUnionWinmdPropertyValues TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" WinmdFiles="@(_PackagingOutputWinmd)">
      <Output TaskParameter="UnionWinmdRequired" PropertyName="_UnionWinmdRequired" />
    </GetUnionWinmdPropertyValues>
    <ItemGroup>
      <UnionWinmdPath Include="$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd" />
      <UnionMetadataWinmd Include="@(UnionWinmdPath)" Condition="Exists(@(UnionWinmdPath)) AND &#xD;&#xA;                              ('IncludeWindowsSdkWinmd' == 'true' OR '$(_UnionWinmdRequired)' == 'true')">
        <ResolvedFrom>GetSDKReferenceFiles</ResolvedFrom>
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>WinMetadata\Windows.winmd</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </UnionMetadataWinmd>
      <PackagingOutputs Include="@(UnionMetadataWinmd)" />
    </ItemGroup>
    <Message Condition="'$(_UnionWinmdRequired)' == 'true'" Text="$(MSBuildProjectName) -&gt; @(UnionWinmdPath)" />
  </Target>
  <!-- ================================================================================================== -->
  <!-- Computes Appx package payload that will be included in the appx package (excluding Appx manifest). -->
  <!-- ================================================================================================== -->
  <Target Name="_ComputeAppxPackagePayload" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <_UnfilteredAppxPackagePayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND '%(OutputGroup)' != 'GetResolvedSDKReferences' AND '%(OutputGroup)' != '_GetProjectArchitecture' AND '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'" />
      <_UnfilteredAppxPackagePayload Include="@(_ExpandedPriPayload)" />
      <_UnfilteredAppxPackagePayload Include="@(ProjectPriFile)" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_UnfilteredAppxPackageUploadPayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND '%(OutputGroup)' != 'GetResolvedSDKReferences' AND '%(OutputGroup)' != '_GetProjectArchitecture' AND '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'" />
      <_UnfilteredAppxPackageUploadPayload Include="@(_ExpandedPriUploadPayload)" />
      <_UnfilteredAppxPackageUploadPayload Include="@(ProjectPriUploadFile)" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_UnfilteredAppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="AppxPackagePayload" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="@(_UnfilteredAppxPackageUploadPayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="AppxPackageUploadPayload" />
    </RemovePayloadDuplicates>
    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or&#xD;&#xA;                          '$(BuildAppxUploadPackageForUap)' != 'true'">
      <PDBPayload Include="@(AppxPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <PDBPayload Include="@(AppxPackageUploadPayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>
    <!-- 
        If packaging outputs contain file named AppxManifest.xml, 
        this is override manifest and it is handled elsewhere.
        -->
    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'AppxManifest.xml'" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxPackageUploadPayload Remove="@(AppxPackageUploadPayload)" Condition="'%(TargetPath)' == 'AppxManifest.xml'" />
    </ItemGroup>
    <ItemGroup>
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'&#xD;&#xA;                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' != ''" />
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'&#xD;&#xA;                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' == ''">
        <MSBuildSourceProjectFile>$(MSBuildProjectFullPath)</MSBuildSourceProjectFile>
      </_ProjectArchitectureFromPayload>
    </ItemGroup>
    <GenerateProjectArchitecturesFile ProjectArchitectures="@(_ProjectArchitectureFromPayload)" ProjectArchitecturesFilePath="$(_ProjectArchitecturesFilePath)" />
    <ItemGroup>
      <FileWrites Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
  </Target>
  <!-- ==================================================================================== -->
  <!-- Generating Appx manifest.                                                            -->
  <!-- Happens after generating PRI file, for every project which can be packaged/deployed. -->
  <!-- ==================================================================================== -->
  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>
      $(_GenerateAppxManifestDependsOn);
      BeforeGenerateAppxManifest;
      _GetRecursiveResolvedSDKReferences;
      _CopyCurrentProjectAppxManifestOverride;
      _CopyCurrentProjectAppxUploadManifestOverride;
      _CalculateInputsForGenerateCurrentProjectAppxManifest;
      _GenerateCurrentProjectAppxManifest;
      _CreateFinalAppxManifestItem;
      _FindStoreAssociationFile;
      _ValidateAppxManifest;
      AfterGenerateAppxManifest
    </_GenerateAppxManifestDependsOn>
  </PropertyGroup>
  <Target Name="_GenerateAppxManifest" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(_GenerateAppxManifestDependsOn)" />
  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxManifest" />
  <!-- Extract SDK references from the payload and filters out duplicates. -->
  <Target Name="_GetRecursiveResolvedSDKReferences">
    <ItemGroup>
      <_UnfilteredRecursiveResolvedSDKReference Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'GetResolvedSDKReferences'" />
    </ItemGroup>
    <RemoveDuplicateSDKReferences Inputs="@(_UnfilteredRecursiveResolvedSDKReference)">
      <Output TaskParameter="Filtered" ItemName="RecursiveResolvedSDKReference" />
    </RemoveDuplicateSDKReferences>
    <ItemGroup>
      <FrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' != ''" />
    </ItemGroup>
    <ItemGroup>
      <NonFrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' == ''" />
    </ItemGroup>
    <!-- Add non-framework SDK versions to manifest build metadata. -->
    <ItemGroup>
      <AppxManifestMetadata Include="@(NonFrameworkSdkReference)">
        <Name>%(NonFrameworkSdkReference.SimpleName)</Name>
        <Version>%(NonFrameworkSdkReference.Version)</Version>
      </AppxManifestMetadata>
    </ItemGroup>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(FrameworkSdkReference)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkSdkPackage" />
    </GetFrameworkSdkPackages>
  </Target>
  <!-- Copy overriden AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxManifestOverride" Condition="Exists(@(CustomAppxManifest))" Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)" Outputs="$(FinalAppxManifestName)">
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(CustomAppxManifest)" DestinationFiles="$(FinalAppxManifestName)" />
  </Target>
  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxUploadManifestOverride" Condition="Exists(@(CustomAppxManifest)) and '$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)" Outputs="$(FinalAppxUploadManifestName)">
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(CustomAppxManifest)" DestinationFiles="$(FinalAppxUploadManifestName)" />
  </Target>
  <!-- Calculates list of input for _GenerateCurrentProjectAppxManifest target. -->
  <Target Name="_CalculateInputsForGenerateCurrentProjectAppxManifest">
    <ItemGroup Condition="'$(AppxHarvestWinmdRegistration)' == 'true'">
      <_WinmdFilesFromWinmdArtifacts Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd' &#xD;&#xA;                                            and '%(PackagingOutputs.OutputGroup)' == 'CopyWinmdArtifactsOutputGroup'&#xD;&#xA;                                            and '%(PackagingOutputs.ProjectName)' != '$(ProjectName)'&#xD;&#xA;                                            and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromReferences Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd' &#xD;&#xA;                                        and '%(PackagingOutputs.OutputGroup)' == 'CopyLocalFilesOutputGroup'&#xD;&#xA;                                        and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromOtherGroups Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd' &#xD;&#xA;                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyWinmdArtifactsOutputGroup'&#xD;&#xA;                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyLocalFilesOutputGroup'&#xD;&#xA;                                         and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'&#xD;&#xA;                                         and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromSDKs Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                  and '%(PackagingOutputs.ResolvedFrom)' == 'GetSDKReferenceFiles'&#xD;&#xA;                                  and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromWinmdArtifacts)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromReferences)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromOtherGroups)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromSDKs)" ProjectName="$(ProjectName)" Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxSDKWinmdFilesForHarvest" />
    </RemovePayloadDuplicates>
    <ItemGroup>
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifestSchema)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(PackageCertificateKeyFile)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxWinmdFilesToHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxSDKWinmdFilesForHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(_QualifiersPath)" />
    </ItemGroup>
  </Target>
  <!-- Generates a final AppxManifest.xml that will be included in the appx package. -->
  <!-- The generation includes pre-processing of any tokens in the input manifest file to produce a valid appx manifest file. -->
  <!-- Input: [AppxManifest] Name of the manifest file template. -->
  <!-- Output: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_GenerateCurrentProjectAppxManifest" Condition="Exists(@(AppxManifest))" Inputs="$(MSBuildAllProjects);@(_GenerateCurrentProjectAppxManifestInput)" Outputs="$(FinalAppxManifestName)">
    <ItemGroup>
      <AppxManifestMetadata Include="$(MakePriExeFullPath)" />
    </ItemGroup>
    <GenerateAppxManifest AppxManifestInput="@(AppxManifest)" AppxManifestOutput="$(FinalAppxManifestName)" ApplicationExecutableName="$(TargetName)" FrameworkSdkReferences="@(FrameworkSdkReference)" NonFrameworkSdkReferences="@(NonFrameworkSdkReference)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" DefaultResourceLanguage="$(DefaultResourceLanguage)" QualifiersPath="$(_QualifiersPath)" PackageArchitecture="$(PackageArchitecture)" SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)" WinmdFiles="@(_AppxWinmdFilesToHarvest)" ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)" OSMinVersion="$(AppxOSMinVersion)" OSMaxVersionTested="$(AppxOSMaxVersionTested)" OSMinVersionReplaceManifestVersion="$(AppxOSMinVersionReplaceManifestVersion)" OSMaxVersionTestedReplaceManifestVersion="$(AppxOSMaxVersionTestedReplaceManifestVersion)" PackageSigningEnabled="$(AppxPackageSigningEnabled)" EnableSigningChecks="$(EnableSigningChecks)" ManifestMetadata="@(AppxManifestMetadata)" MetadataNamespaceUri="$(MetadataNamespaceUri)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" />
    <Message Importance="low" Text="@(AppxManifest) -&gt; $(FinalAppxManifestName)" />
  </Target>
  <!-- In order for incremental build and clean to work correctly,       -->
  <!-- we are creating build item @(FinalAppxManifest) and @(FileWrites) -->
  <!-- in the target which always executes.                              -->
  <Target Name="_CreateFinalAppxManifestItem">
    <ItemGroup>
      <FinalAppxManifest Include="$(FinalAppxManifestName)" />
    </ItemGroup>
    <ItemGroup>
      <FileReads Include="@(CustomAppxManifest)" />
      <FileReads Include="@(_GenerateCurrentProjectAppxManifestInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(FinalAppxManifest)" />
    </ItemGroup>
  </Target>
  <!-- Finds store association file. -->
  <Target Name="_FindStoreAssociationFile">
    <ItemGroup Condition="'@(StoreAssociationFile)' == ''">
      <StoreAssociationFile Include="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
      <None Remove="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
    </ItemGroup>
  </Target>
  <!-- Validates final Appx manifest. -->
  <Target Name="_ValidateAppxManifest">
    <ValidateAppxManifest Input="@(FinalAppxManifest)" SourceAppxManifest="@(SourceAppxManifest)" AppxManifestSchema="@(AppxManifestSchema)" StoreAssociationFile="@(StoreAssociationFile)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" OSMinVersion="$(AppxOSMinVersion)" OSMaxVersionTested="$(AppxOSMaxVersionTested)" PlatformVersionDescriptions="@(PlatformVersionDescription)" ResolvedSDKReferences="@(RecursiveResolvedSDKReference)" ValidateWinmds="$(_CustomAppxManifestUsed)" StrictManifestValidationEnabled="$(AppxStrictManifestValidationEnabled)" WinmdFiles="@(_AppxWinmdFilesToHarvest)" SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)" NonFrameworkSdkReferences="@(NonFrameworkSdkReference)" ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)" ValidateManifest="$(AppxValidateAppxManifest)" AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)" FrameworkSdkPackages="@(FrameworkSdkPackage)">
      <Output TaskParameter="Resources" ItemName="_ManifestResources" />
    </ValidateAppxManifest>
  </Target>
  <!-- Override to specify actions to happen after generating Appx manifest. -->
  <Target Name="AfterGenerateAppxManifest" />
  <!-- Validates Store manifest if it exists. -->
  <Target Name="_ValidateStoreManifest" Condition="'$(AppxValidateStoreManifest)' == 'true' and Exists($(StoreManifestName))">
    <ValidateStoreManifest Input="$(StoreManifestName)" StoreManifestSchema="@(StoreManifestSchema)" />
  </Target>
  <!-- ========================================================================================= -->
  <!-- Generating Appx package recipe.                                                           -->
  <!-- Happens after generating Appx manifest, for every project which can be packaged/deployed. -->
  <!-- ========================================================================================= -->
  <!-- Ensure Fast UpToDate check also consider the .appxrecipe file as an output -->
  <ItemGroup Condition="'$(AppxPackage)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxPackageRecipe)" />
  </ItemGroup>
  <ItemGroup Condition="'$(AppxPackage)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxUploadPackageRecipe)" />
  </ItemGroup>
  <PropertyGroup>
    <_GenerateAppxPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxPackageRecipe;
      _GenerateAppxPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxPackageRecipe
    </_GenerateAppxPackageRecipeDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <_GenerateAppxUploadPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxUploadPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxUploadPackageRecipe;
      _GenerateAppxUploadPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxUploadPackageRecipe
    </_GenerateAppxUploadPackageRecipeDependsOn>
  </PropertyGroup>
  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxPackageRecipe" />
  <Target Name="_GenerateAppxPackageRecipe" Condition="'$(AppxPackage)' == 'true' and '$(AppxGeneratePackageRecipeEnabled)' == 'true'" DependsOnTargets="$(_GenerateAppxPackageRecipeDependsOn)" />
  <Target Name="_GenerateAppxUploadPackageRecipe" Condition="'$(AppxPackage)' == 'true' and &#xD;&#xA;                     '$(AppxGeneratePackageRecipeEnabled)' == 'true' and &#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'" DependsOnTargets="$(_GenerateAppxUploadPackageRecipeDependsOn)" />
  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_CalculateInputsForGenerateAppxPackageRecipe">
    <ItemGroup>
      <_GenerateAppxPackageRecipeInput Include="@(FinalAppxManifest)" />
      <_GenerateAppxPackageRecipeInput Include="@(AppxPackagePayload)" />
      <_GenerateAppxPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_CalculateInputsForGenerateAppxUploadPackageRecipe">
    <ItemGroup>
      <_GenerateAppxUploadPackageRecipeInput Include="@(FinalAppxUploadManifest)" />
      <_GenerateAppxUploadPackageRecipeInput Include="@(AppxUploadPackagePayload)" />
      <_GenerateAppxUploadPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <!-- The uploaded .appx package should never include pdb's -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_GenerateAppxPackageRecipeFile" Inputs="$(MSBuildAllProjects);@(_GenerateAppxPackageRecipeInput)" Outputs="$(AppxPackageRecipe)">
    <GenerateAppxPackageRecipe AppxManifestXml="%(FinalAppxManifest.FullPath)" SourceAppxManifest="@(SourceAppxManifest)" SolutionConfiguration="$(Configuration)|$(Platform)" PayloadFiles="@(AppxPackagePayload)" FrameworkSdkPackages="@(FrameworkSdkPackage)" RecipeFile="$(AppxPackageRecipe)" SystemBinaries="@(AppxSystemBinary)" ReservedFileNames="@(AppxReservedFileName)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestFileNameQueries="@(AppxManifestFileNameQuery)" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" PackageArchitecture="$(PackageArchitecture)" ProjectDir="$(ProjectDir)" IntermediateOutputPath="$(IntermediateOutputPath)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" PlatformVersionDescriptions="@(PlatformVersionDescription)" IndexedPayloadFiles="@(IndexedPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" />
    <Message Importance="low" Text="Manifest: %(FinalAppxManifest.Identity)" />
    <Message Importance="low" Text="Payload: %(AppxPackagePayload.TargetPath) from %(AppxPackagePayload.FullPath)" />
    <Message Importance="low" Text="SDK reference: %(RecursiveResolvedSDKReference.TargetPath) from %(RecursiveResolvedSDKReference.FullPath)" />
    <Message Importance="low" Text="$(MSBuildProjectName) -&gt; $(AppxPackageRecipe)" />
  </Target>
  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_GenerateAppxUploadPackageRecipeFile" Inputs="$(MSBuildAllProjects);@(_GenerateAppxUploadPackageRecipeInput)" Outputs="$(AppxUploadPackageRecipe)">
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(TargetDir)$(AppxUploadPackageArtifactsDir)" />
    <GenerateAppxPackageRecipe AppxManifestXml="%(FinalAppxUploadManifest.FullPath)" SourceAppxManifest="@(SourceAppxManifest)" SolutionConfiguration="$(Configuration)|$(Platform)" PayloadFiles="@(AppxUploadPackagePayload)" FrameworkSdkPackages="@(FrameworkSdkPackage)" RecipeFile="$(AppxUploadPackageRecipe)" SystemBinaries="@(AppxSystemBinary)" ReservedFileNames="@(AppxReservedFileName)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestFileNameQueries="@(AppxManifestFileNameQuery)" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" PackageArchitecture="$(PackageArchitecture)" ProjectDir="$(ProjectDir)" IntermediateOutputPath="$(IntermediateOutputPath)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" PlatformVersionDescriptions="@(PlatformVersionDescription)" IndexedPayloadFiles="@(IndexedPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" />
    <Message Importance="low" Text="Manifest: %(FinalAppxUploadManifest.Identity)" />
    <Message Importance="low" Text="Payload: %(AppxUploadPackagePayload.TargetPath) from %(AppxUploadPackagePayload.FullPath)" />
    <Message Importance="low" Text="SDK reference: %(RecursiveResolvedSDKReference.TargetPath) from %(RecursiveResolvedSDKReference.FullPath)" />
    <Message Importance="low" Text="$(MSBuildProjectName) -&gt; $(AppxUploadPackageRecipe)" />
  </Target>
  <!-- Add FileReads and FileWrites done during generation of package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxPackageRecipe">
    <ItemGroup>
      <FileReads Include="@(_GenerateAppxPackageRecipeInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxPackageRecipe)" />
    </ItemGroup>
  </Target>
  <!-- Add FileReads and FileWrites done during generation of upload package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxUploadPackageRecipe">
    <ItemGroup>
      <FileReads Include="@(_GenerateAppxUploadPackageRecipeInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageRecipe)" />
    </ItemGroup>
  </Target>
  <!-- ==================================================================================== -->
  <!-- Creates a .tlog file from the FileReads items so that up-to-date check works in C++. -->
  <!-- ==================================================================================== -->
  <Target Name="_AppendToReadTlogFile" Condition="'$(Language)' == 'C++' and '@(FileReads)' != ''">
    <WriteLinesToFile File="$(TLogLocation)$(ProjectName).read.1u.tlog" Lines="^$(ProjectPath);@(FileReads->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- ============================================================================ -->
  <!-- Creates a .tlog file from the FileWrites items so Clean target works in C++. -->
  <!-- ============================================================================ -->
  <Target Name="_AppendToWriteTlogFile" Condition="'$(Language)' == 'C++' and '@(FileWrites)' != ''">
    <WriteLinesToFile File="$(TLogLocation)$(ProjectName).write.1u.tlog" Lines="^$(ProjectPath);@(FileWrites->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- Remember packaging files and directories to clean later.   -->
  <!-- We have to roll our own because targets which handle       -->
  <!-- regular FileWrites items are not considering those outside -->
  <!-- output or intermediate directory.                          -->
  <Target Name="_AppendToPackagingWriteLogs">
    <WriteLinesToFile Condition="'@(PackagingFileWrites)' != ''" File="$(PackagingFileWritesLogPath)" Lines="@(PackagingFileWrites->'%(Fullpath)')" Encoding="Unicode" />
    <WriteLinesToFile Condition="'@(PackagingDirectoryWrites)' != ''" File="$(PackagingDirectoryWritesLogPath)" Lines="@(PackagingDirectoryWrites->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- =============================== -->
  <!-- Generating Appx package.        -->
  <!-- Happens when invoked explictly. -->
  <!-- =============================== -->
  <PropertyGroup>
    <_GenerateAppxPackageBaseDependsOn>
      _ComputeAppxPackageOutput;
      _CreateAppxPackage;
      _CreateAppxBundlePlatformSpecificArtifacts;
    </_GenerateAppxPackageBaseDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
      $(_GenerateAppxPackageDependsOn);
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">
      $(_GenerateAppxPackageDependsOn);
      _SuppressDeploymentOnlyFeatures;
      Build;
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>
  </PropertyGroup>
  <Target Name="_GenerateAppxPackage" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(_GenerateAppxPackageDependsOn)" />
  <PropertyGroup>
    <_CreateAppxPackageDependsOn>
      _ValidateAppxPackage;
      _GenerateAppxPackageFile;
      _GenerateAppxUploadPackageFile;
      _GenerateAppxSymbolPackage;
      _CreateAppStoreContainer;
      _CreateAppStoreContainerForUAP;
      _CreateTestLayout;
      _AddWindowsInstallScriptToTestLayout;
    </_CreateAppxPackageDependsOn>
  </PropertyGroup>
  <!-- Computes Appx package output (file name and directory). -->
  <Target Name="_ComputeAppxPackageOutput">
    <ReadLinesFromFile File="$(_MultipleQualifiersPerDimensionFoundPath)" Condition="'$(AppxBundle)' == 'Auto' and Exists($(_MultipleQualifiersPerDimensionFoundPath))">
      <Output TaskParameter="Lines" PropertyName="_MultipleQualifiersPerDimensionFound" />
    </ReadLinesFromFile>
    <PropertyGroup Condition="'$(AppxBundle)' == 'Auto'">
      <_MultipleQualifiersPerDimensionFound Condition="'$(_MultipleQualifiersPerDimensionFound)' != 'true'">false</_MultipleQualifiersPerDimensionFound>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.0'">
      <ProduceAppxBundle>false</ProduceAppxBundle>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetPlatformVersion)' != '8.0'">
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Auto'">$(_MultipleQualifiersPerDimensionFound)</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Never'">false</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Always'">true</ProduceAppxBundle>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageName)' != ''">
      <AppxPackageNameNeutral>$(AppxPackageName)</AppxPackageNameNeutral>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageName)' == ''">
      <AppxPackageNameNeutral>$(ProjectName)_$(AppxManifestIdentityVersion)</AppxPackageNameNeutral>
      <_AppxPackageConfiguration Condition="'$(Configuration)' != 'Release'">_$(Configuration)</_AppxPackageConfiguration>
      <AppxPackageName>$(AppxPackageNameNeutral)_$(Platform)$(_AppxPackageConfiguration)</AppxPackageName>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxStoreContainer)' == '' and '$(ProduceAppxBundle)' == 'false'">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageName)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>
    <!-- compute paths for appx -->
    <PropertyGroup Condition="'$(AppxPackageTestDir)' == ''">
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\</AppxPackageTestDir>
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\</AppxPackageTestDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageOutput)' == ''">
      <AppxPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
    </PropertyGroup>
    <!-- compute paths for Upload appx & symbols -->
    <PropertyGroup Condition="'$(AppxUploadPackageDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)\</AppxUploadPackageDir>
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\</AppxUploadPackageDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxPackageExtension)</AppxUploadPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'">
      <AppxSymbolPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxSymbolPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundleDir Condition="'$(AppxBundleDir)' == ''">$(IntermediateOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxBundleDir>
      <AppxBundleDir Condition="!HasTrailingSlash('$(AppxBundleDir)')">$(AppxBundleDir)\</AppxBundleDir>
    </PropertyGroup>
    <PropertyGroup>
      <AppxUploadBundleDir Condition="'$(AppxUploadBundleDir)' == ''">$(IntermediateUploadOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxUploadBundleDir>
      <AppxUploadBundleDir Condition="!HasTrailingSlash('$(AppxUploadBundleDir)')">$(AppxUploadBundleDir)\</AppxUploadBundleDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxMainPackageOutput)' == ''">
      <AppxMainPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxMainPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadMainPackageOutput)' == ''">
      <AppxUploadMainPackageOutput>$(TargetDir)Upload\$(AppxPackageName)$(AppxPackageExtension)</AppxUploadMainPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxResourcePackOutputBase)' == ''">
      <AppxResourcePackOutputBase>$(TargetDir)$(AppxPackageNameNeutral)</AppxResourcePackOutputBase>
    </PropertyGroup>
  </Target>
  <!-- Extracts hash URI from store association file or provide default. -->
  <!-- Extracts packaging platforms, too.                                -->
  <Target Name="_ExtractStoreAssociationInformation" DependsOnTargets="_FindStoreAssociationFile;_ComputeAppxPackageOutput" BeforeTargets="_CreateAppxPackage;_CreateMainPackage;_CreateResourcePackages;_CreateBundle;_CalculateAppxBundleProperties">
    <PropertyGroup>
      <_ExtractPlatforms Condition="'$(AppxBundlePlatforms)' == '' and '$(ProduceAppxBundle)' == 'true'">true</_ExtractPlatforms>
      <_ExtractPlatforms Condition="'$(_ExtractPlatforms)' == ''">false</_ExtractPlatforms>
    </PropertyGroup>
    <ExtractStoreAssociationInformation StoreAssociationFile="@(StoreAssociationFile)" HashUris="@(AppxHashUri)" ExtractPlatforms="$(_ExtractPlatforms)" Condition="'@(StoreAssociationFile)' != ''">
      <Output TaskParameter="HashAlgorithmId" PropertyName="AppxHashAlgorithmId" />
      <Output TaskParameter="Platforms" PropertyName="_Platforms" />
    </ExtractStoreAssociationInformation>
    <Warning Condition="('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' == '' and '$(AppxBundlePlatforms)' == '')&#xD;&#xA;                         or ('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(_Platforms)' == '')" Text="APPX4001: Build property AppxBundlePlatforms is not explicitly set and is calculated based on currently building architecture. Use 'Create App Package' wizard or edit project file to set it." />
    <Warning Condition="'$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(AppxBundlePlatforms)' == '' and '$(_Platforms)' != ''" Text="APPX4002: Build property AppxBundlePlatforms is not explicitly set and is calculated based on uploaded packages in the Store for currently building app. Use 'Create App Package' wizard or edit project file to set it." />
    <PropertyGroup Condition="'$(AppxHashAlgorithmId)' == ''">
      <AppxHashAlgorithmId>$(AppxDefaultHashAlgorithmId)</AppxHashAlgorithmId>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_ExtractPlatforms)' == 'true'">
      <AppxBundlePlatforms>$(_Platforms.Replace(';', '|'))</AppxBundlePlatforms>
    </PropertyGroup>
  </Target>
  <!-- Executes pre-upload validation of the appx package. -->
  <Target Name="_ValidateAppxPackage" Condition="'$(AppxPackageValidationEnabled)' == 'true'">
    <ValidateAppxPackage SourceAppxManifest="@(SourceAppxManifest)" AppxManifest="@(FinalAppxManifest)" StoreAssociationFile="@(StoreAssociationFile)" PackageArchitecture="$(PackageArchitecture)" AppxPackagePayload="@(AppxPackagePayload)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" ResolvedSDKReferences="@(RecursiveResolvedSDKReference)" AllowDebugFrameworkReferencesInManifest="$(AppxPackageAllowDebugFrameworkReferencesInManifest)" ProjectDir="$(ProjectDir)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" IndexedPayloadFiles="@(IndexedPayloadFiles)" OSMinVersion="$(AppxOSMinVersion)" ProduceAppxBundle="$(ProduceAppxBundle)" IndexedMainPayloadFiles="@(IndexedMainPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" />
  </Target>
  <Target Name="_CreateAppxPackage" Condition="'$(ProduceAppxBundle)' == 'false'" DependsOnTargets="$(_CreateAppxPackageDependsOn)" />
  <!-- The following target generates the appx package. -->
  <Target Name="_GenerateAppxPackageFile" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);@(AppxPackagePayload);$(PackageCertificateKeyFile)" Outputs="$(AppxPackageOutput)">
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <WriteLinesToFile File="$(AppxPackageFileMap)" Lines="[Files];&#xD;&#xA;                                 @(FinalAppxManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22'); &#xD;&#xA;                                 @(AppxPackagePayload->'%22%(Identity)%22 %22%(TargetPath)%22')" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackageFileMap)" />
    </ItemGroup>
    <!-- Package and sign the Test Appx -->
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="false" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" FileMap="$(AppxPackageFileMap)" Output="$(AppxPackageOutput)" />
    <ItemGroup>
      <FinalAppxPackageItem Include="$(AppxPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(FinalAppxPackageItem)" />
    </ItemGroup>
    <WriteLinesToFile File="$(AppxPackagingInfoFile)" Overwrite="true" Lines="%(FinalAppxPackageItem.FullPath)" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
    <Message Importance="high" Text="$(MSBuildProjectName) -&gt; %(FinalAppxPackageItem.FullPath)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="@(FinalAppxPackageItem)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(ResolvedThumbprint)" />
  </Target>
  <!-- The following target generates the appx Upload package. -->
  <Target Name="_GenerateAppxUploadPackageFile" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);@(AppxUploadPackagePayload);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadPackageOutput)">
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <WriteLinesToFile File="$(AppxUploadPackageFileMap)" Lines="[Files];&#xD;&#xA;                                 @(FinalAppxUploadManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');&#xD;&#xA;                                 @(AppxUploadPackagePayload->'%22%(Identity)%22 %22%(TargetPath)%22')" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageFileMap)" />
    </ItemGroup>
    <!-- Package and sign the Upload Appx -->
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="false" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" FileMap="$(AppxUploadPackageFileMap)" Output="$(AppxUploadPackageOutput)" />
    <ItemGroup>
      <FinalAppxUploadPackageItem Include="$(AppxUploadPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
    <Message Importance="high" Text="$(MSBuildProjectName) -&gt; %(FinalAppxUploadPackageItem.FullPath)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="@(FinalAppxUploadPackageItem)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
  </Target>
  <!-- The following target creates the Upload appx symbol package. -->
  <Target Name="_GenerateAppxSymbolPackage" Condition="'$(AppxSymbolPackageEnabled)' == 'true' and &#xD;&#xA;                     '@(PDBPayload)' != '' and &#xD;&#xA;                     ('$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxUploadPackageForUap)' == 'true')" Inputs="$(MSBuildAllProjects);@(PDBPayload);@(FinalAppxManifest)" Outputs="$(AppxSymbolPackageOutput)">
    <PropertyGroup>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == '' and '$(BuildAppxUploadPackageForUap)' == 'true'">false</StripPrivateSymbols>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == ''">true</StripPrivateSymbols>
    </PropertyGroup>
    <GenerateAppxSymbolPackage PdbCopyExeFullPath="$(PdbCopyExeFullPath)" PdbFiles="@(PDBPayload)" ProjectName="$(MSBuildProjectName)" StrippedDirectory="$(AppxSymbolStrippedDir)" StripPrivateSymbols="$(StripPrivateSymbols)" AppxSymbolPackageOutput="$(AppxSymbolPackageOutput)">
      <Output TaskParameter="StrippedPdbs" ItemName="StrippedPDBFiles" />
    </GenerateAppxSymbolPackage>
    <ItemGroup>
      <FinalAppxSymbolPackageItem Include="$(AppxSymbolPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxSymbolPackageItem)" />
      <FileWrites Include="@(StrippedPDBFiles)" />
      <PackagingDirectoryWrites Include="$(AppxSymbolStrippedDir)" />
    </ItemGroup>
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxSymbolPackageOutput)" />
  </Target>
  <!-- Creates a test layout for testing of the appx package. -->
  <Target Name="_CreateTestLayout" Condition="'$(AppxTestLayoutEnabled)' == 'true'">
    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(FileName)%(Extension)')" />
    </ItemGroup>
    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>
    <Message Importance="low" Text="Test Layout: %(_TestLayoutTargetFiles.FullPath)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_TestLayoutSourceFiles)" DestinationFiles="@(_TestLayoutTargetFiles)" />
    <ItemGroup>
      <PackagingFileWrites Include="@(_TestLayoutTargetFiles)" />
      <PackagingDirectoryWrites Include="$(AppxPackageTestDir)" />
    </ItemGroup>
  </Target>
  <!-- Add install script for Windows packages/bundles to the test layout. -->
  <Target Name="_AddWindowsInstallScriptToTestLayout" Condition="'$(AppxTestLayoutEnabled)' == 'true' and '$(_TargetPlatformIsWindowsPhone)' != 'true'">
    <ItemGroup>
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Add-AppDevPackage.ps1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)**\Add-AppDevPackage.psd1" />
    </ItemGroup>
    <ItemGroup>
      <_PowerShellScriptsDestination Include="@(_PowerShellScriptsSource->'$(AppxPackageTestDir)%(RecursiveDir)%(FileName)%(Extension)')" />
    </ItemGroup>
    <!--Copy install scripts to app package location.-->
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="true" SourceFiles="@(_PowerShellScriptsSource)" DestinationFiles="@(_PowerShellScriptsDestination)" ContinueOnError="$(ContinueOnError)" />
    <ItemGroup>
      <PackagingFileWrites Include="@(_PowerShellScriptsDestination)" />
    </ItemGroup>
  </Target>
  <!-- Creates .appxupload file containing .appx and optional .appxsym, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Legacy App Store          -->
  <Target Name="_CreateAppStoreContainer" Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Inputs="$(MSBuildAllProjects);@(FinalAppxPackageItem);@(FinalAppxSymbolPackageItem)" Outputs="$(AppxStoreContainer)">
    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>
    <CreateAppStoreContainer Items="@(FinalAppxPackageItem);@(FinalAppxSymbolPackageItem)" ProjectName="$(MSBuildProjectName)" OutputPath="%(_AppxStoreContainer.FullPath)" />
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>
  <!-- Creates .appxupload file containing .appx and optional .appxsym, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Universal App Store              -->
  <Target Name="_CreateAppStoreContainerForUAP" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadPackageItem);@(FinalAppxSymbolPackageItem)" Outputs="$(AppxStoreContainer)">
    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>
    <CreateAppStoreContainer Items="@(FinalAppxUploadPackageItem);@(FinalAppxSymbolPackageItem)" ProjectName="$(MSBuildProjectName)" OutputPath="%(_AppxStoreContainer.FullPath)" />
    <RemoveDir Directories="$(AppxUploadPackageDir)" />
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>
  <!-- ================================================== -->
  <!-- Create platform-specific artifacts for app bundle. -->
  <!-- ================================================== -->
  <PropertyGroup>
    <_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
      $(Before_CreateAppxBundlePlatformSpecificArtifacts)

      _GetPackageProperties;

      _CreatePackageLayout_CalculateInputsAndOutputs;
      _CreatePackageLayout;
      _CreatePackageLayout_AddFileWrites;

      _CreateUploadPackageLayout_CalculateInputsAndOutputs;
      _CreateUploadPackageLayout;
      _CreateUploadPackageLayout_AddFileWrites;

      _GetDefaultResourceLanguage;

      _CreatePriConfigXmlForSplitting;
      _CreatePriConfigXmlForSplitting_AddFileWrites;

      _CreateUploadPriConfigXmlForSplitting;
      _CreateUploadPriConfigXmlForSplitting_AddFileWrites;

      _SplitResourcesPri_CalculateInputsAndOutputs;
      _SplitResourcesPri;
      _SplitResourcesPri_AddFileWrites;

      _SplitUploadResourcesPri_CalculateInputsAndOutputs;
      _SplitUploadResourcesPri;
      _SplitUploadResourcesPri_AddFileWrites;

      _ExpandMainPriFile;
      _ValidateAppxPackage;

      _CreatePriConfigXmlForMainPackageFileMap;
      _CreatePriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateUploadPriConfigXmlForMainPackageFileMap;
      _CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateMainPackageFileMap;
      _CreateMainPackageFileMap_AddFileWrites;

      _CreateUploadMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateUploadMainPackageFileMap;
      _CreateUploadMainPackageFileMap_AddFileWrites;

      _UpdateMainPackageFileMap;
      _UpdateMainPackageFileMap_AddFileWrites;

      _UpdateUploadMainPackageFileMap;
      _UpdateUploadMainPackageFileMap_AddFileWrites;

      _UpdateAppxManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxManifestForBundle;
      _UpdateAppxManifestForBundle_AddFileWrites;

      _UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxUploadManifestForBundle;
      _UpdateAppxUploadManifestForBundle_AddFileWrites;

      _CreateMainPackage;
      _CreateMainPackage_AddFileWrites;

      _CreateMainUploadPackage;
      _CreateMainUploadPackage_AddFileWrites;

      _GenerateAppxSymbolPackage;

      _CreateResourcePackages_CalculateInputsAndOutputs;
      _CreateResourcePackages;
      _CreateResourcePackages_AddFileWrites;

      _CreateUploadResourcePackages_CalculateInputsAndOutputs;
      _CreateUploadResourcePackages;
      _CreateUploadResourcePackages_AddFileWrites;

      _CreatePlatformSpecificArtifactsList;
      _CreatePlatformSpecificUploadArtifactsList;

      _CreateAppxBundleFiles;

      $(After_CreateAppxBundlePlatformSpecificArtifacts)
    </_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
  </PropertyGroup>
  <Target Name="_CreateAppxBundlePlatformSpecificArtifacts" Condition="'$(ProduceAppxBundle)' == 'true'" DependsOnTargets="$(_CreateAppxBundlePlatformSpecificArtifactsDependsOn)" />
  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout_CalculateInputsAndOutputs">
    <ItemGroup>
      <_PackageLayoutFileSource Include="@(AppxPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_PackageLayoutFileSource Remove="@(_PackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ItemGroup>
      <_PackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
    </ItemGroup>
    <ItemGroup>
      <_PackageLayoutFileTarget Include="@(_PackageLayoutFileSource->'$(AppxLayoutDir)%(TargetPath)')" />
    </ItemGroup>
  </Target>
  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(IntermediateUploadOutputPath)" />
    <ItemGroup>
      <_UploadPackageLayoutFileSource Include="@(AppxUploadPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_UploadPackageLayoutFileSource Remove="@(_UploadPackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ItemGroup>
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriUploadFullPath)" />
    </ItemGroup>
    <ItemGroup>
      <_UploadPackageLayoutFileTarget Include="@(_UploadPackageLayoutFileSource->'$(AppxUploadLayoutDir)%(TargetPath)')" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout">
    <RemoveDir Directories="$(AppxLayoutDir)" />
    <Copy SourceFiles="@(_PackageLayoutFileSource)" DestinationFiles="@(_PackageLayoutFileTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Message Text="$(ProjectName) -&gt; $(AppxLayoutDir)" />
  </Target>
  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <RemoveDir Directories="$(AppxUploadLayoutDir)" />
    <Copy SourceFiles="@(_UploadPackageLayoutFileSource)" DestinationFiles="@(_UploadPackageLayoutFileTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Message Text="$(ProjectName) -&gt; $(AppxUploadLayoutDir)" />
  </Target>
  <!-- add sideload file writes -->
  <Target Name="_CreatePackageLayout_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_PackageLayoutFileTarget)" />
      <PackagingDirectoryWrites Include="$(AppxLayoutDir)" />
    </ItemGroup>
  </Target>
  <!-- Add upload file writes -->
  <Target Name="_CreateUploadPackageLayout_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_UploadPackageLayoutFileTarget)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadLayoutDir)" />
    </ItemGroup>
  </Target>
  <!-- Create sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxBundlePriConfigXmlForSplittingFileName)">
    <CreatePriConfigXmlForSplitting PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)" ResourcesPriFilePath="$(ProjectPriFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" />
    <Message Text="$(ProjectName) -&gt; $(AppxBundlePriConfigXmlForSplittingFileName)" />
  </Target>
  <!-- Create upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <CreatePriConfigXmlForSplitting PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" ResourcesPriFilePath="$(ProjectPriFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" />
    <Message Text="$(ProjectName) -&gt; $(AppxUploadBundlePriConfigXmlForSplittingFileName)" />
  </Target>
  <!-- File writes for the sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- file writes for the upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to split the sideload resources pri -->
  <Target Name="_SplitResourcesPri_CalculateInputsAndOutputs">
    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Prepare to split the upload resources pri -->
  <Target Name="_SplitUploadResourcesPri_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Split the sideload pri -->
  <Target Name="_SplitResourcesPri" Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)" Outputs="$(AppxBundleSplitResourcesGeneratedFilesListPath);@(_AppxBundleSplitResourcesGeneratedFiles)">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxLayoutDir)" OutputFileName="$(AppxBundleSplitResourcesPriPath)" GeneratedFilesListPath="$(AppxBundleSplitResourcesGeneratedFilesListPath)" QualifiersPath="$(AppxBundleSplitResourcesQualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" />
    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
    <Message Text="$(ProjectName) -&gt; %(_AppxBundleSplitResourcesGeneratedFiles.Identity)" />
  </Target>
  <!-- Split the upload pri -->
  <Target Name="_SplitUploadResourcesPri" Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)" Outputs="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath);@(_AppxUploadBundleSplitResourcesGeneratedFiles)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxUploadLayoutDir)" OutputFileName="$(AppxUploadBundleSplitResourcesPriPath)" GeneratedFilesListPath="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" QualifiersPath="$(AppxUploadBundleSplitResourcesQualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" />
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
    <Message Text="$(ProjectName) -&gt; %(_AppxUploadBundleSplitResourcesGeneratedFiles.Identity)" />
  </Target>
  <!-- Wrap up splitting the sideload pri -->
  <Target Name="_SplitResourcesPri_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>
  <!-- Wrap up splitting the upload pri -->
  <Target Name="_SplitUploadResourcesPri_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)">
    <CreatePriConfigXmlForMainPackageFileMap PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" />
    <Message Text="$(ProjectName) -&gt; $(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
  </Target>
  <!-- Create the upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <CreatePriConfigXmlForMainPackageFileMap PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" />
    <Message Text="$(ProjectName) -&gt; $(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
  </Target>
  <!-- Filewrites for sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- Filewrites for upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap_CalculateInputsAndOutputs">
    <ItemGroup>
      <_AppxBundleMainPackageMapInputs Include="$(AppxLayoutDir)\**\*" />
    </ItemGroup>
    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Prepare to create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapInputs Include="$(AppxUploadLayoutDir)\**\*" />
    </ItemGroup>
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap" Inputs="$(MSBuildAllProjects);@(_AppxBundleMainPackageMapInputs)" Outputs="$(AppxBundleMainPackageFileMapIntermediatePath)">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxLayoutDir)" OutputFileName="$(AppxBundleMainPackageFileMapIntermediatePriPath)" GeneratedFilesListPath="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" />
    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
    <Message Text="$(ProjectName) -&gt; %(_AppxBundleMainPackageMapGeneratedFiles.Identity)" />
  </Target>
  <!-- Create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap" Inputs="$(MSBuildAllProjects);@(_AppxUploadBundleMainPackageMapInputs)" Outputs="$(AppxUploadBundleMainPackageFileMapIntermediatePath)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxUploadLayoutDir)" OutputFileName="$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)" GeneratedFilesListPath="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" />
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
    <Message Text="$(ProjectName) -&gt; %(_AppxUploadBundleMainPackageMapGeneratedFiles.Identity)" />
  </Target>
  <!-- Wrap up creating the sideload file map -->
  <Target Name="_CreateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>
  <!-- Wrap up creating the upload file map -->
  <Target Name="_CreateUploadMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>
  <!-- Update the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxBundleMainPackageFileMapIntermediatePath);$(AppxBundleSplitResourcesPriPath)" Outputs="$(AppxBundleMainPackageFileMapPath)">
    <ItemGroup>
      <_AppxBundleSplitResourcesPriPathItem Include="$(AppxBundleSplitResourcesPriPath)" />
    </ItemGroup>
    <UpdateMainPackageFileMap Input="$(AppxBundleMainPackageFileMapIntermediatePath)" Output="$(AppxBundleMainPackageFileMapPath)" SplitResourcesPriPath="%(_AppxBundleSplitResourcesPriPathItem.FullPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" />
    <Message Text="$(ProjectName) -&gt; $(AppxBundleMainPackageFileMapPath)" />
  </Target>
  <!-- Update the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxUploadBundleMainPackageFileMapIntermediatePath);$(AppxUploadBundleSplitResourcesPriPath)" Outputs="$(AppxUploadBundleMainPackageFileMapPath)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesPriPathItem Include="$(AppxUploadBundleSplitResourcesPriPath)" />
    </ItemGroup>
    <UpdateMainPackageFileMap Input="$(AppxUploadBundleMainPackageFileMapIntermediatePath)" Output="$(AppxUploadBundleMainPackageFileMapPath)" SplitResourcesPriPath="%(_AppxUploadBundleSplitResourcesPriPathItem.FullPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" />
    <Message Text="$(ProjectName) -&gt; $(AppxUploadBundleMainPackageFileMapPath)" />
  </Target>
  <!-- Wrap up updating the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>
  <!--Wrap up updating the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_CalculateInputsAndOutputs">
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest->'%(RootDir)%(Directory)ForBundle\%(Filename)%(Extension)')" />
    </ItemGroup>
  </Target>
  <!-- Prepare to update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <!-- split.pri gets added in a previous step and should not be re-added here -->
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest->'%(RootDir)%(Directory)ForUploadBundle\%(Filename)%(Extension)')" Condition="'%(FinalAppxUploadManifest.TargetPath)' != 'split.pri'" />
    </ItemGroup>
  </Target>
  <!-- Update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest)" Outputs="@(AppxManifestForBundle)">
    <MakeDir Directories="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxManifest)" AppxManifestForBundle="@(AppxManifestForBundle)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" />
    <Message Text="$(ProjectName) -&gt; @(AppxManifestForBundle)" />
  </Target>
  <!-- Update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest)" Outputs="@(AppxUploadManifestForBundle)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeDir Directories="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxUploadManifest)" AppxManifestForBundle="@(AppxUploadManifestForBundle)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" />
    <Message Text="$(ProjectName) -&gt; @(AppxUploadManifestForBundle)" />
  </Target>
  <!-- Wrap up updating the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(AppxManifestForBundle)" />
      <PackagingDirectoryWrites Include="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>
  </Target>
  <!-- Wrap up updating the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(AppxUploadManifestForBundle)" />
      <PackagingUploadDirectoryWrites Include="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload appx -->
  <Target Name="_CreateMainPackage" Inputs="$(MSBuildAllProjects);@(AppxManifestForBundle);$(AppxBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)" Outputs="$(AppxMainPackageOutput)">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="false" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxManifestForBundle)" FileMap="$(AppxBundleMainPackageFileMapPath)" Output="$(AppxMainPackageOutput)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxMainPackageOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; $(AppxMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -&gt; $(AppxMainPackageOutput) (unsigned)" />
  </Target>
  <!-- Create the upload appx -->
  <Target Name="_CreateMainUploadPackage" Inputs="$(MSBuildAllProjects);@(AppxUploadManifestForBundle);$(AppxUploadBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadMainPackageOutput)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="false" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxUploadManifestForBundle)" FileMap="$(AppxUploadBundleMainPackageFileMapPath)" Output="$(AppxUploadMainPackageOutput)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxUploadMainPackageOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; $(AppxUploadMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -&gt; $(AppxUploadMainPackageOutput) (unsigned)" />
  </Target>
  <!-- Wrap up creating the sideload package -->
  <Target Name="_CreateMainPackage_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxMainPackageOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- Wrap up creating the upload package -->
  <Target Name="_CreateMainUploadPackage_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadMainPackageOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- Resource packages are created during the build of the platform which will produce the bundle.               -->
  <!-- There is a work item to validate that assumption which will move resource pack generation to target Bundle. -->
  <!-- 635606: Resource Packs: Validate generated resource packs file maps across architectures                   -->
  <!-- Prep to create the sideload resource packages -->
  <Target Name="_CreateResourcePackages_CalculateInputsAndOutputs" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">
    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>
    <ItemGroup>
      <_AppxBundleResourceFileMapsIntermediate Include="@(_AppxBundleSplitResourcesGeneratedFiles)" Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxBundleResourceFileMapsIntermediate>
    </ItemGroup>
    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxBundleResourceFileMapsIntermediate)" FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)" MapSuffix="$(AppxBundleMainPackageFileMapSuffix)" Languages="@(_ManifestResources-&gt;WithMetadataValue('Dimension', 'Language')-&gt;'%(Value)')" Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'">
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>
    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxBundleResourceFileMaps Include="@(_AppxBundleResourceFileMapsIntermediate)" />
    </ItemGroup>
  </Target>
  <!-- Prep to create the upload resource packages -->
  <Target Name="_CreateUploadResourcePackages_CalculateInputsAndOutputs" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>
    <ItemGroup>
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>
    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxUploadBundleResourceFileMapsIntermediate)" FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)" MapSuffix="$(AppxBundleMainPackageFileMapSuffix)" Languages="@(_ManifestResources-&gt;WithMetadataValue('Dimension', 'Language')-&gt;'%(Value)')" Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'">
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxUploadBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>
    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxUploadBundleResourceFileMaps Include="@(_AppxUploadBundleResourceFileMapsIntermediate)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateResourcePackages" Inputs="@(_AppxBundleResourceFileMaps)" Outputs="%(ResourcePack)" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="true" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxManifestForBundle)" FileMap="%(_AppxBundleResourceFileMaps.Identity)" Output="%(_AppxBundleResourceFileMaps.ResourcePack)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="%(_AppxBundleResourceFileMaps.ResourcePack)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; %(_AppxBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -&gt; %(_AppxBundleResourceFileMaps.ResourcePack) (unsigned)" />
  </Target>
  <Target Name="_CreateUploadResourcePackages" Inputs="@(_AppxUploadBundleResourceFileMaps)" Outputs="%(ResourcePack)" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" ResourcePack="true" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxUploadManifestForBundle)" FileMap="%(_AppxUploadBundleResourceFileMaps.Identity)" Output="%(_AppxUploadBundleResourceFileMaps.ResourcePack)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="%(_AppxUploadBundleResourceFileMaps.ResourcePack)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; %(_AppxUploadBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -&gt; %(_AppxUploadBundleResourceFileMaps.ResourcePack) (unsigned)" />
  </Target>
  <Target Name="_CreateResourcePackages_AddFileWrites" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateUploadResourcePackages_AddFileWrites" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
  </Target>
  <!-- Create sideload artifacts list -->
  <Target Name="_CreatePlatformSpecificArtifactsList">
    <MakeDir Directories="$(PlatformSpecificBundleArtifactsListDir)" />
    <ItemGroup>
      <_AppxBundleResourcePack Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxMainPackageOutput)'))" Condition="Exists($(AppxMainPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxSymbolPackageOutput)'))" Condition="Exists($(AppxSymbolPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="ResourcePack=%(_AppxBundleResourcePack.FullPath)" Condition="'@(_AppxBundleResourcePack)' != ''" />
    </ItemGroup>
    <Delete Files="$(AppxBundlePlatformSpecificArtifactsListPath)" />
    <WriteLinesToFile File="$(AppxBundlePlatformSpecificArtifactsListPath)" Lines="@(_PlatformSpecificBundleArtifact)" />
    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->
    <PropertyGroup Condition="'$(AppxBundleOutput)' == ''">
      <AppxBundleOutput>$(AppxPackageTestDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxBundleOutput>
    </PropertyGroup>
    <WriteLinesToFile File="$(AppxPackagingInfoFile)" Overwrite="true" Lines="$([System.IO.Path]::GetFullPath('$(AppxBundleOutput)'))" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
  </Target>
  <!-- Create upload artifacts list -->
  <Target Name="_CreatePlatformSpecificUploadArtifactsList" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeDir Directories="$(PlatformSpecificUploadBundleArtifactsListDir)" />
    <ItemGroup>
      <_AppxUploadBundleResourcePack Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadMainPackageOutput)'))" Condition="Exists($(AppxUploadMainPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxSymbolPackageOutput)'))" Condition="Exists($(AppxSymbolPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="ResourcePack=%(_AppxUploadBundleResourcePack.FullPath)" Condition="'@(_AppxUploadBundleResourcePack)' != ''" />
    </ItemGroup>
    <Delete Files="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" />
    <WriteLinesToFile File="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" Lines="@(_PlatformSpecificUploadBundleArtifact)" />
    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->
    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == ''">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>
    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)" Overwrite="true" Lines="$([System.IO.Path]::GetFullPath('$(AppxUploadBundleOutput)'))" />
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>
  </Target>
  <!-- ============================= -->
  <!-- Produce the app bundle files. -->
  <!-- ============================= -->
  <PropertyGroup>
    <_CreateAppxBundleFilesDependsOn>
      $(BeforeCreateAppxBundleFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateBundle_CalculateInputsAndOutputs;
      _CreateBundle;
      _CreateBundle_AddFileWrites;

      _CreateUploadBundle_CalculateInputsAndOutputs;
      _CreateUploadBundle;
      _CreateUploadBundle_AddFileWrites;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _CreateTestLayout;
      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxBundleFiles)
    </_CreateAppxBundleFilesDependsOn>
  </PropertyGroup>
  <Target Name="_CreateAppxBundleFiles" Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and '$(_SkipBundleCreation)' != 'true'" DependsOnTargets="$(_CreateAppxBundleFilesDependsOn)" />
  <Target Name="_GetOtherPlatformsToBundle" Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>
    <ItemGroup>
      <_OtherPlatformToBundle Condition="'%(Identity)' != '$(_AdjustedPlatform)'" Include="@(AppxBundlePlatformWithAnyCPU)" />
    </ItemGroup>
  </Target>
  <Target Name="_ProducePlatformSpecificBundleArtifactsForOtherPlatforms" Condition="'@(_OtherPlatformToBundle)' != ''" Inputs="@(_OtherPlatformToBundle)" Outputs="%(Identity).AlwaysRun">
    <Message Importance="low" Text="Producing bundle artifacts for platform '%(_OtherPlatformToBundle.Identity)'" />
    <PropertyGroup>
      <_TargetToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetToBuild>
      <_TargetToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetToBuild>
    </PropertyGroup>
    <PropertyGroup Condition="'$(SolutionPath)' == '' or '$(SolutionPath)' == '*Undefined*'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>false</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse />
    </PropertyGroup>
    <MSBuild Projects="$(SolutionPath)" Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*'" Targets="GetSolutionConfigurationContents" Properties="Configuration=$(Configuration);Platform=%(_OtherPlatformToBundle.Identity)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="TargetOutputs" PropertyName="_SolutionConfigurationContentsToUse" />
    </MSBuild>
    <PropertyGroup Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*'">
      <_FileToBuild>$(SolutionPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
    </PropertyGroup>
    <!-- Build the legacy package for the legacy build pipeline -->
    <MSBuild Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Projects="$(_FileToBuild)" Targets="$(_TargetToBuild)" Properties="ShouldUnsetParentConfigurationAndPlatform=$(_ShouldUnsetParentConfigurationAndPlatform);&#xD;&#xA;                             CurrentSolutionConfigurationContents=$(_SolutionConfigurationContentsToUse);&#xD;&#xA;                             Configuration=$(Configuration);&#xD;&#xA;                             Platform=%(_OtherPlatformToBundle.Identity);&#xD;&#xA;                             _SkipBundleCreation=true;&#xD;&#xA;                             PlatformSpecificBundleArtifactsListDir=$(PlatformSpecificBundleArtifactsListDir);&#xD;&#xA;                             AppxPackageDir=$(AppxPackageDir)" ContinueOnError="$(ContinueOnError)" />
    <!-- Build the UAP package for UAP build pipeline -->
    <MSBuild Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Projects="$(_FileToBuild)" Targets="$(_TargetToBuild)" Properties="ShouldUnsetParentConfigurationAndPlatform=$(_ShouldUnsetParentConfigurationAndPlatform);&#xD;&#xA;                             CurrentSolutionConfigurationContents=$(_SolutionConfigurationContentsToUse);&#xD;&#xA;                             Configuration=$(Configuration);&#xD;&#xA;                             Platform=%(_OtherPlatformToBundle.Identity);&#xD;&#xA;                             _SkipBundleCreation=true;&#xD;&#xA;                             PlatformSpecificBundleArtifactsListDir=$(PlatformSpecificUploadBundleArtifactsListDir);&#xD;&#xA;                             AppxPackageDir=$(AppxUploadPackageDir)" ContinueOnError="$(ContinueOnError)" />
  </Target>
  <Target Name="_GetPlatformSpecificBundleArtifacts">
    <ItemGroup>
      <_PlatformSpecificBundleArtifact Remove="@(_PlatformSpecificBundleArtifact)" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Remove="@(_PlatformSpecificUploadBundleArtifact)" />
    </ItemGroup>
    <ParsePlatformSpecificBundleArtifactsLists Files="$(PlatformSpecificBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>
    <ParsePlatformSpecificBundleArtifactsLists Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Files="$(PlatformSpecificUploadBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificUploadBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>
    <ItemGroup>
      <_MainPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourcePackToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_MainUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourceUploadPackToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>
  </Target>
  <!-- Prep to create the sideload bundle -->
  <Target Name="_CreateBundle_CalculateInputsAndOutputs">
    <ItemGroup>
      <_CreateBundleInputs Include="@(_MainPackageToBundle)" />
      <_CreateBundleInputs Include="@(_ResourcePackToBundle)" />
    </ItemGroup>
  </Target>
  <!-- Prep to create the upload bundle -->
  <Target Name="_CreateUploadBundle_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_CreateUploadBundleInputs Include="@(_MainUploadPackageToBundle)" />
      <_CreateUploadBundleInputs Include="@(_ResourceUploadPackToBundle)" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload bundle -->
  <Target Name="_CreateBundle" Inputs="$(MSBuildAllProjects);@(_CreateBundleInputs);$(PackageCertificateKeyFile)" Outputs="$(AppxBundleOutput)">
    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)" AppxBundlePlatforms="@(AppxBundlePlatform)" />
    <RemoveDir Directories="$(AppxBundleDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_CreateBundleInputs)" DestinationFolder="$(AppxBundleDir)" />
    <ItemGroup>
      <_AppxBundleContent Include="$(AppxBundleDir)*" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>
    <Message Text="Adding file '%(_AppxBundleContent.Identity)'" />
    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxBundleManifestVersion="$(AppxBundleManifestVersion)" BundleDir="$(AppxBundleDir)" Output="$(AppxBundleOutput)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxBundleOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Importance="high" Text="$(ProjectName) -&gt; $(AppxBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
  </Target>
  <!-- Create the upload bundle -->
  <Target Name="_CreateUploadBundle" Inputs="$(MSBuildAllProjects);@(_CreateUploadBundleInputs);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadBundleOutput)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)" AppxBundlePlatforms="@(AppxBundlePlatform)" />
    <RemoveDir Directories="$(AppxUploadBundleDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_CreateUploadBundleInputs)" DestinationFolder="$(AppxUploadBundleDir)" />
    <ItemGroup>
      <_AppxUploadBundleContent Include="$(AppxUploadBundleDir)*" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>
    <Message Text="Adding file '%(_AppxUploadBundleContent.Identity)'" />
    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxBundleManifestVersion="$(AppxBundleManifestVersion)" BundleDir="$(AppxUploadBundleDir)" Output="$(AppxUploadBundleOutput)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxUploadBundleOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Importance="high" Text="$(ProjectName) -&gt; $(AppxUploadBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
  </Target>
  <!-- wrap up creating the sideload bundle -->
  <Target Name="_CreateBundle_AddFileWrites">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxBundleOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- wrap up creating the upload bundle -->
  <Target Name="_CreateUploadBundle_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxUploadBundleOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateAppStoreBundleContainer_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or &#xD;&#xA;                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'">
    <ItemGroup>
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Include="$(AppxBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'" Include="$(AppxUploadBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Include="@(_SymbolPackageToBundle)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxStoreContainer)' == ''">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)_bundle$(_AppxPackageConfiguration)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>
  </Target>
  <Target Name="_CreateAppStoreBundleContainer" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or &#xD;&#xA;                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Inputs="$(MSBuildAllProjects);@(_CreateAppStoreBundleContainerInputs)" Outputs="$(AppxStoreContainer)">
    <CreateAppStoreContainer Items="@(_CreateAppStoreBundleContainerInputs)" ProjectName="$(MSBuildProjectName)" OutputPath="$(AppxStoreContainer)" />
    <!-- Remove the intermediate directory after a bundle build -->
    <RemoveDir Directories="$(AppxUploadPackageDir)" />
  </Target>
  <Target Name="_CreateAppStoreBundleContainer_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or &#xD;&#xA;                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>
  <!-- =============================== -->
  <!-- Clean/Rebuild support.          -->
  <!-- =============================== -->
  <!-- Cleans current project and any referenced projects' appx package artifacts. -->
  <Target Name="_CleanAppxPackage" Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == 'true'" DependsOnTargets="$(_CleanAppxPackageDependsOn)" AfterTargets="Clean">
    <ReadLinesFromFile File="$(PackagingDirectoryWritesLogPath)" Condition="Exists($(PackagingDirectoryWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_DirectoriesToRemove" />
    </ReadLinesFromFile>
    <RemoveDir Directories="@(_DirectoriesToRemove)" ContinueOnError="true" />
    <Delete Files="$(PackagingDirectoryWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <ReadLinesFromFile File="$(PackagingFileWritesLogPath)" Condition="Exists($(PackagingFileWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_FilesToRemove" />
    </ReadLinesFromFile>
    <Delete Files="@(_FilesToRemove)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <Delete Files="$(PackagingFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
  </Target>
  <!-- Rebuild appx package target and entry point. -->
  <Target Name="_RebuildAppxPackage" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(CleanPackageAction);$(PackageAction)" />
  <!-- ========================================== -->
  <!-- Returns Architecture for given Platform.   -->
  <!-- ========================================== -->
  <Target Name="_GetProjectArchitecture" Returns="@(ProjectArchitecture)">
    <PropertyGroup>
      <_ProjectArchitectureOutput>Invalid</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'AnyCPU'">neutral</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x86'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'Win32'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x64'">x64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm'">arm</_ProjectArchitectureOutput>
    </PropertyGroup>
    <ItemGroup>
      <ProjectArchitecture Include="$(_ProjectArchitectureOutput)" />
    </ItemGroup>
  </Target>
  <!-- ========================================== -->
  <!-- Getting all packaging outputs.             -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->
  <PropertyGroup>
    <GetPackagingOutputsDependsOn>
      $(GetPackagingOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </GetPackagingOutputsDependsOn>
  </PropertyGroup>
  <Target Name="GetPackagingOutputs" Returns="@(PackagingOutputs)" DependsOnTargets="$(GetPackagingOutputsDependsOn)">
    <CallTarget Targets="BuiltProjectOutputGroup" Condition="'$(IncludeBuiltProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_BuiltProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="DebugSymbolsProjectOutputGroup" Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DebugSymbolsProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_DebugSymbolsProjectOutputGroupOutput.FinalOutputPath)">
        <OutputGroup>DebugSymbolsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="DocumentationProjectOutputGroup" Condition="'$(IncludeDocumentationProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DocumentationProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_DocumentationProjectOutputGroupOutput)">
        <OutputGroup>DocumentationProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SatelliteDllsProjectOutputGroup" Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SatelliteDllsProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SatelliteDllsProjectOutputGroupOutput)">
        <OutputGroup>SatelliteDllsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SourceFilesProjectOutputGroup" Condition="'$(IncludeSourceFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFilesProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SourceFilesProjectOutputGroupOutput)">
        <OutputGroup>SourceFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SGenFilesOutputGroup" Condition="'$(IncludeSGenFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SGenFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SGenFilesOutputGroupOutput)">
        <OutputGroup>SGenFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CopyLocalFilesOutputGroup" Condition="'$(IncludeCopyLocalFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyLocalFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="ComFilesOutputGroup" Condition="'$(IncludeComFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ComFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ComFilesOutputGroupOutput)">
        <OutputGroup>ComFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CopyWinmdArtifactsOutputGroup" Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyWinmdArtifactsOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyWinmdArtifactsOutputGroupOutput)">
        <OutputGroup>CopyWinmdArtifactsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <!-- If extension SDK contains both XAML and XBF files, do not package XBF files from SDK -->
      <_SDKRedistRedundantXBF Include="@(_SDKRedistOutputGroupOutput->'%(RootDir)%(Directory)%(Filename).xbf')" Condition="'%(Extension)'=='.xaml'" />
      <_SDKRedistOutputGroupOutput Remove="@(_SDKRedistRedundantXBF)" />
    </ItemGroup>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SDKRedistOutputGroupOutput)">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Remove="@(RemoveSdkFilesFromAppxPackage)" />
    </ItemGroup>
    <CallTarget Targets="PriFilesOutputGroup" Condition="'$(IncludePriFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_PriFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_PriFilesOutputGroupOutput)">
        <OutputGroup>PriFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="ContentFilesProjectOutputGroup" Condition="'$(IncludeContentFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ContentFilesProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ContentFilesProjectOutputGroupOutput)">
        <OutputGroup>ContentFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_ContentFilesProjectOutputGroupOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CustomOutputGroupForPackaging" Condition="'$(IncludeCustomOutputGroupForPackaging)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CustomOutputGroupForPackagingOutput" />
    </CallTarget>
    <ItemGroup Condition="'$(DisableEmbeddedXbf)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_CustomOutputGroupForPackagingOutput Remove="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'" />
    </ItemGroup>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' != '.xbf'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' != 'true'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' == 'true'">
        <OutputGroup>EmbedOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <ExpandPayloadDirectories Inputs="@(_PackagingOutputsUnexpanded)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsExpanded" />
    </ExpandPayloadDirectories>
    <CallTarget Targets="GetResolvedSDKReferences" Condition="'$(IncludeGetResolvedSDKReferences)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetResolvedSDKReferencesOutputWithoutMetadata" />
    </CallTarget>
    <ItemGroup>
      <_GetResolvedSDKReferencesOutput Include="@(_GetResolvedSDKReferencesOutputWithoutMetadata)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_GetResolvedSDKReferencesOutput>
    </ItemGroup>
    <CallTarget Targets="_GetProjectArchitecture">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectArchitecture" />
    </CallTarget>
    <ItemGroup>
      <_ProjectArchitectureItem Include="@(_ProjectArchitecture)">
        <OutputGroup>_GetProjectArchitecture</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_ProjectArchitectureItem>
    </ItemGroup>
    <ItemGroup>
      <ProjectPriFile Include="$(ProjectPriFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <ProjectPriUploadFile Include="$(ProjectPriUploadFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriUploadFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriUploadFile>
    </ItemGroup>
    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">true</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">false</_ContinueOnError>
    </PropertyGroup>
    <MSBuild Projects="@(ProjectReferenceWithConfiguration)" Targets="GetPackagingOutputs" BuildInParallel="$(BuildInParallel)" Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)" Condition="'@(ProjectReferenceWithConfiguration)' != ''&#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true' &#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'" ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackagingOutputsFromOtherProjects" />
    </MSBuild>
    <ItemGroup>
      <PackagingOutputs Include="@(ProjectPriFile)" />
      <PackagingOutputs Include="@(_PackagingOutputsExpanded)" />
      <PackagingOutputs Include="@(_GetResolvedSDKReferencesOutput)" />
      <PackagingOutputs Include="@(_PackagingOutputsFromOtherProjects)" />
      <PackagingOutputs Include="@(_ProjectArchitectureItem)" />
    </ItemGroup>
    <Message Text="$(ProjectName) : %(PackagingOutputs.ProjectName).%(PackagingOutputs.OutputGroup) : %(PackagingOutputs.Identity) -&gt; %(PackagingOutputs.TargetPath)" />
  </Target>
  <!-- ============================== -->
  <!-- Getting package architecture.  -->
  <!-- ============================== -->
  <PropertyGroup>
    <_GetPackagePropertiesDependsOn>
      $(_GetPackagePropertiesDependsOn);
      _GetProjectArchitecture;
      _GetRecursiveProjectArchitecture;
      _GetPackageArchitecture;
      _GetDefaultResourceLanguage;
      _CalculateAppxBundleProperties;
    </_GetPackagePropertiesDependsOn>
  </PropertyGroup>
  <!-- Gets some package properties. -->
  <Target Name="_GetPackageProperties" Condition="'$(AppxGetPackagePropertiesEnabled)' == 'true'" DependsOnTargets="$(_GetPackagePropertiesDependsOn)" />
  <!-- Extract Project Architecture from the payload -->
  <Target Name="_GetRecursiveProjectArchitecture">
    <ItemGroup>
      <_RecursiveProjectArchitecture Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == '_GetProjectArchitecture'" />
      <_RecursiveProjectArchitecture Remove="@(_RecursiveProjectArchitecture)" Condition="'%(ProjectName)' == '$(ProjectName)'" />
    </ItemGroup>
  </Target>
  <!-- Gets package architecture. -->
  <Target Name="_GetPackageArchitecture">
    <GetPackageArchitecture Platform="$(Platform)" ProjectArchitecture="@(ProjectArchitecture)" RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)">
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </GetPackageArchitecture>
  </Target>
  <!-- Gets default resource language for the package. -->
  <Target Name="_GetDefaultResourceLanguage">
    <GetDefaultResourceLanguage DefaultLanguage="$(DefaultLanguage)" SourceAppxManifest="@(SourceAppxManifest)">
      <Output TaskParameter="DefaultResourceLanguage" PropertyName="DefaultResourceLanguage" />
    </GetDefaultResourceLanguage>
  </Target>
  <Target Name="_CalculateAppxBundleProperties" Condition="'$(AppxBundle)' != 'Never'">
    <PropertyGroup>
      <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''">$(PackageArchitecture)</AppxBundlePlatforms>
    </PropertyGroup>
    <GetAppxBundlePlatforms Input="$(AppxBundlePlatforms)">
      <Output TaskParameter="Platforms" ItemName="AppxBundlePlatform" />
      <Output TaskParameter="Last" PropertyName="AppxBundleLastPlatform" />
    </GetAppxBundlePlatforms>
    <ItemGroup>
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' == 'neutral'" Include="@(AppxBundlePlatform -> 'AnyCPU')" />
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' != 'neutral'" Include="@(AppxBundlePlatform)" />
    </ItemGroup>
    <PropertyGroup>
      <_AppxBundlePlatformsForNamingIntermediate>@(AppxBundlePlatformWithAnyCPU)</_AppxBundlePlatformsForNamingIntermediate>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundlePlatformsForNaming>$(_AppxBundlePlatformsForNamingIntermediate.Replace(';','_'))</AppxBundlePlatformsForNaming>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleProducingPlatform>
      <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleResourcePacksProducingPlatform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true' &#xD;&#xA;                              and '$(BuildingInsideVisualStudio)' == 'true'&#xD;&#xA;                              and  $(AppxBundlePlatformsForNaming.Contains('_'))">
      <AppxPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxPackageDirInProjectDir)</AppxPackageDir>
      <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true' &#xD;&#xA;                              and '$(BuildingInsideVisualStudio)' == 'true'&#xD;&#xA;                              and  $(AppxBundlePlatformsForNaming.Contains('_'))&#xD;&#xA;                              and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxUploadPackageDirInProjectDir)</AppxUploadPackageDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundlePlatformSpecificArtifactsListPath>$(PlatformSpecificBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificArtifactsListPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxBundlePlatformSpecificUploadArtifactsListPath>$(PlatformSpecificUploadBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificUploadArtifactsListPath>
    </PropertyGroup>
  </Target>
  <!-- ====================== -->
  <!-- Project output groups. -->
  <!-- ====================== -->
  <!-- Targets that all output groups defined in this targets depends on. -->
  <PropertyGroup>
    <AllOutputGroupsDependsOn>
      $(AllOutputGroupsDependsOn)
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </AllOutputGroupsDependsOn>
  </PropertyGroup>
  <!-- ======================================= -->
  <!-- Output group including CopyLocal files. -->
  <!-- ======================================= -->
  <PropertyGroup>
    <CopyLocalFilesOutputGroupDependsOn>
      $(CopyLocalFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyLocalFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="CopyLocalFilesOutputGroup" DependsOnTargets="$(CopyLocalFilesOutputGroupDependsOn)" Returns="@(CopyLocalFilesOutputGroupOutput)">
    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml' or '$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' == 'true'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>
    <!-- In case of Winmd files, we may not get implementation -->
    <!-- file as separate CopyLocal file (if exist), so we are -->
    <!-- extracting it here.                                   -->
    <ItemGroup>
      <_WinmdWithImplementation Include="@(CopyLocalFilesOutputGroupOutput)" Condition="'%(CopyLocalFilesOutputGroupOutput.Extension)' == '.winmd' &#xD;&#xA;                       AND '%(CopyLocalFilesOutputGroupOutput.Filename)' != 'platform'&#xD;&#xA;                       AND '%(CopyLocalFilesOutputGroupOutput.Implementation)' != ''" />
      <!-- Determine if any existing copy-local item has already -->
      <!-- satisfied the implementation                          -->
      <_WinmdWithImplementationTargetPath Include="@(_WinmdWithImplementation->'%(DestinationSubDirectory)%(Implementation)')">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_WinmdWithImplementationTargetPath>
      <_CopyLocalFilesOutputGroupOutputTargetPath Include="@(CopyLocalFilesOutputGroupOutput->'%(TargetPath)')" />
      <!-- intersect on targetpath -->
      <_WinmdSatifiedImplementation Include="@(_WinmdWithImplementationTargetPath)" Condition="'@(_WinmdWithImplementationTargetPath)' == '@(_CopyLocalFilesOutputGroupOutputTargetPath)' AND '%(Identity)' != ''" />
      <_WinmdWithImplementation Remove="@(_WinmdSatifiedImplementation->'%(OriginalItemSpec)')" />
    </ItemGroup>
    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)">
        <TargetPath>%(_WinmdWithImplementation.DestinationSubDirectory)%(_WinmdWithImplementation.Implementation)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- =========================================== -->
  <!-- Output group including COM reference files. -->
  <!-- =========================================== -->
  <PropertyGroup>
    <ComFilesOutputGroupDependsOn>
      $(ComFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </ComFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ComFilesOutputGroup" DependsOnTargets="$(ComFilesOutputGroupDependsOn)" Returns="@(ComFilesOutputGroupOutputs)">
    <ItemGroup>
      <ComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)">
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)">
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(NativeReferenceFile)">
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
    </ItemGroup>
  </Target>
  <!-- ============================================ -->
  <!-- Output group including Winmd artifact files. -->
  <!-- ============================================ -->
  <PropertyGroup>
    <CopyWinmdArtifactsOutputGroupDependsOn>
      $(CopyWinmdArtifactsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyWinmdArtifactsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="CopyWinmdArtifactsOutputGroup" DependsOnTargets="$(CopyWinmdArtifactsOutputGroupDependsOn)" Returns="@(CopyWinmdArtifactsOutputGroupOutputs)">
    <ItemGroup>
      <CopyWinmdArtifactsOutputGroupOutputs Include="@(FinalWinmdExpArtifacts ->'%(FullPath)')">
        <TargetPath>%(FinalWinmdExpArtifacts.DestinationSubDirectory)%(FinalWinmdExpArtifacts.Filename)%(FinalWinmdExpArtifacts.Extension)</TargetPath>
      </CopyWinmdArtifactsOutputGroupOutputs>
    </ItemGroup>
  </Target>
  <!-- ===================== -->
  <!-- Prepare layout target -->
  <!-- ===================== -->
  <PropertyGroup>
    <PrepareLayoutDependsOn>
      $(PrepareLayoutDependsOn);
      BeforePrepareLayout;
      _PrepareLayout;
      AfterPrepareLayout
    </PrepareLayoutDependsOn>
  </PropertyGroup>
  <!-- Prepares layout for debbuging/launching. -->
  <Target Name="PrepareLayout" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(PrepareLayoutDependsOn)" />
  <!-- Implement BeforePrepareLayout to influence final APPX layout recipe content.                          -->
  <!-- Here one can specify these additional items:                                                          -->
  <!-- (TODO: final extensibility items list and names - depending how much InternalPrepareLayout recognize) -->
  <!--                                                                                                       -->
  <!--    @(AppxAdditionalPackageContent)                                                                    -->
  <!--    @(AppxAdditionalSDKDependencies)                                                                   -->
  <!--    @(AppxAdditionalPRI)                                                                               -->
  <!--    @(AppxAdditionalWinmd)                                                                             -->
  <!--                                                                                                       -->
  <Target Name="BeforePrepareLayout" />
  <!-- Internal prepare layout target. -->
  <Target Name="_PrepareLayout" Inputs="$(MSBuildAllProjects);$(AppxPackageRecipe)" Outputs="$(FinalAppxPackageRecipe)">
    <!-- TODO: PRI and Winmd merge steps will be moved here -->
    <Copy UseHardlinksIfPossible="false" SourceFiles="$(AppxPackageRecipe)" DestinationFiles="$(FinalAppxPackageRecipe)" />
  </Target>
  <!-- Implement AfterPrepareLayout if needed to modify layout in more custom way. -->
  <!-- Here one can do arbitraty changes to $(FinalAppxPackageRecipe)              -->
  <Target Name="AfterPrepareLayout" />
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonTargets)" Condition="'$(CustomAfterMicrosoftCommonTargets)' != '' and Exists('$(CustomAfterMicrosoftCommonTargets)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.Net.CoreRuntime.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetfxCoreRuntimeTargets Condition="'$(NetfxCoreRuntimeTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\.NetNative\Microsoft.Net.CoreRuntime.targets</NetfxCoreRuntimeTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetfxCoreRuntimeTargets)" Condition="exists('$(NetfxCoreRuntimeTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\.NetNative\Microsoft.Net.CoreRuntime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Provides a default target platform for finding the ilc.exe version when
       the project is configured to AnyCPU -->
  <PropertyGroup>
    <_PlatformTargetForCoreRuntime Condition="'$(PlatformTarget)'!='AnyCPU'">$(PlatformTarget)</_PlatformTargetForCoreRuntime>
    <_PlatformTargetForCoreRuntime Condition="'$(PlatformTarget)'=='AnyCPU'">x86</_PlatformTargetForCoreRuntime>
  </PropertyGroup>
  <!-- 
       _TargetsCoreRuntime is one of the main flags that decides whether the toolchain needs to kick-in. It implies:
       - The feature must be turned on (EnableCoreRuntime == true)
       - This is a UAP app (including those that are pure C++ or JS) 
       - .NetNativeToolchain is not going to be used (i.e.: the default debug configuration)

       The second flag will narrow the condition further to UAP apps that has some managed code in their dependency closure.
       (See _AppContainsManagedCodeInItsClosure)

       This flag (_TargetsCoreRuntime) is also being consumed by project system to decide which debugger guid needs to be used,
       hence if you intend to rename this flag make sure that project system is also updated
  -->
  <PropertyGroup Condition="'$(EnableCoreRuntime)' == 'true' and '$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP' and '$(UseDotNetNativeToolchain)' != 'true'">
    <_TargetsCoreRuntime>true</_TargetsCoreRuntime>
  </PropertyGroup>
  <PropertyGroup>
    <_CoreRuntimeMSBuildTaskAssembly>$(MSBuildThisFileDirectory)\Microsoft.Build.Net.CoreRuntimeTask.dll</_CoreRuntimeMSBuildTaskAssembly>
    <_AppxMSBuildToolsPath Condition="'$(_AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</_AppxMSBuildToolsPath>
    <_AppxMSBuildTaskAssembly Condition="'$(_AppxMSBuildTaskAssembly)' == ''">$(_AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</_AppxMSBuildTaskAssembly>
    <CoreRuntimeSDKName>Microsoft.NET.CoreRuntime, Version=1.0</CoreRuntimeSDKName>
    <VCLibs14SDKName>Microsoft.VCLibs, Version=14.0</VCLibs14SDKName>
  </PropertyGroup>
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.WireUpCoreRuntime" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.MergePriConfigTask" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.MergeResWFilesTask" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.ResourceHandlingTask" />
  <UsingTask AssemblyFile="$(_AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <!-- Adds a <build:Item> tag for OptimizingToolset and TargetRuntime properties
       WireUpCoreRuntime needs these metadata -->
  <ItemGroup Condition="'$(_TargetsCoreRuntime)'=='true'">
    <AppxManifestMetadata Include="OptimizingToolset">
      <Value>None</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="TargetRuntime" Condition="'$(TargetRuntime)'!=''">
      <Value>$(TargetRuntime)</Value>
    </AppxManifestMetadata>
  </ItemGroup>
  <Target Name="ComputeWireUpCoreRuntimeGates" AfterTargets="AfterGenerateAppxManifest">
    <!-- 
         _AppContainsManagedCodeInItsClosure is going to be used as a gate to invoking the toolchain. As name suggests, 
         it implies that the app or one of the dependencies in its closure has managed code in it.

         ASSUMPTION: In deciding whether an unmanaged app has a managed dependency we'll defer to the computation of 
         whether UnionWinMD needs to be included in the PackagingOutputs or not. 
         (See the target _AddUnionWinmd in Microsoft.AppxPackage.Targets)
         Briefly, UnionWinMD is going to be included if any of the winmds that the app is referencing is managed. 
         So existance of UnionWinMD is being used as an indicator to existance of managed code. 
         This way the cost of computing managed dependency is avoided. 
    -->
    <ItemGroup>
      <_UnionMetadataWinMD Include="@(PackagingOutputs)" Condition="'%(Identity)' == '$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed' or '@(_UnionMetadataWinMD)' != ''">
      <_AppContainsManagedCodeInItsClosure>true</_AppContainsManagedCodeInItsClosure>
    </PropertyGroup>
    <!--
         WireUpCoreRuntimeGates is the property that ultimately controls triggering the toolchain. It implies:
         - The feature must be turned on (EnableCoreRuntime == true)
         - This is a UAP app that has some managed code in its dependency closure
         - .NetNativeToolchain is not going to be used (i.e.: the default debug configuration)
    -->
    <PropertyGroup Condition="'$(_TargetsCoreRuntime)' == 'true' and '$(_AppContainsManagedCodeInItsClosure)' == 'true'">
      <WireUpCoreRuntimeGates>Satisfied</WireUpCoreRuntimeGates>
    </PropertyGroup>
  </Target>
  <Target Name="ComputeWireUpCoreRuntimeParameters" DependsOnTargets="ComputeWireUpCoreRuntimeGates" Condition="'$(WireUpCoreRuntimeGates)'=='Satisfied'">
    <!-- Compute the input/output location of the WireUpCoreRuntime-->
    <PropertyGroup Condition="'$(WireUpCoreRuntimeOutputPath)'==''">
      <WireUpCoreRuntimeOutputPath>$(OutputPath)Core\</WireUpCoreRuntimeOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(WireUpCoreRuntimeOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_WireUpCoreRuntimeOutputPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup Condition="'$(WireUpCoreRuntimeInputPath)'==''">
      <WireUpCoreRuntimeInputPath>$(IntermediateOutputPath)Core\</WireUpCoreRuntimeInputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(WireUpCoreRuntimeInputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_WireUpCoreRuntimeInputPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup>
      <_WireUpCoreRuntimeExitCode>0</_WireUpCoreRuntimeExitCode>
      <_WireUpCoreRuntimeTaskExecuted>false</_WireUpCoreRuntimeTaskExecuted>
    </PropertyGroup>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ItemGroup>
      <DependencySDKs Include="$(CoreRuntimeSDKName)" />
      <DependencySDKs Include="$(VCLibs14SDKName)" />
      <!--UWPShim is built against dev14 CRT-->
    </ItemGroup>
    <ResolveSDKReference SDKReferences="@(DependencySDKs)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" ProjectName="$(ProjectName)" InstalledSDKs="@(InstalledSDKLocations)">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedDependencySDKs" />
    </ResolveSDKReference>
    <ItemGroup>
      <CoreRuntimeSDK Include="@(ResolvedDependencySDKs)" Condition="'%(ResolvedDependencySDKs.SDKName)' == '$(CoreRuntimeSDKName)'" />
    </ItemGroup>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(ResolvedDependencySDKs)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkPackageDependencies" />
    </GetFrameworkSdkPackages>
    <ItemGroup>
      <FrameworkPackagesForTargetArchitecture Include="@(FrameworkPackageDependencies)" Condition="'%(Architecture)' == '$(_PlatformTargetForCoreRuntime)'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by WireUpCoreRuntime -->
      <_TransformedAppxManifestXmlFile>$(_WireUpCoreRuntimeOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>
      <_TransformedProjectPriFullPath>$(_WireUpCoreRuntimeOutputPath)$(ProjectPriFileName)</_TransformedProjectPriFullPath>
      <CoreRuntimeSDKLocation>%(CoreRuntimeSDK.Identity)</CoreRuntimeSDKLocation>
    </PropertyGroup>
  </Target>
  <Target Name="_GetLibrariesToGeneratePrisForUWPApps" BeforeTargets="_GeneratePrisForPortableLibraries" Condition="'$(TargetPlatformIdentifier)'=='UAP'">
    <ItemGroup>
      <_FxLibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="$(IntermediateOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ResWOutputFullPath" />
    </ConvertToAbsolutePath>
    <ResourceHandlingTask AssemblyList="@(_FxLibrariesUnfiltered)" OutResWPath="$(ResWOutputFullPath)" StateFile="$(ResWOutputFullPath.TrimEnd('\'))\ResourceHandlingTask.state">
      <!-- 
              Explicitly using CreatedResWFiles and _LibrariesUnfiltered item group
              names because we are feeding them into the existing item groups that are 
              used as part of _GeneratePrisForPortableLibraries.
          -->
      <Output TaskParameter="ReswFileList" ItemName="CreatedResWFiles" />
      <Output TaskParameter="UnprocessedAssemblyList" ItemName="_LibrariesUnfiltered" />
    </ResourceHandlingTask>
    <ItemGroup>
      <FileWrites Include="$(ResWOutputFullPath.TrimEnd('\'))\ResourceHandlingTask.state" />
      <FileWrites Include="@(CreatedResWFiles)" />
    </ItemGroup>
  </Target>
  <Target Name="PrepareWireUpCoreRuntimeInputFolder" Inputs="@(AppxPackagePayload);@(FinalAppxManifest);@(MSBuildAllProjects)" Outputs="@(AppxPackagePayload -> '$(_WireUpCoreRuntimeInputPath)%(TargetPath)');@(FinalAppxManifest -> '$(_WireUpCoreRuntimeInputPath)%(Filename)%(Extension)')" DependsOnTargets="ComputeWireUpCoreRuntimeParameters" Condition="'$(WireUpCoreRuntimeGates)'=='Satisfied'">
    <!-- The appx package payload is the input to WireUpCoreRuntime. Copy them to WireUpCoreRuntime input path -->
    <ItemGroup>
      <_WireUpCoreRuntimeInputPayload Include="@(AppxPackagePayload->'$(_WireUpCoreRuntimeInputPath)%(TargetPath)')" />
    </ItemGroup>
    <!-- Find app-local Windows.winmd if it exists -->
    <ItemGroup>
      <AppLocalMetadataFile Include="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'WinMetadata\Windows.winmd'" />
    </ItemGroup>
    <Copy SourceFiles="@(AppxPackagePayload)" DestinationFiles="@(_WireUpCoreRuntimeInputPayload)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- AppxManifest is not part of the AppxPackagePayload. We need to copy it separately -->
    <Copy SourceFiles="@(FinalAppxManifest)" DestinationFolder="$(_WireUpCoreRuntimeInputPath)" Condition="Exists('%(FullPath)')" />
  </Target>
  <!-- We will always inject the CLR from the framework SDK, so remove it if it was contributed through NuGet -->
  <Target Name="FilterCoreRuntimePayloadFromNuGet" BeforeTargets="_CopyFilesMarkedCopyLocal" DependsOnTargets="ResolveNuGetPackageAssets" Condition="'$(ResolveNuGetPackages)' == 'true' AND '$(_TargetsCoreRuntime)' == 'true'">
    <PropertyGroup>
      <_CoreRuntimePackageId Condition="'%(ReferenceCopyLocalPaths.FileName)%(ReferenceCopyLocalPaths.Extension)' == 'mscorlib.dll' OR '%(ReferenceCopyLocalPaths.FileName)%(ReferenceCopyLocalPaths.Extension)' == 'mscorlib.ni.dll'">%(ReferenceCopyLocalPaths.NuGetPackageId)</_CoreRuntimePackageId>
    </PropertyGroup>
    <ItemGroup>
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'$(UseAppLocalCoreCLR)' != 'true' AND '%(ReferenceCopyLocalPaths.NuGetPackageId)' == '$(_CoreRuntimePackageId)' AND '$(_CoreRuntimePackageId)' != ''" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeInputsForInjectingAppLocalNetFX" Returns="@(AppLocalFrameworkLibsFiltered)" Condition="'$(EnableAppLocalFxWorkaround)' == 'true'">
    <ItemGroup>
      <AppLocalFrameworkLibsUnfiltered Include="$(CoreRuntimeSDKLocation)AppLocalFramework\Neutral\*">
        <IsIL>true</IsIL>
      </AppLocalFrameworkLibsUnfiltered>
      <AppLocalFrameworkLibsUnfiltered Include="$(CoreRuntimeSDKLocation)AppLocalFramework\$(_PlatformTargetForCoreRuntime)\*">
        <IsIL>false</IsIL>
      </AppLocalFrameworkLibsUnfiltered>
      <!-- Exclude the framework libs that app already has. We don't want to overwrite them -->
      <AppLocalFrameworkLibsFiltered Include="@(AppLocalFrameworkLibsUnfiltered)" Condition="!Exists('$(_WireUpCoreRuntimeInputPath)%(Filename)%(Extension)')" />
    </ItemGroup>
  </Target>
  <Target Name="InjectAppLocalNetFX" Returns="@(AppLocalFrameworkLibs)" Condition="'$(EnableAppLocalFxWorkaround)' == 'true'">
    <CallTarget Targets="ComputeInputsForInjectingAppLocalNetFX">
      <Output TaskParameter="TargetOutputs" ItemName="AppLocalFrameworkLibsFiltered" />
    </CallTarget>
    <Copy SourceFiles="@(AppLocalFrameworkLibsFiltered)" DestinationFolder="$(_WireUpCoreRuntimeOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" Condition="'$(EnableAppLocalFxWorkaround)' == 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="AppLocalFrameworkLibs" />
    </Copy>
    <ItemGroup>
      <FileWrites Include="@(AppLocalFrameworkLibs)" />
    </ItemGroup>
  </Target>
  <Target Name="InjectAppLocalNetFXAndUpdateResources" Condition="'$(EnableAppLocalFxWorkaround)' == 'true'">
    <CallTarget Targets="InjectAppLocalNetFX">
      <Output TaskParameter="TargetOutputs" ItemName="AppLocalFrameworkLibs" />
    </CallTarget>
    <ItemGroup>
      <AppLocalNetFXIL Include="@(AppLocalFrameworkLibs)" Condition="'%(IsIL)'=='true'" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="$(IntermediateOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AppLocalNetFXResourcesRootFullPath" />
    </ConvertToAbsolutePath>
    <MakeDir Directories="$(AppLocalNetFXResourcesRootFullPath)" />
    <ResourceHandlingTask AssemblyList="@(AppLocalNetFXIL)" OutResWPath="$(AppLocalNetFXResourcesRootFullPath)">
      <Output TaskParameter="ReswFileList" ItemName="CreatedResWFilesOfAppLocalNetFX" />
    </ResourceHandlingTask>
    <Message Importance="low" Text="Created resource files: @(CreatedResWFilesOfAppLocalNetFX)" />
    <ItemGroup>
      <FileWrites Include="$(CreatedResWFilesOfAppLocalNetFX)" />
    </ItemGroup>
    <PropertyGroup>
      <LayoutsResfilesFile>$(AppLocalNetFXResourcesRootFullPath)\empty.layout.resfiles</LayoutsResfilesFile>
      <AppLocalNetFXResourcesResFilesPath>$(AppLocalNetFXResourcesRootFullPath)\applocalnetfxresources.resfiles</AppLocalNetFXResourcesResFilesPath>
      <PriResfilesFile>$(AppLocalNetFXResourcesRootFullPath)\empty.pri.resfiles</PriResfilesFile>
      <AppLocalNetFXPriConfigFilePath>$(AppLocalNetFXResourcesRootFullPath.TrimEnd('\'))\priconfig.netfx.xml</AppLocalNetFXPriConfigFilePath>
      <MergedResourcePriFile>$(_WireUpCoreRuntimeOutputPath.TrimEnd('\'))\resources.pri</MergedResourcePriFile>
    </PropertyGroup>
    <!-- Create the .resfiles for applocal netfx resources -->
    <WriteLinesToFile File="$(AppLocalNetFXResourcesResFilesPath)" Lines="@(CreatedResWFilesOfAppLocalNetFX)" Overwrite="true" />
    <Touch Files="$(LayoutsResfilesFile)" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
    <Touch Files="$(PriResfilesFile)" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
    <ItemGroup>
      <FileWrites Include="$(AppLocalNetFXResourcesResFilesPath)" />
      <FileWrites Include="$(AppLocalNetFXPriConfigFilePath)" />
    </ItemGroup>
    <CreatePriConfigXmlForFullIndex LayoutResfilesPath="$(LayoutsResfilesFile)" ResourcesResfilesPath="$(AppLocalNetFXResourcesResFilesPath)" PriResfilesPath="$(PriResfilesFile)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" PriConfigXmlPath="$(AppLocalNetFXPriConfigFilePath)" />
    <MergePriConfigTask Condition="Exists('$(_PriConfigXmlPath)')" AppPriConfig="$(_PriConfigXmlPath)" CustomPriConfig="$(AppLocalNetFXPriConfigFilePath)" MergedPriConfig="$(AppLocalNetFXPriConfigFilePath)" />
    <PropertyGroup>
      <MakePriArgs>$(MakePriArgs) versioned</MakePriArgs>
      <MakePriArgs>$(MakePriArgs) /pr "$(MSBuildProjectDirectory.TrimEnd('\'))"</MakePriArgs>
      <MakePriArgs>$(MakePriArgs) /cf "$(AppLocalNetFXPriConfigFilePath)" </MakePriArgs>
      <MakePriArgs>$(MakePriArgs) /of "$(MergedResourcePriFile)"</MakePriArgs>
      <MakePriArgs>$(MakePriArgs) /o </MakePriArgs>
      <MakePriArgs>$(MakePriArgs) /if "$(ProjectPriFullPath)"</MakePriArgs>
      <MakePriCmd>"$(MakePriExeFullPath)" $(MakePriArgs)</MakePriCmd>
    </PropertyGroup>
    <Exec Command="$(MakePriCmd)" StandardOutputImportance="low" />
    <ItemGroup>
      <FileWrites Include="$(MergedResourcePriFile)" />
    </ItemGroup>
  </Target>
  <!-- Wire up the CoreRuntime -->
  <Target Name="_WireUpCoreRuntime" Inputs="@(_WireUpCoreRuntimeInputPayload);@(_WireUpCoreRuntimeInputAppxManifest);@(MSBuildAllProjects)" Outputs="@(_WireUpCoreRuntimeInputPayload -> '$(_WireUpCoreRuntimeOutputPath)%(TargetPath)');@(_WireUpCoreRuntimeInputAppxManifest -> '$(_WireUpCoreRuntimeOutputPath)%(Filename)%(Extension)')" DependsOnTargets="PrepareWireUpCoreRuntimeInputFolder" AfterTargets="ComputeWireUpCoreRuntimeGates" Condition="'$(WireUpCoreRuntimeGates)'=='Satisfied'">
    <!-- Delete existing transformed file -->
    <Delete Files="$(_TransformedAppxManifestXmlFile)" />
    <CreateProperty Value="true">
      <Output PropertyName="_WireUpCoreRuntimeTaskExecuted" TaskParameter="ValueSetByTask" />
    </CreateProperty>
    <WireUpCoreRuntime AppxPackageInput="$(_WireUpCoreRuntimeInputPath.TrimEnd('\'))" AppxPackageOutput="$(_WireUpCoreRuntimeOutputPath.TrimEnd('\'))" TargetRuntime="$(TargetRuntime)" TargetArch="$(_PlatformTargetForCoreRuntime)" FrameworkPackages="@(FrameworkPackagesForTargetArchitecture)" CoreRuntimeExtensionSDKLocation="$(CoreRuntimeSDKLocation)">
      <Output TaskParameter="ErrorCode" PropertyName="_WireUpCoreRuntimeExitCode" />
      <Output TaskParameter="FrameworkPackagesNeedsToBeDeployed" PropertyName="FrameworkPackagesNeedsToBeDeployed" />
    </WireUpCoreRuntime>
    <!-- Temporary workaround for missing app-local framework -->
    <CallTarget Targets="InjectAppLocalNetFXAndUpdateResources" Condition="'$(EnableAppLocalFxWorkaround)' == 'true'" />
    <!-- End of temporary workaround -->
    <!-- Record output files as file writes -->
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true'">
      <_WireUpCoreRuntimeOutputPayload Include="$(_WireUpCoreRuntimeOutputPath)**\*" />
      <!-- Exclude AppxManifest from the payload -->
      <_WireUpCoreRuntimeOutputPayload Remove="@(_WireUpCoreRuntimeOutputPayload)" Condition="'%(Filename)%(Extension)' == '$(_AppxManifestXmlFileName)'" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(_WireUpCoreRuntimeOutputPath)**\*" />
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true'">
      <FrameworkSdkPackage Include="@(FrameworkPackageDependencies)" Condition="'$(FrameworkPackagesNeedsToBeDeployed)'=='true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
      <AppxPackagePayload Include="@(_WireUpCoreRuntimeOutputPayload)">
        <TargetPath>%(RecursiveDir)%(Filename)%(Extension)</TargetPath>
      </AppxPackagePayload>
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true' and Exists('$(_TransformedAppxManifestXmlFile)')">
      <FinalAppxManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxManifest Include="$(_TransformedAppxManifestXmlFile)" />
      <FileWrites Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true' and Exists('$(_TransformedProjectPriFullPath)')">
      <ProjectPriFullPath>$(_TransformedProjectPriFullPath)</ProjectPriFullPath>
    </PropertyGroup>
    <PropertyGroup>
      <_WireUpCoreRuntimeMsg>WireUpCoreRuntime has encountered an error</_WireUpCoreRuntimeMsg>
    </PropertyGroup>
    <Error Condition="'$(_WireUpCoreRuntimeExitCode)' &gt; 0" Text="$(_WireUpCoreRuntimeMsg)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.Net.CoreRuntime.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.NetNative.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ProjectNTargets Condition="'$(ProjectNTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\.NetNative\Microsoft.NetNative.targets</ProjectNTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ProjectNTargets)" Condition="exists('$(ProjectNTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\.NetNative\Microsoft.NetNative.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
    <_ProjectNToolchainEnabled>true</_ProjectNToolchainEnabled>
  </PropertyGroup>
  <!-- Make sure WindowsSDK_LibraryPath is available to us so that MCG can load up the libs correctly -->
  <!--<Import Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props" Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props')" />-->
  <!--<Import Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props" Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props')" />-->
  <!-- Create list of supported platforms based on installed SDKs. 
       VS uses this list to alter UI behavior (project settings). -->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true'">
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\ARM\ilc')">ARM</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\x64\ilc')">$(AllowedPlatformsForProjectN),x64</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(MSBuildThisFileDirectory)\x86\ilc')">$(AllowedPlatformsForProjectN),x86</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN>$(AllowedPlatformsForProjectN.TrimStart(','))</AllowedPlatformsForProjectN>
  </PropertyGroup>
  <!-- Provides a default target platform for finding the ilc.exe version when
       the project is configured to AnyCPU -->
  <PropertyGroup>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'!='AnyCPU'">$(PlatformTarget)</_PlatformTargetForIlcVersion>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'=='AnyCPU'">x86</_PlatformTargetForIlcVersion>
  </PropertyGroup>
  <PropertyGroup>
    <SkipILCompilation>true</SkipILCompilation>
  </PropertyGroup>
  <!-- Adds a <build:Item> tag containing the version of ilc.exe in
       the output AppxManifest if the project is using ProjectN -->
  <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
    <AppxManifestMetadata Include="$(MSBuildExtensionsPath)\Microsoft\.NETNative\$(_PlatformTargetForIlcVersion)\ilc\ilc.exe" />
  </ItemGroup>
  <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
    <AppxManifestMetadata Include="OptimizingToolset">
      <Value>ilc.exe</Value>
    </AppxManifestMetadata>
  </ItemGroup>
  <!-- 
       Insert the SDK references for VCLibs and Microsoft.Net.Native.Runtime FW packages only if we have .NET Native enabled and the app contains managed code.
       "App contains managed code" is determined by checking the presence of System.Runtime.dll in the _IlcInputPath location since this assembly is deployed only when
       managed code exists in the app.
       
       Store relies on a similar logic as well.
       
       This ensures that we do not accidently insert the reference to Microsoft.Net.Native.Runtime package in purely native projects (e.g. C++ or JS).
   -->
  <Target Name="AddSDKReferences" Condition="'$(_ProjectNToolchainEnabled)'=='true' and Exists('$(_IlcInputPath)System.Runtime.dll')" AfterTargets="PrepareILCInputFolder">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ItemGroup>
      <!-- This naively hopes installed packages are compatible with us, but we will
           later insert a package dependency that has the actual required version. -->
      <NETNativeSDKs Include="Microsoft.NET.Native.Runtime.1.1, Version=1.1" />
      <NETNativeSDKs Include="Microsoft.VCLibs, Version=14.0" />
    </ItemGroup>
    <ResolveSDKReference SDKReferences="@(NETNativeSDKs)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" ProjectName="$(ProjectName)" InstalledSDKs="@(InstalledSDKLocations)">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedNETNativeSDKs" />
    </ResolveSDKReference>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(ResolvedNETNativeSDKs)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="NETNativeFrameworkPackages" />
    </GetFrameworkSdkPackages>
    <ItemGroup>
      <FrameworkSdkPackage Include="@(NETNativeFrameworkPackages)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeExtensionSDKReferencePaths">
    <ItemGroup>
      <!-- Don't include platform.winmd otherwise it will be added to Ilc's /externalReferencePath argument and loaded
           which will cause all sorts of problems because it is not a valid winmd file and it is not valid .NET 
           metadata. For example types don't derived from System.Object. 
      -->
      <ExtensionSDKReferencePath Include="@(ReferencePath-&gt;DirectoryName())" Condition="'%(ReferencePath.CopyLocal)' != 'true' and '%(ReferencePath.ResolvedFrom)' == 'GetSDKReferenceFiles' and '%(ReferencePath.Filename)%(ReferencePath.Extension)' != 'platform.winmd'" KeepDuplicates="false" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <_GatekeeperPlatformTarget>$(PlatformTarget)</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">x64</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">x86</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">arm</_GatekeeperPlatformTarget>
  </PropertyGroup>
  <Target Name="RunGatekeeper" AfterTargets="AfterGenerateAppxManifest" DependsOnTargets="ComputeExtensionSDKReferencePaths;PrepareILCInputFolder" Condition="('$(ProjectNProfileEnabled)' == 'true' and '$(EnableGateKeeperAnalysis)' == 'true') And Exists('$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc')">
    <ItemGroup>
      <_GatekeeperLibPath Include="@(ExtensionSDKReferencePath)" />
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\Facades" KeepDuplicates="false" />
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\IL" KeepDuplicates="false" />
      <_GatekeeperLibPath Include="$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\lib\Private" KeepDuplicates="false" />
      <_GatekeeperWinMDPath Condition="Exists('$(_IlcInputPath)WinMetadata\Windows.winmd')" Include="$(_IlcInputPath)WinMetadata\Windows.winmd" />
      <_GatekeeperWinMDPath Condition="'$(_GatekeeperWinMDPath)' == ''" Include="$(TargetPlatformWinMDLocation)\*.winmd" />
      <_GateKeeperWinMDFile Include="@(AppLocalMetadataFile)" />
    </ItemGroup>
    <PropertyGroup>
      <_GatekeeperCmd>"$(MSBuildThisFileDirectory)$(_GatekeeperPlatformTarget)\ilc\tools\Gatekeeper.exe"</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd) /In:"$(_IlcInputPath)</_GatekeeperCmd>
      <!-- We quote the input folder in case there are spaces in the path. 
           However, if the last character is '\', adding a quote after it 
           confuses command line parser. It thinks we are trying to escape 
           the quote and makes it part of the path, which causes Gatekeeper 
           to complain about an invalid character in the path. Let's add 
           one more '\' in this case.
      -->
      <_GatekeeperCmd Condition="$(_GatekeeperCmd.EndsWith('\'))">$(_GatekeeperCmd)\</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd)"</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd) /Lib:"@(_GatekeeperLibPath,'" /Lib:"')"</_GatekeeperCmd>
      <_GatekeeperCmd Condition="'$(_GatekeeperWinMDPath)' != ''">$(_GatekeeperCmd) /WinMD:"@(_GateKeeperWinMDPath,'" /WinMD:"')"</_GatekeeperCmd>
      <_GatekeeperCmd Condition="'$(ProjectNVSTelemetrySession)' != ''">$(_GatekeeperCmd) /VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)</_GatekeeperCmd>
      <_GatekeeperCmd>$(_GatekeeperCmd) /RdXmlPath:"$(MSBuildThisFileDirectory)LibraryXML"</_GatekeeperCmd>
    </PropertyGroup>
    <Exec Command="$(_GatekeeperCmd)">
      <Output TaskParameter="ExitCode" PropertyName="_GatekeeperExitCode" />
    </Exec>
  </Target>
  <UsingTask TaskName="ValidateRdXmlTask" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')" />
  <UsingTask TaskName="LoggerBasedExecTask" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')" />
  <UsingTask TaskName="IlcErrorTask" AssemblyFile="$(MSBuildThisFileDirectory)$(_PlatformTargetForIlcVersion)\ilc\ilc.exe" />
  <Target Name="ValidateRdXml" AfterTargets="AfterGenerateAppxManifest" BeforeTargets="BuildNativePackage" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')">
    <ItemGroup>
      <!-- Include runtime directives -->
      <RdXmlFiles Include="*.rd.xml" />
    </ItemGroup>
    <ValidateRdXmlTask Files="@(RdXmlFiles)" />
  </Target>
  <Target Name="CheckForAnyCPU">
    <IlcErrorTask Condition="'$(PlatformTarget)' == 'AnyCPU'" ResourceName="Error_AnyCPU" />
  </Target>
  <UsingTask TaskName="ComputeManagedBinaries" AssemblyFile="$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\ilc.exe" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')" />
  <Target Name="ComputeIlcParameters" DependsOnTargets="ComputeExtensionSDKReferencePaths">
    <!-- Compute the target location for ILC outputs -->
    <PropertyGroup Condition="'$(IlcOutputPath)'==''">
      <IlcOutputPath>$(OutputPath)ilc\</IlcOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcOutputPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup Condition="'$(IlcIntermediateRootPath)'==''">
      <IlcIntermediateRootPath>$(IntermediateOutputPath)ilc\</IlcIntermediateRootPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcIntermediateRootPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcIntermediateRootPath" />
    </ConvertToAbsolutePath>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <PropertyGroup>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</WindowsSdkPath>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$(_TargetPlatformSdkDir)</WindowsSdkPath>
    </PropertyGroup>
    <!-- Prepare ilc arguments. -->
    <PropertyGroup>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(WindowsSDK_LibraryPath)'!=''">$(WindowsSDK_LibraryPath)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='ARM' And '$(WindowsSDK_LibraryPath_arm)'!=''">$(WindowsSDK_LibraryPath_arm)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x86' And '$(WindowsSDK_LibraryPath_x86)'!=''">$(WindowsSDK_LibraryPath_x86)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x64' And '$(WindowsSDK_LibraryPath_x64)'!=''">$(WindowsSDK_LibraryPath_x64)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(_TargetPlatformSdkDir)')">$(_TargetPlatformSdkDir.TrimEnd('\'))</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\Lib\winv6.4\um')">$(TargetPlatformSdkPath)\Lib\winv6.4\um</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\lib\$(PlatformTarget)')">$(TargetPlatformSdkPath)\lib\$(PlatformTarget)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'==''">$(TargetPlatformSdkPath)\Lib\winv6.3\um</IlcTargetPlatformSdkLibPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcTargetPlatformSdkLibPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcTargetPlatformSdkLibPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup>
      <_IlcExitCode />
      <_IlcExePath>$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc\ilc.exe</_IlcExePath>
      <_IlcInputPath>$(_IlcIntermediateRootPath)in\</_IlcInputPath>
      <_IlcIntermediatePath>$(_IlcIntermediateRootPath)intermediate\</_IlcIntermediatePath>
      <_IlcVerbosity>normal</_IlcVerbosity>
      <_IlcKeepIntermediates>true</_IlcKeepIntermediates>
      <_IlcSuppressPDBWarnings>true</_IlcSuppressPDBWarnings>
      <_IlcBuildType Condition="'$(Optimize)'=='true'">ret</_IlcBuildType>
      <_IlcBuildType Condition="'$(Optimize)'!='true'">chk</_IlcBuildType>
      <_IlcExternalReferencePath>/externalReferencePath:"@(ExtensionSDKReferencePath,'" /externalReferencePath:"')"</_IlcExternalReferencePath>
    </PropertyGroup>
  </Target>
  <!-- The ILC input folder is created when .Net Native compilation is enabled, and when it isn't but we're running Gatekeeper.
       This ensures Gatekeeper is run on the same set of inputs as if .Net Native were enabled -->
  <Target Name="PrepareILCInputFolder" BeforeTargets="RunGatekeeper" AfterTargets="ValidateRdXml" DependsOnTargets="ComputeIlcParameters" Condition="'$(ProjectNProfileEnabled)' == 'true' and ('$(_ProjectNToolchainEnabled)' == 'true' or '$(EnableGateKeeperAnalysis)' == 'true')">
    <!-- Deploy managed appx package layout to _IlcInputPath -->
    <ItemGroup>
      <_IlcInputPayload Include="@(AppxPackagePayload->'$(_IlcInputPath)%(TargetPath)')" />
    </ItemGroup>
    <!-- 
         Sanitizing ILC input folder:
         When .net native is disabled (i.e. the default debug configuration), gatekeeper will populate this folder with CoreCLR related libraries.
         If user switches the configuration and enables .net native, the very same folder will be used as input to ILC.
         Then when user builds without doing a clean first, 
            - if there happens to be a file in AppxPackagePayload that already exists in this directory it'll be overwritten. However,
            - those files in this directory that doesn't exist in the AppxPackagePayload, such as CoreCLR specific files, will just stay. 
         The later will cause a failure in ILC later on.
         To prevent that we're removing any file from this directory that doesn't exist in AppxPackagePayload
    -->
    <ItemGroup>
      <_ResidualFilesInIlcInputPath Include="$(_IlcInputPath)**\*" />
      <_ResidualFilesInIlcInputPath Remove="@(_IlcInputPayload)" />
    </ItemGroup>
    <Delete Files="@(_ResidualFilesInIlcInputPath)" />
    <!-- Find app-local Windows.winmd if it exists -->
    <ItemGroup>
      <AppLocalMetadataFile Include="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'WinMetadata\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup>
      <AppLocalMetadataPath>%(AppLocalMetadataFile.RootDir)%(AppLocalMetadataFile.Directory)</AppLocalMetadataPath>
    </PropertyGroup>
    <Copy SourceFiles="@(AppxPackagePayload)" DestinationFiles="@(_IlcInputPayload)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Copy SourceFiles="@(FinalAppxManifest)" DestinationFolder="$(_IlcInputPath)" Condition="Exists('%(FullPath)')" />
    <!-- If an app-local Windows.winmd was found, we want to defer to it for platform metadata -->
    <PropertyGroup Condition="Exists('$(_IlcInputPath)WinMetadata\Windows.winmd')">
      <_TargetPlatformMetadataPath>$(_IlcInputPath)WinMetadata</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('@(UnionWinmdPath)')">
      <_TargetPlatformMetadataPath>$([System.IO.Path]::GetDirectoryName('%(UnionWinmdPath.FullPath)'))</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('$(TargetPlatformWinMDLocation)')">
      <_TargetPlatformMetadataPath>$(TargetPlatformWinMDLocation)</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <Error Condition="'$(_TargetPlatformMetadataPath)' == ''" Text="Could not find an existing platform WinMD location" />
  </Target>
  <Target Name="ComputeNativePackageInputsAndOutputs" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(MSBuildThisFileDirectory)$(PlatformTarget)\ilc')">
    <!-- 
      Inputs and outputs to ILC:

        Inputs:
          - Managed binaries (*.exe / *.dll / *.winmd)
          - Metadata directives (*.rd.xml)
          - Xaml roots logs (*.xr.xml)
          - Appxmanifest.xml

        Outputs:
          - Compiled native binaries
            - For managed apps: exename.exe, exename.dll
            - For hybrid apps: <PackageIdGuid>.exe, <PackageIdGuid>.dll
    -->
    <ComputeManagedBinaries InputFiles="@(AppxPackagePayload)" AppxManifest="$(FinalAppxManifestName)" OutputPath="$(_IlcOutputPath)">
      <Output TaskParameter="ManagedFiles" ItemName="ManagedAppxPackagePayload" />
      <Output TaskParameter="OutputDotNetNativeFiles" ItemName="BuildNativePackageOutputs" />
    </ComputeManagedBinaries>
    <ItemGroup>
      <!-- Runtime reflection directives affect types / metadata retained in compilation -->
      <BuildNativePackagesInputs Include="*.rd.xml" />
      <!-- Xaml roots are entrypoints into managed code and affect types / methods retained in compilation -->
      <BuildNativePackagesInputs Include="*.xr.xml" />
      <!-- ILC modifies the appx manifest -->
      <BuildNativePackagesInputs Include="$(FinalAppxManifestName)" />
      <!-- Include winmds and managed binaries -->
      <BuildNativePackagesInputs Include="@(ManagedAppxPackagePayload)" />
    </ItemGroup>
  </Target>
  <!-- 
    This target detects whether compilation of IL is required as part of BuildNativePackage.
    If all managed input assemblies are up to date with respect to output native binaries,
    this target will be skipped since it's up to date.  That allows ILC to run in a
    pass-through mode that copies all the non-code artifacts through to the output folder.
  -->
  <Target Name="BuildNativePackageCompilationRequired" AfterTargets="ValidateRdXml;RunGatekeeper" Condition="'$(_ProjectNToolchainEnabled)' == 'true'" DependsOnTargets="CheckForAnyCPU;ComputeNativePackageInputsAndOutputs" Inputs="@(BuildNativePackagesInputs)" Outputs="@(BuildNativePackageOutputs)">
    <CreateProperty Value="false">
      <Output PropertyName="SkipILCompilation" TaskParameter="ValueSetByTask" />
    </CreateProperty>
  </Target>
  <!-- Build native appx package. Runs after managed appx package payload is computed. -->
  <Target Name="BuildNativePackage" AfterTargets="ValidateRdXml;RunGatekeeper;BuildNativePackageCompilationRequired" Condition="'$(_ProjectNToolchainEnabled)' == 'true'" DependsOnTargets="CheckForAnyCPU;ComputeIlcParameters;">
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by ILC -->
      <_TransformedAppxManifestXmlFile>$(_IlcOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>
      <!-- ILC hardcodes resources.pri as the file name so we do the same here -->
      <_ProjectPriFileName>resources.pri</_ProjectPriFileName>
      <_TransformedProjectPriFullPath>$(_IlcOutputPath)$(_ProjectPriFileName)</_TransformedProjectPriFullPath>
    </PropertyGroup>
    <!-- Delete existing transformed file -->
    <Delete Condition="'$(SkipILCompilation)' != 'true'" Files="$(_TransformedAppxManifestXmlFile)" />
    <!-- Invoke ilc. -->
    <PropertyGroup>
      <FrameworkPathOverride Condition="$(FrameworkPathOverride) == ''">$(MSBuildExtensionsPath32)\..\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5.1</FrameworkPathOverride>
      <_IlcCmd>"$(_IlcExePath)"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /in:"$(_IlcInputPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /out:"$(_IlcOutputPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /intermediatespath:"$(_IlcIntermediatePath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /v:$(_IlcVerbosity)</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /keepintermediates:$(_IlcKeepIntermediates)</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /buildtype:$(_IlcBuildType)</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /exename:"$(TargetFileName)"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /makepripath:"$(MakePriExeFullPath)"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /appPriProjectRoot:"$(ProjectDir.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /rcpath:"$(WindowsSdkPath)\bin\x86\rc.exe"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /targetplatformsdklibpath:"$(_IlcTargetPlatformSdkLibPath)"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /targetplatformsdkmetadatapath:"$(_TargetPlatformMetadataPath)"</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /targetframeworkpath:"$(FrameworkPathOverride.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(_IlcExternalReferencePath)' != '/externalReferencePath:&quot;&quot;'">$(_IlcCmd) $(_IlcExternalReferencePath)</_IlcCmd>
      <_IlcCmd Condition="'$(ProjectNVSTelemetrySession)' != ''">$(_IlcCmd) /VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /RdXmlPath:"$(MSBuildThisFileDirectory)LibraryXML"</_IlcCmd>
      <_IlcCmd Condition="'$(_IlcSuppressPDBWarnings)'=='true'">$(_IlcCmd) /suppressPDBWarnings:$(_IlcSuppressPDBWarnings)</_IlcCmd>
      <_IlcCmd>$(_IlcCmd) /AllowNoManagedCode</_IlcCmd>
      <_IlcCmd Condition="'$(AppContextSwitches)' != ''">$(_IlcCmd) /AppContextSwitches:"$(AppContextSwitches)"</_IlcCmd>
      <_IlcCmd Condition="'$(SkipILCompilation)' == 'true'">$(_IlcCmd) /SkipILCompilation:$(SkipILCompilation)</_IlcCmd>
      <_IlcCmd Condition="'$(NetNativeReproPath)' != ''">$(_IlcCmd) /PackRepro:"$(NetNativeReproPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(NetNativePdbPath)' != ''">$(_IlcCmd) /PdbPath:"$(NetNativePdbPath.TrimEnd('\'))"</_IlcCmd>
      <_IlcCmd Condition="'$(EnableNetNativeDeveloperExperienceMode)'!=''">$(_IlcCmd) /developerExperience:$(EnableNetNativeDeveloperExperienceMode)</_IlcCmd>
      <_IlcCmd Condition="'$(UseNetNativeCustomFramework)' == 'true'">$(_IlcCmd) /UseCustomFramework</_IlcCmd>
      <!-- The IlcParameters property allows for debug scenarios where overriding one of the built-in switches
           might be desirable. It should always come last, since ILC treats command line parameters at the end
           of its command line as having higher precedence -->
      <_IlcCmd Condition="'$(IlcParameters)' != ''">$(_IlcCmd) $(IlcParameters)</_IlcCmd>
    </PropertyGroup>
    <LoggerBasedExecTask Command="$(_IlcCmd)" MessageLog="$(_IlcIntermediateRootPath)ilclog.csv">
      <Output TaskParameter="ExitCode" PropertyName="_IlcExitCode" />
    </LoggerBasedExecTask>
    <!-- Preserve generated C# files in the ilc package output -->
    <ItemGroup>
      <_IlcGeneratedSource Include="$(_IlcIntermediatePath)**\*.g.cs" />
    </ItemGroup>
    <Copy SourceFiles="@(_IlcGeneratedSource)" DestinationFolder="$(_IlcOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
    <!-- Record intermediate and output files as file writes. -->
    <ItemGroup>
      <_IlcIntermediatePayload Include="$(_IlcIntermediatePath)**\*" />
      <_IlcOutputPayload Include="$(_IlcOutputPath)**\*" />
      <!-- Do not include manifest file in the payload -->
      <_IlcOutputPayload Remove="@(_IlcOutputPayload)" Condition="'%(Filename)%(Extension)' == '$(_AppxManifestXmlFileName)'" />
      <FileWrites Include="@(_IlcIntermediatePayload)" />
      <FileWrites Include="@(_IlcOutputPayload)" />
    </ItemGroup>
    <!-- 
      Modify appx package payload so that the native package layout produced by ilc is used for deployment,
      and produce the payload for the appxupload so that Store can compile it. 
    -->
    <ItemGroup>
      <AppxUploadPackagePayload Include="@(AppxPackagePayload)" />
      <FinalAppxUploadManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxUploadManifest Include="$(_TransformedAppxManifestXmlFile)" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
      <AppxPackagePayload Include="@(_IlcOutputPayload)" Condition="'$(PlatformTarget)' != 'ARM' or '%(Extension)' != '.pdb'">
        <TargetPath>%(RecursiveDir)%(Filename)%(Extension)</TargetPath>
      </AppxPackagePayload>
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.g.cs" />
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.xr.xml" />
    </ItemGroup>
    <PropertyGroup>
      <ProjectPriUploadFullPath>$(ProjectPriFullPath)</ProjectPriUploadFullPath>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_TransformedAppxManifestXmlFile)')">
      <FinalAppxManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxManifest Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>
    <!-- 
      AppxPackage targets depend on ProjectPriFullPath being correctly set. In particular for AppxBundles 
      the _CreatePackageLayout_CalculateInputsAndOutputs target expects this property to be set to exactly what
      is contained in the AppxPackagePayload because it removes it and if the path doesn't exactly match it fails.
    -->
    <PropertyGroup Condition="Exists('$(_TransformedProjectPriFullPath)')">
      <ProjectPriFullPath>$(_TransformedProjectPriFullPath)</ProjectPriFullPath>
    </PropertyGroup>
    <OnError ExecuteTargets="LogIlcBehavioralDifference" />
  </Target>
  <Target Name="LogIlcBehavioralDifference">
    <PropertyGroup>
      <_IlcMinBehavioralExitCode>1400</_IlcMinBehavioralExitCode>
    </PropertyGroup>
    <IlcErrorTask Condition="'$(_IlcExitCode)' != '' and '$(_IlcExitCode)' &gt;= '$(_IlcMinBehavioralExitCode)'" ResourceName="Error_IlcBehavioralDifferences" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.NetNative.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.NuGet.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NuGetTargets Condition="'$(NuGetTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\NuGet\Microsoft.NuGet.targets</NuGetTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetTargets)" Condition="Exists('$(NuGetTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\NuGet\Microsoft.NuGet.targets
============================================================================================================================================
-->
  <UsingTask TaskName="Microsoft.NuGet.Build.Tasks.ResolveNuGetPackageAssets" AssemblyFile="Microsoft.NuGet.Build.Tasks.dll" />
  <PropertyGroup>
    <ProjectLockFile Condition="'$(ProjectLockFile)' == ''">project.lock.json</ProjectLockFile>
    <ResolveNuGetPackages Condition="'$(ResolveNuGetPackages)' == '' and '$(MSBuildProjectExtension)' != '.xproj'">true</ResolveNuGetPackages>
    <BaseNuGetRuntimeIdentifier Condition="'$(BaseNuGetRuntimeIdentifier)' == '' and '$(TargetPlatformIdentifier)' == 'UAP'">win10</BaseNuGetRuntimeIdentifier>
    <BaseNuGetRuntimeIdentifier Condition="'$(BaseNuGetRuntimeIdentifier)' == ''">win</BaseNuGetRuntimeIdentifier>
    <UseTargetPlatformAsNuGetTargetMoniker Condition="'$(UseTargetPlatformAsNuGetTargetMoniker)' == '' AND '$(TargetFrameworkMoniker)' == '.NETCore,Version=v5.0'">true</UseTargetPlatformAsNuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' == 'true'">$(TargetPlatformIdentifier),Version=v$([System.Version]::Parse('$(TargetPlatformMinVersion)').ToString(3))</NuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' != 'true'">$(TargetFrameworkMoniker)</NuGetTargetMoniker>
    <CopyNuGetImplementations Condition="'$(CopyNuGetImplementations)' == '' and '$(OutputType)' != 'library' and ('$(OutputType)' != 'winmdobj' or '$(AppxPackage)' == 'true')">true</CopyNuGetImplementations>
    <IncludeFrameworkReferencesFromNuGet Condition="'$(IncludeFrameworkReferencesFromNuGet)' == ''">true</IncludeFrameworkReferencesFromNuGet>
  </PropertyGroup>
  <!-- If a RuntimeIndentifier wasn't already specified, let's go generate it -->
  <PropertyGroup Condition="'$(RuntimeIndentifier)' == '' and '$(CopyNuGetImplementations)' == 'true'">
    <_NuGetRuntimeIdentifierWithoutAot>$(BaseNuGetRuntimeIdentifier)-$(PlatformTarget.ToLower())</_NuGetRuntimeIdentifierWithoutAot>
    <NuGetRuntimeIdentifier>$(_NuGetRuntimeIdentifierWithoutAot)</NuGetRuntimeIdentifier>
    <NuGetRuntimeIdentifier Condition="'$(UseDotNetNativeToolchain)' == 'true'">$(_NuGetRuntimeIdentifierWithoutAot)-aot</NuGetRuntimeIdentifier>
  </PropertyGroup>
  <ItemGroup>
    <!-- If we are resolving from project.lock.json, we need to consider any edit to it as something that forces a rebuild -->
    <CustomAdditionalCompileInputs Include="$(ProjectLockFile)" Condition="'$(ResolveNuGetPackages)' == 'true' and Exists('$(ProjectLockFile)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP'">
    <_NuGetTargetFallbackMoniker>UAP,Version=v10.0</_NuGetTargetFallbackMoniker>
    <ImplicitlyExpandTargetFramework>false</ImplicitlyExpandTargetFramework>
    <EnableAppLocalFXWorkaround>false</EnableAppLocalFXWorkaround>
    <UseNetNativeCustomFramework>true</UseNetNativeCustomFramework>
  </PropertyGroup>
  <!--
    ============================================================
                                        GetProjectsReferencingProjectJsonFiles
    ============================================================
  -->
  <Target Name="GetProjectsReferencingProjectJson" DependsOnTargets="_SplitProjectReferencesByFileExistence" Returns="@(_ProjectReferencingProjectJsonFile)">
    <ItemGroup Condition="'$(ResolveNuGetPackages)' == 'true'">
      <_ProjectReferencingProjectJsonFile Include="$(MSBuildProjectFullPath)">
        <ProjectReferences>@(ProjectReference)</ProjectReferences>
        <ProjectJson>$(MSBuildProjectDirectory)\project.json</ProjectJson>
      </_ProjectReferencingProjectJsonFile>
    </ItemGroup>
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetProjectsReferencingProjectJson" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferencingProjectJsonFile" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
                                        ResolveNuGetPackageAssets

    Resolve assets from consumed NuGet packages listed in the project.lock.json

        [OUT]
        @(Analyzer) - Paths to build-time diagnostic analyzers
        @(Reference) - Paths to build-time NuGet dependencies
        @(ReferenceCopyLocalPaths) - Paths to run-time dependencies to copy
    ============================================================
  -->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>$(ResolveAssemblyReferencesDependsOn);ResolveNuGetPackageAssets</ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <ResolveNuGetPackageAssetsDependsOn Condition="'$(ImplicitlyExpandTargetFramework)' == 'true'">$(ResolveNuGetPackageAssetsDependsOn);ImplicitlyExpandTargetFramework</ResolveNuGetPackageAssetsDependsOn>
  </PropertyGroup>
  <Target Name="ResolveNuGetPackageAssets" DependsOnTargets="$(ResolveNuGetPackageAssetsDependsOn)" Condition="'$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')">
    <ResolveNuGetPackageAssets AllowFallbackOnTargetSelection="$(DesignTimeBuild)" IncludeFrameworkReferences="$(IncludeFrameworkReferencesFromNuGet)" NuGetPackagesDirectory="$(NuGetPackagesDirectory)" RuntimeIdentifier="$(NuGetRuntimeIdentifier)" ProjectLanguage="$(Language)" ProjectLockFile="$(ProjectLockFile)" TargetMonikers="$(NuGetTargetMoniker);$(_NuGetTargetFallbackMoniker)">
      <Output TaskParameter="ResolvedAnalyzers" ItemName="Analyzer" />
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="ResolvedReferences" ItemName="_ReferencesFromNuGetPackages" />
      <Output TaskParameter="ReferencedPackages" ItemName="ReferencedNuGetPackages" />
    </ResolveNuGetPackageAssets>
    <ItemGroup>
      <!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
      <Reference Remove="@(_ReferencesFromNuGetPackages)" />
      <!-- Remove simple name references if we're directly providing a reference assembly to the compiler. For example,
           consider a project with an Reference Include="System", and some NuGet package is providing System.dll -->
      <Reference Remove="%(_ReferencesFromNuGetPackages.FileName)" />
      <!-- Remove simple name references that are already implicitly added -->
      <_ReferencesFromNuGetPackages Remove="%(ReferencePath.FileName)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
      <Reference Include="@(_ReferencesFromNuGetPackages)" />
    </ItemGroup>
    <PropertyGroup Condition=" '$(AutoUnifyAssemblyReferences)' == 'true' ">
      <!-- Normally Design Time Assembly Resolution (DTAR) won't consider these references.
           Put DTAR in a mode where it will prefer the output of RAR and unify. -->
      <DTARUseReferencesFromProject>true</DTARUseReferencesFromProject>
    </PropertyGroup>
  </Target>
  <Target Name="RuntimeImplementationProjectOutputGroup" Returns="@(RuntimeImplementationProjectOutputGroupOutput)" Condition="'$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')">
    <!-- This output group must contain the implementation assemblies for the host (i.e. design time) environment, not the
         target environment. Thus, we explicitly pass AheadOfTimeCompile = false -->
    <ResolveNuGetPackageAssets AllowFallbackOnTargetSelection="$(DesignTimeBuild)" NuGetPackagesDirectory="$(NuGetPackagesDirectory)" RuntimeIdentifier="$(_NuGetRuntimeIdentifierWithoutAot)" ProjectLanguage="$(Language)" ProjectLockFile="$(ProjectLockFile)" TargetMonikers="$(NuGetTargetMoniker);$(_NuGetTargetFallbackMoniker)">
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="NonAheadOfTimeRuntimeImplementations" />
    </ResolveNuGetPackageAssets>
    <ItemGroup>
      <RuntimeImplementationProjectOutputGroupOutput Include="%(NonAheadOfTimeRuntimeImplementations.Identity)">
        <FinalOutputPath>%(NonAheadOfTimeRuntimeImplementations.FullPath)</FinalOutputPath>
        <TargetPath>%(NonAheadOfTimeRuntimeImplementations.FullPath)</TargetPath>
      </RuntimeImplementationProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
            Framework injection into mixed-target applications
    ============================================================
  -->
  <PropertyGroup>
    <NuGetTargetFrameworkMonikerToInject Condition="'$(NuGetTargetFrameworkMonikerToInject)' == ''">.NETCore,Version=v5.0</NuGetTargetFrameworkMonikerToInject>
    <NuGetTargetMonikerToInject Condition="'$(NuGetTargetMonikerToInject)' == ''">.NETCore,Version=v5.0</NuGetTargetMonikerToInject>
  </PropertyGroup>
  <Target Name="ComputeNetCoreFrameworkInjectionParameters" BeforeTargets="BeforeGenerateProjectPriFile" DependsOnTargets="_AddUnionWinmd" Condition="'$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP'">
    <PropertyGroup>
      <_PackagingOutputsIncludesFramework Condition="'%(PackagingOutputs.FileName)%(PackagingOutputs.Extension)' == 'System.Runtime.dll'">true</_PackagingOutputsIncludesFramework>
      <_AppContainsManagedCodeForInjection Condition="'%(PackagingOutputs.Identity)' == '$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd'">true</_AppContainsManagedCodeForInjection>
    </PropertyGroup>
    <PropertyGroup>
      <_NetCoreFrameworkInjectionNeeded Condition="'$(_PackagingOutputsIncludesFramework)' != 'true' and '$(_AppContainsManagedCodeForInjection)' == 'true'">true</_NetCoreFrameworkInjectionNeeded>
    </PropertyGroup>
  </Target>
  <Target Name="InjectNetCoreFrameworkBlockIfLockFileExists" AfterTargets="ComputeNetCoreFrameworkInjectionParameters" Condition="'$(_NetCoreFrameworkInjectionNeeded)' == 'true' and '$(ResolveNuGetPackages)' == 'true' and Exists('$(ProjectLockFile)')">
    <Error Text="One of your dependencies requires the .NET Framework, but the .NET Framework could not be found in the NuGet packages installed in this project.  Please install the appropriate .NET Framework packages required by your dependency." />
  </Target>
  <Target Name="InjectNetCoreFramework" AfterTargets="ComputeNetCoreFrameworkInjectionParameters" Condition="'$(_NetCoreFrameworkInjectionNeeded)' == 'true' and ('$(ResolveNuGetPackages)' != 'true' or !Exists('$(ProjectLockFile)'))">
    <GetReferenceAssemblyPaths TargetFrameworkMoniker="$(NuGetTargetFrameworkMonikerToInject)" Condition="'$(FrameworkInjectionLockFile)' == ''">
      <Output TaskParameter="ReferenceAssemblyPaths" ItemName="_NuGetInjectionSourceDirectories" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <FrameworkInjectionLockFile Condition="'$(FrameworkInjectionLockFile)' == ''">@(_NuGetInjectionSourceDirectories->'%(Identity)\project.lock.json')</FrameworkInjectionLockFile>
      <FrameworkInjectionPackagesDirectory Condition="'$(FrameworkInjectionPackagesDirectory)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\NuGet\Repository', 'NETCoreSDK', null, RegistryView.Registry32, RegistryView.Default))</FrameworkInjectionPackagesDirectory>
    </PropertyGroup>
    <ResolveNuGetPackageAssets Condition="Exists('$(FrameworkInjectionLockFile)')" NuGetPackagesDirectory="$(FrameworkInjectionPackagesDirectory)" RuntimeIdentifier="$(NuGetRuntimeIdentifier)" TargetMonikers="$(NuGetTargetMonikerToInject)" ProjectLockFile="$(FrameworkInjectionLockFile)">
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="_InjectNetCoreFrameworkPayload" />
    </ResolveNuGetPackageAssets>
    <PropertyGroup>
      <_CoreRuntimePackageId Condition="'%(_InjectNetCoreFrameworkPayload.FileName)%(_InjectNetCoreFrameworkPayload.Extension)' == 'mscorlib.dll' OR '%(_InjectNetCoreFrameworkPayload.FileName)%(_InjectNetCoreFrameworkPayload.Extension)' == 'mscorlib.ni.dll'">%(_InjectNetCoreFrameworkPayload.NuGetPackageId)</_CoreRuntimePackageId>
    </PropertyGroup>
    <ItemGroup>
      <PackagingOutputs Include="@(_InjectNetCoreFrameworkPayload)" Condition="'%(_InjectNetCoreFrameworkPayload.NuGetPackageId)' != '$(_CoreRuntimePackageId)' or '$(UseDotNetNativeToolchain)' == 'true'">
        <TargetPath>%(Filename)%(Extension)</TargetPath>
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!--<Import Project="$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.targets" Condition="Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.targets') AND '$(IncludeNuGetImports)' != 'false'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.NuGet.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.QualityTools.Testing.Fakes.ImportAfter.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="$(FakesImported) != 'true'">
    <FakesBinPath Condition="$(FakesBinPath) == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\Fakes</FakesBinPath>
    <FakesTargets>$(FakesBinPath)\Microsoft.QualityTools.Testing.Fakes.targets</FakesTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(FakesTargets)" Condition="$(FakesImported) != 'true' and Exists('$(FakesTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\Fakes\Microsoft.QualityTools.Testing.Fakes.targets
============================================================================================================================================
-->
  <!-- Safeguard against importing this .targets file multiple times -->
  <PropertyGroup>
    <FakesImported>true</FakesImported>
  </PropertyGroup>
  <!-- Build customization properties -->
  <PropertyGroup>
    <FakesBinPath Condition="$(FakesBinPath) == ''">$(MSBuildProjectDirectory)</FakesBinPath>
    <FakesOutputPath Condition="$(FakesOutputPath) == ''">$(ProjectDir)FakesAssemblies</FakesOutputPath>
    <FakesIntermediatePath>$([System.IO.Path]::Combine('$(ProjectDir)','$(IntermediateOutputPath)Fakes'))</FakesIntermediatePath>
    <FakesContinueOnError Condition="$(FakesContinueOnError) == ''">false</FakesContinueOnError>
    <FakesToolsPath Condition="$(FakesToolsPath) == ''">$(FakesBinPath)</FakesToolsPath>
    <FakesMSBuildPath Condition="'$(FakesMSBuildPath)' == ''">$(MSBuildToolsPath)\msbuild.exe</FakesMSBuildPath>
    <!-- Pass unit test project's PlatformTarget to GenerateFakes task *only if* PlatformTarget is present! -->
    <FakesCompilationProperties Condition="'$(PlatformTarget)' != ''">$(FakesCompilationProperties);PlatformTarget=$(PlatformTarget)</FakesCompilationProperties>
    <FakesCommandLineArguments Condition="'$(FakesCompilationProperties)' != ''">$(FakesCommandLineArguments) /Properties:"$(FakesCompilationProperties)"</FakesCommandLineArguments>
    <FakesCommandLineArguments>$(FakesCommandLineArguments) /msbuildpath:"$(FakesMSBuildPath)"</FakesCommandLineArguments>
    <FakesVerbosity Condition="'$(FakesVerbosity)' == ''">Critical</FakesVerbosity>
    <FakesTasks>$(FakesBinPath)\Microsoft.QualityTools.Testing.Fakes.Tasks.dll</FakesTasks>
  </PropertyGroup>
  <!-- Make "Fakes" item available as a "Build Action" in the Properties window -->
  <ItemGroup>
    <AvailableItemName Include="Fakes" />
  </ItemGroup>
  <UsingTask TaskName="Microsoft.QualityTools.Testing.Fakes.GenerateFakes" AssemblyFile="$(FakesTasks)" />
  <UsingTask TaskName="Microsoft.QualityTools.Testing.Fakes.ReportFakesWarnings" AssemblyFile="$(FakesTasks)" />
  <!-- Generate .Fakes assemblies before assembly references of the parent project are resolved -->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      FakesGenerateBeforeBuild;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <!-- Define Fakes build steps -->
  <PropertyGroup>
    <FakesGenerateBeforeBuildDependsOn>
      $(FakesGenerateBeforeBuildDependsOn);
      ResolveFakesReferences;
      BuildFakesAssemblies;
    </FakesGenerateBeforeBuildDependsOn>
  </PropertyGroup>
  <Target Name="FakesGenerateBeforeBuild" Condition="@(Fakes) != '' AND $(BuildingProject)" DependsOnTargets="$(FakesGenerateBeforeBuildDependsOn)" />
  <!-- Collect the references excluding Fakes assembly files. -->
  <Target Name="ResolveFakesReferences" Condition="@(Fakes) != '' AND $(BuildingProject)">
    <ItemGroup>
      <ReferenceWithoutFakes Include="@(Reference)" />
      <ReferenceWithoutFakes Remove="$(FakesOutputPath)\*.Fakes.dll" />
    </ItemGroup>
    <PropertyGroup>
      <FakesResolveAssemblyReferencesStateFile>$(IntermediateOutputPath)$(MSBuildProjectFile)FakesResolveAssemblyReference.cache</FakesResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <ResolveAssemblyReference Assemblies="@(ReferenceWithoutFakes)" AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)" IgnoreDefaultInstalledAssemblyTables="$(IgnoreDefaultInstalledAssemblyTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" CandidateAssemblyFiles="@(Content);@(None)" SearchPaths="$(AssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)" AutoUnify="$(AutoUnifyAssemblyReferences)" IgnoreVersionForFrameworkReferences="$(IgnoreVersionForFrameworkReferences)" FindDependencies="true" FindSatellites="false" FindSerializationAssemblies="false" FindRelatedFiles="true" Silent="true" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(FakesResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="" LatestTargetFrameworkDirectories="@(LatestTargetFrameworkDirectories)" CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)">
      <Output TaskParameter="ResolvedFiles" ItemName="FakesResolvedReferencePaths" />
      <Output TaskParameter="ResolvedDependencyFiles" ItemName="FakesResolvedReferenceDependencyPaths" />
      <Output TaskParameter="RelatedFiles" ItemName="FakesRelatedPaths" />
      <Output TaskParameter="SatelliteFiles" ItemName="FakesSatellitePaths" />
      <Output TaskParameter="SuggestedRedirects" ItemName="FakesSuggestedRedirects" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </ResolveAssemblyReference>
  </Target>
  <!-- Generate fakes assembly files, if outdated. -->
  <Target Name="BuildFakesAssemblies" Condition="@(Fakes) != '' AND $(BuildingProject)" Inputs="&#xD;&#xA;      @(Fakes);&#xD;&#xA;      @(FakesReferencePaths);&#xD;&#xA;      @(FakesResolvedReferencePaths);&#xD;&#xA;      @(FakesResolvedReferenceDependencyPaths);&#xD;&#xA;      @(FakesRelatedPaths);&#xD;&#xA;      @(FakesSatellitePaths);&#xD;&#xA;      @(FakesSuggestedRedirects);&#xD;&#xA;    " Outputs="@(Fakes->'$(FakesOutputPath)\%(FileName).Fakes.dll')">
    <GenerateFakes ContinueOnError="$(FakesContinueOnError)" Verbosity="$(FakesVerbosity)" ForceX86="$(FakesForceX86)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetRuntimeVersion="$(TargetedRuntimeVersion)" ReferenceFiles="&#xD;&#xA;        @(FakesReferencePaths);&#xD;&#xA;        @(FakesResolvedReferencePaths);&#xD;&#xA;        @(FakesResolvedReferenceDependencyPaths);" SearchPaths="@(FakesSearchPaths)" CommandLineArguments="$(FakesCommandLineArguments)" OutputPath="$(FakesOutputPath)" IntermediatePath="$(FakesIntermediatePath)" Fakes="@(Fakes)" ToolsPath="$(FakesToolsPath)">
      <Output TaskParameter="FakesAssemblies" ItemName="FakesAssemblies" />
      <Output TaskParameter="FakesConfigurations" ItemName="FakesConfigurations" />
      <Output TaskParameter="FakesMessages" ItemName="FakesMessageFiles" />
    </GenerateFakes>
    <ReportFakesWarnings MessageFiles="@(FakesMessageFiles)" ContinueOnError="$(FakesContinueOnError)" />
    <ItemGroup>
      <FileWrites Include="$(FakesIntermediatePath)\**" />
      <ReferenceCopyLocalPaths Include="@(FakesConfigurations)" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Append directory where .Fakes assemblies are generated to the end of the assembly search path -->
      <AssemblySearchPaths>
        $(AssemblySearchPaths);
        $(FakesOutputPath)
      </AssemblySearchPaths>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.QualityTools.Testing.Fakes.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.VisualStudio.ReleaseManagement.BuildInfo.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.BuildInfo.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <BuildInfoBinPath Condition="$(BuildInfoBinPath) == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\BuildInfo</BuildInfoBinPath>
    <BuildInfoTargets>$(BuildInfoBinPath)\Microsoft.VisualStudio.ReleaseManagement.BuildInfo.targets</BuildInfoTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(BuildInfoTargets)" Condition="Exists('$(BuildInfoTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\BuildInfo\Microsoft.VisualStudio.ReleaseManagement.BuildInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.BuildInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains targets to produce a build info file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="GenerateBuildInfoTask" AssemblyFile="Microsoft.VisualStudio.ReleaseManagement.BuildInfoTasks.dll" />
  <UsingTask TaskName="AddUnmanagedResource" AssemblyFile="Microsoft.VisualStudio.ReleaseManagement.BuildInfoTasks.dll" />
  <UsingTask TaskName="ExtractUnmanagedResource" AssemblyFile="Microsoft.VisualStudio.ReleaseManagement.BuildInfoTasks.dll" />
  <!-- ################################################################################ -->
  <!-- Defaults -->
  <!-- ################################################################################ -->
  <PropertyGroup>
    <!-- Are we building inside TeamBuild? -->
    <BuildingInTeamBuild Condition=" '$(BuildUri)'!='' ">true</BuildingInTeamBuild>
    <!-- Generate build info config file for team build by default. Uncomment the line below after testing-->
    <GenerateBuildInfoConfigFile Condition=" '$(BuildingInTeamBuild)'=='true' AND $(GenerateBuildInfoConfigFile)=='' ">true</GenerateBuildInfoConfigFile>
    <GenerateBuildInfoConfigFile Condition=" $(GenerateBuildInfoConfigFile)=='' ">false</GenerateBuildInfoConfigFile>
    <AddBuildInfoToAssembly Condition=" $(AddBuildInfoToAssembly) == ''">false</AddBuildInfoToAssembly>
    <IncludeServerNameInBuildInfo Condition=" $(IncludeServerNameInBuildInfo) == '' ">false</IncludeServerNameInBuildInfo>
  </PropertyGroup>
  <!-- ################################################################################ -->
  <!-- Targets -->
  <!-- ################################################################################ -->
  <!-- ******************************************************* -->
  <!-- Target to supply default values for the BuildInfo file
       if the caller hasn't already supplied them. -->
  <!-- ******************************************************* -->
  <Target Name="SetBuildInfoDefaults">
    <!-- ******************************************************* -->
    <!-- Assign the default values to BuildInfo properties. -->
    <!-- ******************************************************* -->
    <PropertyGroup>
      <BuildId Condition=" $(BuildId)=='' AND $(BuildUri)!='' ">$(BuildUri)</BuildId>
      <BuildId Condition=" $(BuildId)=='' ">AutoGen_$([System.Guid]::NewGuid())</BuildId>
      <BuildLabel Condition=" $(BuildLabel)=='' ">$(BuildId)</BuildLabel>
      <BuildTimestamp Condition=" $(BuildTimestamp)=='' ">$([System.DateTime]::UtcNow.ToString("R"))</BuildTimestamp>
    </PropertyGroup>
    <!-- ******************************************************* -->
    <!-- Set the build info output file name if it hasn't already been set -->
    <!-- ******************************************************* -->
    <PropertyGroup>
      <!-- Default the path the target directory, failing which the project directory -->
      <BuildInfoPath Condition=" $(BuildInfoPath)=='' ">$(TargetDir)</BuildInfoPath>
      <BuildInfoPath Condition=" $(BuildInfoPath)=='' ">$(MSBuildProjectDirectory)</BuildInfoPath>
      <!-- Output file name: default to "[$AssemblyName].BuildInfo.config" -->
      <BuildInfoFileName Condition=" $(BuildInfoFileName) == '' AND  $(AssemblyName)!='' ">$(AssemblyName).BuildInfo.config</BuildInfoFileName>
      <BuildInfoFileName Condition=" $(BuildInfoFileName) == '' ">BuildInfo.config</BuildInfoFileName>
      <!-- Set the full path and file name. We don't need a Condition here since it's checked in the containing PropertyGroup -->
      <BuildInfoResourceFileName> $([System.IO.Path]::Combine($(IntermediateOutputPath), $(BuildInfoFileName)))</BuildInfoResourceFileName>
      <BuildInfoConfigFileName> $([System.IO.Path]::Combine($(BuildInfoPath), $(BuildInfoFileName)))</BuildInfoConfigFileName>
      <BuildInfoResourceLogicalName Condition=" $(BuildInfoResourceLogicalName)=='' ">Microsoft.VisualStudio.BuildInfo.Config</BuildInfoResourceLogicalName>
    </PropertyGroup>
  </Target>
  <!-- **********************************************************************************-->
  <!-- Target to create a new BuildInfo file as an embedded resource in the compiled file-->
  <!-- ********************************************************************************* -->
  <Target Name="CreateTfsBuildInfoResource" Condition=" $(AddBuildInfoToAssembly)==true " AfterTargets="AfterCompile" BeforeTargets="AfterBuild" Inputs="$(MSBuildAllProjects);&#xD;&#xA;            @(Compile);&#xD;&#xA;            @(_CoreCompileResourceInputs);&#xD;&#xA;            $(ApplicationIcon);&#xD;&#xA;            $(AssemblyOriginatorKeyFile);&#xD;&#xA;            @(ReferencePath);&#xD;&#xA;            @(CompiledLicenseFile);&#xD;&#xA;            @(LinkResource);&#xD;&#xA;            @(EmbeddedDocumentation);&#xD;&#xA;            $(Win32Resource);&#xD;&#xA;            $(Win32Manifest);&#xD;&#xA;            @(Page);&#xD;&#xA;            @(ApplicationDefinition);&#xD;&#xA;            @(CustomAdditionalCompileInputs)" Outputs="$(BuildInfoResourceFileName)" DependsOnTargets="SetBuildInfoDefaults">
    <GenerateBuildInfoTask BuildId="$(BuildId)" BuildLabel="$(BuildLabel)" BuildTimestamp="$(BuildTimestamp)" OutputFileName="$(BuildInfoResourceFileName)" TargetFileInSourceControl="$(MSBuildProjectFullPath)" TfsBuildUri="$(BuildUri)" TfsUrl="$(TeamFoundationServerUrl)" Configuration="$(Configuration)" BuiltSolution="$(SolutionPath)" BuildDefinition="$(BuildDefinition)" SymbolPath="$(BuildSymbolStorePath)" SourceVersion="$(BuildSourceVersion)" IncludeServerNameInBuildInfo="$(IncludeServerNameInBuildInfo)" />
    <!-- Add the file to @(FileWrites) so it will be cleaned up by the Clean target -->
    <ItemGroup Condition=" Exists('$(BuildInfoResourceFileName)') ">
      <FileWrites Include="$(BuildInfoResourceFileName)" />
    </ItemGroup>
    <AddUnmanagedResource AssemblyFile="@(IntermediateAssembly)" ResourceFile="$(BuildInfoResourceFileName)" ResourceName="$(BuildInfoResourceLogicalName)" />
  </Target>
  <!-- ******************************************************* -->
  <!-- Target to create a new BuildInfo file -->
  <!-- ******************************************************* -->
  <Target Name="CreateTfsBuildInfoFile" Condition=" $(GenerateBuildInfoConfigFile)==true AND $(WebProjectOutputDir)!=''" AfterTargets="AfterCompile" Inputs="@(IntermediateAssembly);&#xD;&#xA;            @(Content);&#xD;&#xA;            @(None);&#xD;&#xA;            @(DocFileItem);&#xD;&#xA;            @(_SourceItemsToCopyToOutputDirectoryAlways);&#xD;&#xA;            @(_SourceItemsToCopyToOutputDirectory);&#xD;&#xA;            @(_WebApplicationSilverlightXapFiles);&#xD;&#xA;            @(_binDeployableAssemblies)" Outputs="$(BuildInfoConfigFileName)" DependsOnTargets="SetBuildInfoDefaults">
    <GenerateBuildInfoTask BuildId="$(BuildId)" BuildLabel="$(BuildLabel)" BuildTimestamp="$(BuildTimestamp)" OutputFileName="$(BuildInfoConfigFileName)" TargetFileInSourceControl="$(MSBuildProjectFullPath)" ProjectName="$(MSBuildProjectName)" TfsBuildUri="$(BuildUri)" TfsUrl="$(TeamFoundationServerUrl)" Platform="$(Platform)" Configuration="$(Configuration)" BuiltSolution="$(SolutionPath)" BuildDefinition="$(BuildDefinition)" SymbolPath="$(BuildSymbolStorePath)" SourceVersion="$(BuildSourceVersion)" IncludeServerNameInBuildInfo="$(IncludeServerNameInBuildInfo)" />
    <!-- Add the file to @(FileWrites) so it will be cleaned up by the Clean target -->
    <ItemGroup Condition=" Exists('$(BuildInfoConfigFileName)') ">
      <FileWrites Include="$(BuildInfoConfigFileName)" />
    </ItemGroup>
    <!-- We're assuming we're only copying one file, so the DestinationFolder
         is hard-coded to a single file name. -->
    <Copy Condition="$(Disable_CopyWebApplication) != '' AND $(Disable_CopyWebApplication)== 'false' AND '$(OutDir)' != '$(OutputPath)' AND Exists('$(BuildInfoConfigFileName)') " SourceFiles="$(BuildInfoConfigFileName)" DestinationFiles="$(WebProjectOutputDir)\BuildInfo.config" SkipUnchangedFiles="true" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <!-- Add the file to @(FileWrites) so it will be cleaned up by the Clean target -->
    <ItemGroup Condition="$(Disable_CopyWebApplication) != '' AND $(Disable_CopyWebApplication)== 'false' AND '$(OutDir)' != '$(OutputPath)' AND Exists('$(BuildInfoConfigFileName)') ">
      <FileWrites Include="$(WebProjectOutputDir)\BuildInfo.config" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <PublishPipelineCollectFilesCore>
            $(PublishPipelineCollectFilesCore);
            CollectFilesFromBuildInfoConfigFile;
        </PublishPipelineCollectFilesCore>
  </PropertyGroup>
  <Target Name="CollectFilesFromBuildInfoConfigFile" DependsOnTargets="CreateTfsBuildInfoFile" Condition=" $(GenerateBuildInfoConfigFile)==true AND $(WebProjectOutputDir)!=''">
    <!-- Add the file with the necessary metadata to the set of files to be
           published by WebDeploy.
         
           Web publishing is controlled by Microsoft.Web.Publishing.targets in 
           %(MSBuildExtensions)\Microsoft\VisualStudio\v%(VisualStudioVersion)%\Web. These targets have a
           customisable mechanism for deciding which files should be published -
           search for "FilesToIncludeTargetFile" for more information. We're short-circuiting
           the normal mechanism by explicitly adding the file to the list that needs
           to be published.
           -->
    <ItemGroup Condition=" Exists('$(BuildInfoConfigFileName)') ">
      <FilesForPackagingFromProject Include="$(BuildInfoConfigFileName)">
        <!-- The file should appear at the destination root (which is where the
                web.config should be) and be called BuildInfo.config. -->
        <DestinationRelativePath>BuildInfo.config</DestinationRelativePath>
        <FromTarget>CollectFilesFromBuildInfoConfigFile</FromTarget>
        <Exclude>false</Exclude>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>
  <!-- ******************************************************* -->
  <!-- Target to delete an existing BuildInfo file -->
  <!-- ******************************************************* -->
  <Target Name="DeleteBuildInfoFile" AfterTargets="AfterCompile" Condition=" $(GenerateBuildInfoConfigFile)==false " DependsOnTargets="SetBuildInfoDefaults">
    <Delete Condition="EXISTS('$(BuildInfoConfigFileName)')" Files="$(BuildInfoConfigFileName)" />
  </Target>
  <Target Name="DeleteBuildInfoResource" AfterTargets="AfterCompile" Condition=" $(AddBuildInfoToAssembly)==false " DependsOnTargets="SetBuildInfoDefaults">
    <Delete Condition="EXISTS('$(BuildInfoResourceFileName)')" Files="$(BuildInfoResourceFileName)" />
  </Target>
  <Target Name="ExtractUnmanagedResource">
    <PropertyGroup>
      <AssemblyFile Condition=" $(AssemblyFile)=='' ">$(TargetPath)</AssemblyFile>
    </PropertyGroup>
    <ExtractUnmanagedResource AssemblyFile="$(AssemblyFile)" ResourceName="$(ResourceName)" ResourceType="$(ResourceType)" ResourceFile="$(ResourceFile)" CanLogErrors="$(CanLogErrors)" />
  </Target>
  <Target Name="AddUnmanagedResource">
    <PropertyGroup>
      <AssemblyFile Condition=" $(AssemblyFile)=='' ">$(TargetPath)</AssemblyFile>
    </PropertyGroup>
    <AddUnmanagedResource AssemblyFile="$(AssemblyFile)" ResourceFile="$(ResourceFile)" ResourceName="$(ResourceName)" ResourceType="$(ResourceType)" CanLogErrors="$(CanLogErrors)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.VisualStudio.ReleaseManagement.BuildInfo.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\MSBuild\14.0\Microsoft.Common.targets\ImportAfter\Microsoft.VisualStudio.Silverlight.SDKTools.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.VisualStudio.Silverlight.SDKTools

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process the root SMB project.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight'">
    <!--If the path to the sign tool is not set, try the Windows SDK path or the Framework SDK path -->
    <Windows8SDKInstallationFolder>$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32, RegistryView.Default))</Windows8SDKInstallationFolder>
    <Windows8SDKInstallationFolder Condition="'$(Windows8SDKInstallationFolder)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0', 'InstallationFolder', null, RegistryView.Registry32, RegistryView.Default))</Windows8SDKInstallationFolder>
    <_WindowsSDKSignToolPath Condition="'$(Windows8SDKInstallationFolder)' != ''">$([System.IO.Path]::Combine('$(Windows8SDKInstallationFolder)', 'bin\x86'))</_WindowsSDKSignToolPath>
    <SignToolPath Condition="'$(SignToolPath)' == '' and Exists('$(_WindowsSDKSignToolPath)\SignTool.exe')">$(_WindowsSDKSignToolPath)</SignToolPath>
    <SignToolPath Condition="'$(SignToolPath)' == ''">$(FrameworkSDKRoot)bin</SignToolPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
        installed.  -->
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
    <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')">

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.ServiceModel.targets
============================================================================================================================================
-->
  <!-- 
        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  

        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
   -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets">

C:\windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.ServiceModel.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.ServiceModel.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.Build.Tasks.Xsd.XsdTypeImporterTask" AssemblyName="XsdBuildTask, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL" />
  <!-- sub build target, preceeding XsdCodeGen -->
  <Target Name="PreXsdCodeGen" BeforeTargets="CoreCompile">
    <ItemGroup>
      <XsdCodeGenInputXsdFiles Include="@(None)" Condition=" '%(None.Extension)' == '.xsd' and '%(None.Generator)' == '' " />
    </ItemGroup>
    <PropertyGroup>
      <XsdCodeGenPreCondition>False</XsdCodeGenPreCondition>
      <XsdCodeGenPreCondition Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5' and '$(TargetFrameworkVersion)' != 'v4.0' and ( '$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' ) and '$(XsdCodeGenEnabled)' == 'True' and '@(XsdCodeGenInputXsdFiles)' != '' ">True</XsdCodeGenPreCondition>
    </PropertyGroup>
    <CallTarget Targets="CleanXsdCodeGen" Condition=" '$(XsdCodeGenPreCondition)' != 'True' " />
  </Target>
  <!-- main build target -->
  <Target Name="XsdCodeGen" DependsOnTargets="ResolveReferences" AfterTargets="PreXsdCodeGen" Condition=" '$(XsdCodeGenPreCondition)' == 'True' ">
    <!-- will show in VS output window, for discoverability -->
    <Message Importance="high" Text="Generating code from XSD: InputXsdFiles=@(XsdCodeGenInputXsdFiles)" />
    <PropertyGroup>
      <!-- assign default values -->
      <XsdCodeGenSerializerMode Condition=" '$(XsdCodeGenSerializerMode)' == '' ">XmlSerializer</XsdCodeGenSerializerMode>
      <XsdCodeGenReuseTypesFlag Condition=" '$(XsdCodeGenReuseTypesFlag)' == '' ">True</XsdCodeGenReuseTypesFlag>
      <XsdCodeGenReuseTypesMode Condition=" '$(XsdCodeGenReuseTypesMode)' == '' ">All</XsdCodeGenReuseTypesMode>
      <XsdCodeGenNamespaceMappings Condition=" '$(XsdCodeGenNamespaceMappings)' == '' and '$(Language)' == 'C#' and '$(RootNamespace)' != '' ">*, $(RootNamespace).ContractTypes</XsdCodeGenNamespaceMappings>
      <XsdCodeGenNamespaceMappings Condition=" '$(XsdCodeGenNamespaceMappings)' == '' ">*, ContractTypes</XsdCodeGenNamespaceMappings>
      <XsdCodeGenCollectionTypes Condition=" '$(XsdCodeGenCollectionTypes)' == '' ">System.Array;System.Collections.Generic.Dictionary`2</XsdCodeGenCollectionTypes>
      <XsdCodeGenImportXmlTypes Condition=" '$(XsdCodeGenImportXmlTypes)' == '' ">True</XsdCodeGenImportXmlTypes>
      <XsdCodeGenGenerateSerializableTypes Condition=" '$(XsdCodeGenGenerateSerializableTypes)' == '' ">True</XsdCodeGenGenerateSerializableTypes>
      <XsdCodeGenGenerateDataTypesOnly Condition=" '$(XsdCodeGenGenerateDataTypesOnly)' == '' ">False</XsdCodeGenGenerateDataTypesOnly>
      <XsdCodeGenGenerateInternalTypes Condition=" '$(XsdCodeGenGenerateInternalTypes)' == '' ">False</XsdCodeGenGenerateInternalTypes>
      <XsdCodeGenEnableDataBinding Condition=" '$(XsdCodeGenEnableDataBinding)' == '' ">False</XsdCodeGenEnableDataBinding>
      <!-- calc dynamic values -->
      <XsdCodeGenSupportFx35DataTypes Condition="'$(XsdCodeGenSupportFx35DataTypes)' == '' and '$(TargetFrameworkVersion)' == 'v2.0'">False</XsdCodeGenSupportFx35DataTypes>
      <XsdCodeGenSupportFx35DataTypes Condition="'$(XsdCodeGenSupportFx35DataTypes)' == '' and '$(TargetFrameworkVersion)' == 'v3.0'">False</XsdCodeGenSupportFx35DataTypes>
      <XsdCodeGenSupportFx35DataTypes Condition="'$(XsdCodeGenSupportFx35DataTypes)' == ''">True</XsdCodeGenSupportFx35DataTypes>
    </PropertyGroup>
    <!-- calc references for type reusing, resolve their paths from @(ReferencePath) from 'ResolveReferences' build target -->
    <ItemGroup>
      <XsdCodeGenReferencesResolved Include="@(ReferencePath)" Condition=" '$(XsdCodeGenReuseTypesFlag)' == 'True' and '$(XsdCodeGenReuseTypesMode)' == 'All' " />
    </ItemGroup>
    <CallTarget Targets="XsdResolveReferencePath" Condition=" '$(XsdCodeGenReuseTypesFlag)' == 'True' and '$(XsdCodeGenReuseTypesMode)' != 'All' ">
      <Output ItemName="XsdCodeGenReferencesResolved" TaskParameter="TargetOutputs" />
    </CallTarget>
    <!-- will show in VS output window, for discoverability -->
    <Message Importance="high" Text="Generating code from XSD: References=@(XsdCodeGenReferencesResolved)" />
    <!-- set property <MSBuildTargetsVerbose>True</MSBuildTargetsVerbose> to see following messages -->
    <Message Text="Generating code from XSD: OutputDirectory=$(IntermediateOutputPath)\XsdGeneratedCode" />
    <Message Text="Generating code from XSD: Language=$(Language)" />
    <Message Text="Generating code from XSD: NamespaceMappings=$(XsdCodeGenNamespaceMappings)" />
    <Message Text="Generating code from XSD: SerializerMode=$(XsdCodeGenSerializerMode)" />
    <Message Text="Generating code from XSD: CollectionTypes=$(XsdCodeGenCollectionTypes)" />
    <Message Text="Generating code from XSD: ExcludedTypes=$(XsdCodeGenExcludedTypes)" />
    <Message Text="Generating code from XSD: ImportXmlTypes=$(XsdCodeGenImportXmlTypes)" />
    <Message Text="Generating code from XSD: GenerateSerializableTypes=$(XsdCodeGenGenerateSerializableTypes)" />
    <Message Text="Generating code from XSD: GenerateInternalTypes=$(XsdCodeGenGenerateInternalTypes)" />
    <Message Text="Generating code from XSD: EnableDataBinding=$(XsdCodeGenEnableDataBinding)" />
    <Message Text="Generating code from XSD: SupportFx35DataTypes=$(XsdCodeGenSupportFx35DataTypes)" />
    <MakeDir Directories="$(IntermediateOutputPath)\XsdGeneratedCode" />
    <ItemGroup>
      <XsdCodeGenGeneratedFile Condition=" '@(XsdCodeGenGeneratedFile)' == '' And '$(Language)' == 'C#' " Include="$(IntermediateOutputPath)\XsdGeneratedCode\GeneratedXsdTypes.cs" />
      <XsdCodeGenGeneratedFile Condition=" '@(XsdCodeGenGeneratedFile)' == '' And '$(Language)' == 'VB' " Include="$(IntermediateOutputPath)\XsdGeneratedCode\GeneratedXsdTypes.vb" />
    </ItemGroup>
    <Touch Files="@(XsdCodeGenGeneratedFile)" AlwaysCreate="true" />
    <ItemGroup>
      <Compile Include="@(XsdCodeGenGeneratedFile)" />
      <FileWrites Include="@(XsdCodeGenGeneratedFile)" />
    </ItemGroup>
    <XsdTypeImporterTask InputXsdFiles="@(XsdCodeGenInputXsdFiles)" References="@(XsdCodeGenReferencesResolved)" OutputDirectory="$(IntermediateOutputPath)\XsdGeneratedCode" Language="$(Language)" NamespaceMappings="$(XsdCodeGenNamespaceMappings.Split(';'))" SerializerMode="$(XsdCodeGenSerializerMode)" CollectionTypes="$(XsdCodeGenCollectionTypes.Split(';'))" ExcludedTypes="$(XsdCodeGenExcludedTypes.Split(';'))" ImportXmlTypes="$(XsdCodeGenImportXmlTypes)" GenerateSerializableTypes="$(XsdCodeGenGenerateSerializableTypes)" GenerateInternalTypes="$(XsdCodeGenGenerateInternalTypes)" EnableDataBinding="$(XsdCodeGenEnableDataBinding)" SupportFx35DataTypes="$(XsdCodeGenSupportFx35DataTypes)" />
    <!-- will show in VS output window, for discoverability -->
    <Message Importance="high" Text="Generated code from XSD: GeneratedFile=@(XsdCodeGenGeneratedFile)" />
  </Target>
  <!-- sub build target, called by XsdCodeGen -->
  <Target Name="XsdResolveReferencePath" Outputs="@(XsdCodeGenReferencesResolved)">
    <!-- filter @(ReferencePath) (full file path) by $(XsdCodeGenReferences) (file name without extension) -->
    <WriteLinesToFile File="$(IntermediateOutputPath)\XsdCodeGenTempA.txt" Lines="@(ReferencePath)" Overwrite="True" />
    <WriteLinesToFile File="$(IntermediateOutputPath)\XsdCodeGenTempB.txt" Lines="$(XsdCodeGenReferences.Split(';'))" Overwrite="True" />
    <Delete Files="$(IntermediateOutputPath)\XsdCodeGenTempC.txt" />
    <!-- for /f "tokens=*" %%a in ($(IntermediateOutputPath)\XsdCodeGenTempA.txt) do ( for /f "tokens=*" %%b in ($(IntermediateOutputPath)\XsdCodeGenTempB.txt) do ( if /i "%%~na" EQU "%%~b" ( echo %%a>>"$(IntermediateOutputPath)\XsdCodeGenTempC.txt" ) ) ) -->
    <Exec Command="for /f %22tokens=*%22 %%a in ($(IntermediateOutputPath)\XsdCodeGenTempA.txt) do ( for /f %22tokens=*%22 %%b in ($(IntermediateOutputPath)\XsdCodeGenTempB.txt) do ( if /i %22%%~na%22 EQU %22%%~b%22 ( echo %%a&gt;&gt;%22$(IntermediateOutputPath)\XsdCodeGenTempC.txt%22 ) ) )" />
    <ReadLinesFromFile File="$(IntermediateOutputPath)\XsdCodeGenTempC.txt">
      <Output ItemName="XsdCodeGenReferencesResolved" TaskParameter="Lines" />
    </ReadLinesFromFile>
    <Delete Files="$(IntermediateOutputPath)\XsdCodeGenTempA.txt;$(IntermediateOutputPath)\XsdCodeGenTempB.txt;$(IntermediateOutputPath)\XsdCodeGenTempC.txt" />
  </Target>
  <!-- clean build target for XsdCodeGen -->
  <Target Name="CleanXsdCodeGen" AfterTargets="Clean">
    <ItemGroup>
      <CleanXsdCodeGenFiles Include="$(IntermediateOutputPath)\XsdGeneratedCode\*" />
    </ItemGroup>
    <Delete Files="@(CleanXsdCodeGenFiles)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.ServiceModel.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
    <PropertyGroup>
      <TargetFrameworkMonikerAssemblyAttributeText Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">
// &lt;autogenerated /&gt;
using System%3b
using System.Reflection%3b
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute("$(TargetFrameworkMoniker)", FrameworkDisplayName = "$(TargetFrameworkMonikerDisplayName)")]
        </TargetFrameworkMonikerAssemblyAttributeText>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
    <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
           want that switch to be passed to the compiler so that either we or the user
           provides the references
           NoStdLib on the other hand indicates that the user doesn't want standard references
           so only if NoStdLib isn't set to true, will we provide the standard references
      -->
    <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
    <ErrorEndLocation Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(ErrorEndLocation)' == ''">true</ErrorEndLocation>
    <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
    <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
  </PropertyGroup>
  <!-- Add any "automatic" compiler references that need to be resolved when NoCompilerStandardLib is set
         but the user hasn't told us to not include standard references -->
  <ItemGroup Condition=" '$(NoCompilerStandardLib)' == 'true' and '$(NoStdLib)' != 'true' ">
    <!-- Note that unlike VB, C# does not automatically locate System.dll as a "standard library"
           instead the reference is always passed from the project. Also, for mscorlib.dll 
           we need to provide the explicit location in order to maintain the correct behaviour
      -->
    <_ExplicitReference Include="$(FrameworkPathOverride)\mscorlib.dll" />
  </ItemGroup>
  <!--<Import Project="$(CustomAfterMicrosoftCSharpTargets)" Condition="'$(CustomAfterMicrosoftCSharpTargets)' != '' and Exists('$(CustomAfterMicrosoftCSharpTargets)')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.CSharp.Targets
============================================================================================================================================
-->
  <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports 
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
        way instead. -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
        targets), we're stuck doing it this way instead. -->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">-->
  <!--<Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--</ImportGroup>-->
  <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.CSharp.targets 
        imports Microsoft.Common.targets from the current directory. -->
  <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
    <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="..\Microsoft.Portable.Core.targets">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\Microsoft.Portable.Core.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.Core.targets

Contains common targets that are shared by all portable library projects regardless of version.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="VisualStudio\v$(VisualStudioVersion)\Microsoft.Portable.CurrentVersion.targets" Condition="Exists('VisualStudio\v$(VisualStudioVersion)\Microsoft.Portable.CurrentVersion.targets')">

C:\Program Files (x86)\MSBuild\Microsoft\Portable\VisualStudio\v14.0\Microsoft.Portable.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Portable.CurrentVersion.targets

Contains common targets that are shared by all portable library projects targeting a specific
Visual Studio version.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(WindowsUIXamlCommonTargets)" Condition="'$(PortableEnableXamlTargets)'=='true' and Exists('$(WindowsUIXamlCommonTargets)')">

C:\Program Files (x86)\MSBuild\Microsoft\WindowsXaml\v14.0\8.1\Microsoft.Windows.UI.Xaml.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="ImportBefore\*" />-->
  <!-- Need the path to vcmeta.dll -->
  <PropertyGroup>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\14.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VSWinExpress\14.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VSWinExpress\14.0\Setup\VC@ProductDir)</VCInstallDir>
    <XAMLFingerprint Condition="'$(XAMLFingerprint)' == ''">true</XAMLFingerprint>
    <DisableXbfGeneration Condition="'$(DisableXbfGeneration)' == '' AND '$(TargetPlatformVersion)' == '8.0'">true</DisableXbfGeneration>
    <DisableXbfGeneration Condition="'$(DisableXbfGeneration)' == ''">false</DisableXbfGeneration>
    <XamlSavedStateFileName Condition="'$(XamlSavedStateFileName)' == ''">XamlSaveStateFile.xml</XamlSavedStateFileName>
    <XamlSavedStateFilePath>$(IntermediateOutputPath)\$(XamlSavedStateFileName)</XamlSavedStateFilePath>
    <XAMLFingerprintIgnorePaths Condition="'$(XAMLFingerprintIgnorePaths)'==''">
            @(ReferenceAssemblyPaths);
            $(WindowsSDK80Path)
        </XAMLFingerprintIgnorePaths>
  </PropertyGroup>
  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="PRIResource" />
    <AvailableItemName Include="AppxManifest" />
    <AvailableItemName Include="ApplicationDefinition" />
    <AvailableItemName Include="Page" />
    <AvailableItemName Include="DesignData" />
    <AvailableItemName Include="DesignDataWithDesignTimeCreatableTypes" />
  </ItemGroup>
  <ItemGroup>
    <ProjectCapability Include="WindowsXaml" />
    <ProjectCapability Include="WindowsXamlPage" />
    <ProjectCapability Include="WindowsXamlCodeBehind" />
    <ProjectCapability Include="WindowsXamlResourceDictionary" />
    <ProjectCapability Include="WindowsXamlUserControl" />
  </ItemGroup>
  <!-- For Managed Assemblies Create a XAML Roots Log -->
  <PropertyGroup Condition="'$(ManagedAssembly)' != 'false'">
    <XamlRootsLog>$(AssemblyName).xr.xml</XamlRootsLog>
  </PropertyGroup>
  <!-- Setting PRI index name.  The XAML compiler use this in the LoadComponent() string.
         It must match the name of the directoy the AppX Packaging system uses -->
  <PropertyGroup>
    <!-- Exe's don't have an PriIndexName -->
    <PriIndexName Condition="'$(AppxPackage)' == 'true'" />
    <!-- Managed Dll's use the "safe" name of the project as the App Package Name -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' != 'false' and '$(OutputType)' != 'winmdobj'">$(TargetName)</PriIndexName>
    <!-- Winmd library targets (managed or native) use the default root namespace of the project for the App package name -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' != 'false' and '$(OutputType)' == 'winmdobj'">$(RootNamespace)</PriIndexName>
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' == 'false' and '$(RootNamespace)' != ''">$(RootNamespace)</PriIndexName>
    <!-- If RootNamespace is empty fall back to TargetName -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and $(PriIndexName) == ''">$(TargetName)</PriIndexName>
  </PropertyGroup>
  <PropertyGroup>
    <AvailablePlatforms>$(AvailablePlatforms),ARM</AvailablePlatforms>
    <!-- this Property is used only for the Managed build.
            See Microsoft.Windows.UI.Xaml.Cpp.Targets for Native build rules -->
    <PrepareResourcesDependsOn>
            ResolveKeySource;
            MarkupCompilePass1;
            XamlPreCompile;
            MarkupCompilePass2;
            $(PrepareResourcesDependsOn)
        </PrepareResourcesDependsOn>
    <Prefer32Bit Condition="'$(Prefer32Bit)' == '' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe')">true</Prefer32Bit>
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">true</HighEntropyVA>
    <SubsystemVersion Condition="'$(SubsystemVersion)' == '' and ('$(PlatformTarget)' == 'ARM' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == 'winmdobj')">6.02</SubsystemVersion>
    <SubsystemVersion Condition="'$(SubsystemVersion)' == ''">6.00</SubsystemVersion>
    <OnXamlPreCompileErrorTarget Condition="'$(OnXamlPreCompileErrorTarget)' == ''">_OnXamlPreCompileError</OnXamlPreCompileErrorTarget>
    <!-- Use Intermediate dir if XamlGeneratedOutputPath is not defined -->
    <XamlGeneratedOutputPath Condition="'$(XamlGeneratedOutputPath)' == ''">$(IntermediateOutputPath)</XamlGeneratedOutputPath>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.CompileXaml" AssemblyFile="Microsoft.Windows.UI.Xaml.81.Build.Tasks.dll" />
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.AddDefaultXamlLinkMetadata" AssemblyFile="Microsoft.Windows.UI.Xaml.81.Build.Tasks.dll" />
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.GetXamlCppIncludeDirectories" AssemblyFile="Microsoft.Windows.UI.Xaml.81.Build.Tasks.dll" />
  <PropertyGroup>
    <!--If the path to the sign tool is not set, assume the SDK path -->
    <SignToolPath Condition="'$(SignToolPath)' == ''">$(FrameworkSDKRoot)bin</SignToolPath>
    <!--Integration with packaging for GeneratedXamlFilesOutputGroupOutput -->
    <IncludeCustomOutputGroupForPackaging>true</IncludeCustomOutputGroupForPackaging>
  </PropertyGroup>
  <ItemGroup>
    <XamlIntermediateAssembly Condition="'$(ManagedAssembly)'!='false'" Include="$(XamlGeneratedOutputPath)intermediatexaml\$(TargetName)$(TargetExt)" />
    <XamlIntermediateAssembly Condition="'$(ManagedAssembly)'=='false'" Include="$(OutputPath)\$(TargetName).winmd" />
  </ItemGroup>
  <!--
    ============================================================
    Adds all XAML Pages to the $(Resource) collection
    ============================================================
    -->
  <ItemGroup Condition=" '$(ManagedAssembly)'=='' ">
    <!-- Add XAML Page items to $(Resource) -->
    <Resource Include="@(Page)" />
    <Resource Include="@(ApplicationDefinition)" />
  </ItemGroup>
  <!-- Manifest metadata items.                       -->
  <!-- See Microsoft.AppxPackage.targets for details. -->
  <ItemGroup Label="AppxManifestMetadata">
    <AppxManifestMetadata Include="$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\$(TargetPlatformVersion)\Microsoft.Windows.UI.Xaml.81.Build.Tasks.dll" />
  </ItemGroup>
  <PropertyGroup>
    <MarkupCompilePass1DependsOn>
            GetXamlCppIncludeDirectories;
            $(GetXamlCppIncludeDirectories)
        </MarkupCompilePass1DependsOn>
    <MarkupCompilePass2DependsOn>
            GetXamlCppIncludeDirectories;
            $(GetXamlCppIncludeDirectories)
        </MarkupCompilePass2DependsOn>
    <Prep_ComputeProcessXamlFilesDependsOn>
            GetXamlCppIncludeDirectories;
            $(Prep_ComputeProcessXamlFilesDependsOn)
        </Prep_ComputeProcessXamlFilesDependsOn>
  </PropertyGroup>
  <!-- In order for the XAML compiler to generated the correct relative paths for #includes in
         the generated C++ code it needs to know the AdditionalIncludeDirectories of all the .cpp
         files are DependentUpon XAML files.-->
  <Target Name="GetXamlCppIncludeDirectories" Condition="'$(ManagedAssembly)'=='false' and '$(XamlCppIncludeDirectories)' == ''">
    <GetXamlCppIncludeDirectories ClCompile="@(ClCompile)">
      <Output PropertyName="XamlCppIncludeDirectories" TaskParameter="ComputedIncludeDirectories" />
    </GetXamlCppIncludeDirectories>
  </Target>
  <!-- 
    ================================================================
                        DesignTimeMarkupCompilation
                        
    Support for the Intellisense build
    ================================================================
     -->
  <PropertyGroup>
    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true' ">
            DesignTimeMarkupCompilation;
            $(CoreCompileDependsOn)
        </CoreCompileDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeMarkupCompilation">
    <!-- BuildingProject is used in Managed builds (always true in Native) -->
    <!-- DesignTimeBuild is used in Native builds (always false in Managed) -->
    <CallTarget Condition="'$(BuildingProject)' != 'true' Or $(DesignTimeBuild) == 'true'" Targets="DesignTimeMarkupCompilationCT" />
  </Target>
  <!-- A copy of the first pass, without the WarningLevel manipulation -->
  <Target Name="DesignTimeMarkupCompilationCT" DependsOnTargets="$(MarkupCompilePass1DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <MakeDir Condition="'$(ManagedAssembly)'!='false'" Directories="$(XamlGeneratedOutputPath)intermediatexaml\" />
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(Language)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" PriIndexName="$(PriIndexName)" ProjectName="$(MsBuildProjectName)" IsPass1="True" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" CIncludeDirectories="$(XamlCppIncludeDirectories)" ProjectPath="$(MSBuildProjectFullPath)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(ReferencePath)" ForceSharedStateShutdown="False" ContinueOnError="True" CompileMode="DesignTimeBuild" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" SavedStateFile="$(XamlSavedStateFilePath)" SuppressWarnings="$(SuppressXamlWarnings)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <!--
      Add to the list of files written.
      It is used in Microsoft.Common.Targets for a next clean build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
    </ItemGroup>
    <Message Text="(Out) ISenseCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) ISenseXamlFiles: '@(_GeneratedXamlFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'%(ClCompile.CompilerIteration)' != 'XamlGenerated'" />
    <Message Text="(Out) Compile: '@(Compile)'" />
  </Target>
  <!--   
    ================================================================
                         MarkupCompilePass1
    ================================================================
    -->
  <Target Name="MarkupCompilePass1" DependsOnTargets="$(MarkupCompilePass1DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <MakeDir Condition="'$(ManagedAssembly)'!='false'" Directories="$(XamlGeneratedOutputPath)intermediatexaml\" />
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(Language)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" PriIndexName="$(PriIndexName)" ProjectName="$(MsBuildProjectName)" IsPass1="True" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" ProjectPath="$(MSBuildProjectFullPath)" CIncludeDirectories="$(XamlCppIncludeDirectories)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(ReferencePath)" ForceSharedStateShutdown="False" CompileMode="RealBuildPass1" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" SavedStateFile="$(XamlSavedStateFilePath)" SuppressWarnings="$(SuppressXamlWarnings)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <!--
      FileWrites is used in Microsoft.Common.Targets for "Clean" build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXbfFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
    </ItemGroup>
    <Message Text="(Out) GeneratedCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'$(ManagedAssembly)'=='false' and '%(ClCompile.CompilerIteration)'!='XamlGenerated'" />
    <Message Text="(Out) Compile: '@(Compile)'" Condition="'$(ManagedAssembly)'!='false'" />
    <PropertyGroup>
      <PrevWarningLevel>$(WarningLevel)</PrevWarningLevel>
      <WarningLevel Condition="'$(SuppressWarningsInPass1)'=='true'">0</WarningLevel>
    </PropertyGroup>
  </Target>
  <!--   
    ================================================================
                         MarkupCompilePass2
    ================================================================
    -->
  <Target Name="MarkupCompilePass2" DependsOnTargets="$(MarkupCompilePass2DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <PropertyGroup>
      <WarningLevel>$(PrevWarningLevel)</WarningLevel>
      <WarningLevel Condition="'$(WarningLevel)' == '' and '$(ExplicitResetWarningSuppression)' == 'true'">1</WarningLevel>
    </PropertyGroup>
    <!-- The Name of the Local Assembly in Managed and Native -->
    <PropertyGroup>
      <LocalAssembly Condition="'$(LocalAssembly)' == '' and Exists(@(XamlIntermediateAssembly))">
                @(XamlIntermediateAssembly->'%(Identity)')
            </LocalAssembly>
    </PropertyGroup>
    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput_xaml" />
    </CallTarget>
    <ItemGroup>
      <SdkXamlItems Include="@(_SDKRedistOutputGroupOutput_xaml)" Condition="'%(Extension)'=='.xaml'" />
    </ItemGroup>
    <ItemGroup>
      <!-- C++ provides a filtered Item that eliminates any Managed Assemblies on the ReferencePath (from SDKs for example) -->
      <XamlReferencesToCompile Condition="'$(Language)'=='C++'" Include="@(WinMDReferenceToCompile)" />
      <XamlReferencesToCompile Condition="'$(Language)'!='C++'" Include="@(ReferencePath)" />
    </ItemGroup>
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(Language)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" SdkXamlPages="@(SdkXamlItems)" PriIndexName="$(PriIndexName)" ProjectName="$(MsBuildProjectName)" IsPass1="False" DisableXbfGeneration="$(DisableXbfGeneration)" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" ClIncludeFiles="@(ClInclude)" CIncludeDirectories="$(XamlCppIncludeDirectories)" LocalAssembly="$(LocalAssembly)" ProjectPath="$(MSBuildProjectFullPath)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(XamlReferencesToCompile)" ForceSharedStateShutdown="False" CompileMode="RealBuildPass2" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" SavedStateFile="$(XamlSavedStateFilePath)" RootsLog="$(XamlRootsLog)" SuppressWarnings="$(SuppressXamlWarnings)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <Output Condition=" '$(ManagedAssembly)'=='false' " ItemName="XamlGFiles" TaskParameter="GeneratedCodeFiles" />
      <!--
      FileWrites is used in Microsoft.Common.Targets for "Clean" build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXbfFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="_GeneratedXamlFiles" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="_GeneratedXbfFiles" TaskParameter="GeneratedXbfFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
      <FileWrites Condition="'$(XamlRootsLog)' != ''" Include="$(XamlRootsLog)" />
    </ItemGroup>
    <Message Text="(Out) GeneratedCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) GeneratedXamlFiles: '@(_GeneratedXamlFiles)'" />
    <Message Text="(Out) GeneratedXbfFiles: '@(_GeneratedXbfFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'$(ManagedAssembly)'=='false'" />
    <Message Text="(Out) Compile: '@(Compile)'" Condition="'$(ManagedAssembly)'!='false'" />
  </Target>
  <Target Name="_OnXamlPreCompileError" DependsOnTargets="$(_OnXamlPrecompileErrorDependsOn)">
    <CompileXaml ProjectPath="$(MSBuildProjectFullPath)" Language="$(Language)" LanguageSourceExtension="$(DefaultLanguageSourceExtension)" OutputPath="$(XamlGeneratedOutputPath)" ReferenceAssemblies="@(ReferencePath)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" ForceSharedStateShutdown="True" CompileMode="OnErrorShutdown" SavedStateFile="$(XamlSavedStateFilePath)" />
  </Target>
  <Target Name="Prep_ComputeProcessXamlFiles" Condition="'@(ApplicationDefinition)'!='' or '@(Page)'!=''" DependsOnTargets="$(Prep_ComputeProcessXamlFilesDependsOn)">
    <!-- collect all the XAML pages from the Project file into one Item -->
    <ItemGroup>
      <AllProjectXamlPages Condition="'%(ApplicationDefinition.ExcludedFromBuild)'!='true'" Include="@(ApplicationDefinition)" />
      <AllProjectXamlPages Condition="'%(Page.ExcludedFromBuild)'!='true'" Include="@(Page)" />
    </ItemGroup>
    <!-- For ttems are outside the project cone Link metadata tells us what the apparent project path should be.
         C++ doesn't use Link data, so for C++ add implied DefaultXamlLink metadata based on the Include Path -->
    <AddDefaultXamlLinkMetadata Condition="'$(ManagedAssembly)'=='false'" ProjectPath="$(ProjectPath)" XamlPages="@(AllProjectXamlPages)" CIncludeDirectories="$(XamlCppIncludeDirectories)">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AddDefaultXamlLinkMetadata>
    <!-- Remove the Items named in _Temp, then add the actual items from _Temp, then clear _Temp  -->
    <ItemGroup>
      <AllProjectXamlPages Remove="@(_Temp)" />
      <AllProjectXamlPages Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- transfer the DefaultXamlLink data to the Link attribute -->
    <ItemGroup>
      <AllProjectXamlPages Condition="'%(AllProjectXamlPages.DefaultXamlLink)'!=''">
        <Link>%(AllProjectXamlPages.DefaultXamlLink)</Link>
      </AllProjectXamlPages>
    </ItemGroup>
    <!-- Compute the Generated XAML source path and the bin dir Destination path -->
    <!-- If there is a Link use that, otherwise use the Given path from the Project file Item -->
    <ItemGroup>
      <GeneratedXamlSrc0 Condition="'%(AllProjectXamlPages.Link)'!=''" Include="@(AllProjectXamlPages->'$(XamlGeneratedOutputPath)%(Link)')" />
      <GeneratedXamlSrc0 Condition="'%(AllProjectXamlPages.Link)'==''" Include="@(AllProjectXamlPages->'$(XamlGeneratedOutputPath)%(Identity)')" />
      <GeneratedXamlDest0 Condition="'%(AllProjectXamlPages.Link)'!=''" Include="@(AllProjectXamlPages->'$(OutputPath)\%(Link)')" />
      <GeneratedXamlDest0 Condition="'%(AllProjectXamlPages.Link)'==''" Include="@(AllProjectXamlPages->'$(OutputPath)\%(Identity)')" />
    </ItemGroup>
    <!-- Swap in the XBF suffix if appropriate. -->
    <ItemGroup Condition="'$(DisableXbfGeneration)' == 'true'">
      <GeneratedXamlSrc Include="@(GeneratedXamlSrc0)" />
      <GeneratedXamlDest Include="@(GeneratedXamlDest0)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DisableXbfGeneration)' != 'true'">
      <GeneratedXamlSrc Include="%(GeneratedXamlSrc0.RelativeDir)%(GeneratedXamlSrc0.Filename).xbf" />
      <GeneratedXamlDest Include="%(GeneratedXamlDest0.RelativeDir)%(GeneratedXamlDest0.Filename).xbf" />
    </ItemGroup>
    <!-- if we converted SDK XAML into XBF, add the XBF to the list, and remove the XAML from the list -->
    <ItemGroup Condition="'$(DisableXbfGeneration)' != 'true' and '@(SdkXamlItems)' != ''">
      <GeneratedSdkXamlSrc0 Include="@(SdkXamlItems->'$(XamlGeneratedOutputPath)%(TargetPath)')" />
      <GeneratedSdkXamlDest0 Include="@(SdkXamlItems->'$(OutputPath)\%(TargetPath)')" />
      <GeneratedXamlSrc Include="%(GeneratedSdkXamlSrc0.RelativeDir)%(GeneratedSdkXamlSrc0.Filename).xbf" />
      <GeneratedXamlDest Include="%(GeneratedSdkXamlDest0.RelativeDir)%(GeneratedSdkXamlDest0.Filename).xbf" />
      <RemoveSdkFilesFromAppxPackage Include="@(SdkXamlItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(XamlRootsLog)' != ''">
      <GeneratedXamlSrc Include="$(XamlGeneratedOutputPath)\$(XamlRootsLog)" />
      <GeneratedXamlDest Include="$(OutputPath)\$(XamlRootsLog)" />
    </ItemGroup>
    <Message Importance="low" Text="(Out) Prep_GeneratedXamlSrc == @(GeneratedXamlSrc)" />
    <Message Importance="low" Text="(Out) Prep_GeneratedXamlDest == @(GeneratedXamlDest)" />
  </Target>
  <!-- if $GenerateLibraryLayout is True this is skipped and see the PrepareLibraryLayout target -->
  <Target Name="CopyGeneratedXaml" BeforeTargets="CopyFilesToOutputDirectory" DependsOnTargets="Prep_ComputeProcessXamlFiles" Condition="'$(GenerateLibraryLayout)' != 'true'">
    <Copy SourceFiles="@(GeneratedXamlSrc)" DestinationFiles="@(GeneratedXamlDest)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" />
    <ItemGroup>
      <FileWrites Include="@(GeneratedXamlDest)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeProcessXamlFiles" Returns="@(ProcessedXamlFiles)" DependsOnTargets="Prep_ComputeProcessXamlFiles">
    <ItemGroup>
      <!-- In the normal (non-SDK) build, AppX Packaging picks up the files from the bin aka OutputPath folder -->
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' != 'true'" Include="@(GeneratedXamlDest)" />
      <!-- In the SDK build, AppX Packaging picks up the files from the XamlGeneratedOutput folder -->
      <!-- For SDK builds include both the XAML and XBF -->
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' == 'true'" Include="@(GeneratedXamlSrc)" />
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' == 'true' and '$(DisableXbfGeneration)' != 'true'" Include="@(GeneratedXamlSrc0)" />
    </ItemGroup>
    <Message Importance="Low" Text="(Out) GeneratedXamlDest == @(GeneratedXamlDest)" />
    <Message Importance="Low" Text="(Out) GeneratedXamlSrc == @(GeneratedXamlSrc)" />
    <Message Text="(Out) ProcessedXamlFiles == @(ProcessedXamlFiles)" />
  </Target>
  <Target Name="CustomOutputGroupForPackaging" DependsOnTargets="ComputeProcessXamlFiles" Returns="@(CustomOutputGroupForPackagingOutput)">
    <ItemGroup>
      <ProcessedXamlFilesFullPath Include="@(ProcessedXamlFiles->'%(FullPath)')" />
    </ItemGroup>
    <PropertyGroup>
      <XamlPackagingRootFolder Condition="'$(GenerateLibraryLayout)' == 'true'">$(XamlGeneratedOutputPath)</XamlPackagingRootFolder>
      <XamlPackagingRootFolder Condition="'$(GenerateLibraryLayout)' != 'true'">$(OutputPath)\</XamlPackagingRootFolder>
    </PropertyGroup>
    <AssignTargetPath Files="@(ProcessedXamlFilesFullPath)" RootFolder="$(XamlPackagingRootFolder)">
      <Output TaskParameter="AssignedFiles" ItemName="CustomOutputGroupForPackagingOutput" />
    </AssignTargetPath>
    <Message Text="(Out) Project='$(MsBuildProjectName)' ProcessedXamlFiles == @(ProcessedXamlFiles)" />
    <Message Text="(Out) XamlPackagingRootFolder == $(XamlPackagingRootFolder)" />
    <Message Text="(Out) ProcessedXamlFilesFullPath == @(ProcessedXamlFilesFullPath)" />
    <Message Text="(Out) Project='$(MsBuildProjectName)' CustomOutputGroupForPackagingOutput == @(CustomOutputGroupForPackagingOutput)" />
  </Target>
  <PropertyGroup>
    <PrepareLibraryLayoutDependsOn>
            GetPackagingOutputs;
            $(PrepareLibraryLayoutDependsOn)
        </PrepareLibraryLayoutDependsOn>
  </PropertyGroup>
  <!-- This builds the Bin Folder for DLL's that wish to have the SDK type layout -->
  <Target Name="PrepareLibraryLayout" Condition="'$(GenerateLibraryLayout)' == 'true'" DependsOnTargets="$(PrepareLibraryLayoutDependsOn)" BeforeTargets="CopyFilesToOutputDirectory">
    <ItemGroup>
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup'" />
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging'" />
    </ItemGroup>
    <Copy SourceFiles="@(_LayoutFile)" DestinationFiles="@(_LayoutFile->'$(OutputPath)\%(TargetPath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" />
  </Target>
  <!--
    ============================================================
    Properties and Targets Common to Managed .NETCore projects
    ============================================================
    -->
  <!--
      The ImplicitlyExpandTargetFramework target will expand all 
      of the dll reference assemblies in the TargetFrameworkDirectory 
      for the project and place the items into the ReferencePath itemgroup 
      which contains resolved items.
    -->
  <PropertyGroup>
    <ResolveReferencesDependsOn>
            $(ResolveReferencesDependsOn);
            ImplicitlyExpandTargetFramework;
            ImplicitlyExpandTargetPlatform
        </ResolveReferencesDependsOn>
    <ImplicitlyExpandTargetFrameworkDependsOn>
            $(ImplicitlyExpandTargetFrameworkDependsOn);
            GetReferenceAssemblyPaths
        </ImplicitlyExpandTargetFrameworkDependsOn>
  </PropertyGroup>
  <Target Name="ImplicitlyExpandTargetFramework" Condition="'$(ImplicitlyExpandTargetFramework)' == 'true'" DependsOnTargets="$(ImplicitlyExpandTargetFrameworkDependsOn)">
    <ItemGroup>
      <ReferenceAssemblyPaths Include="$(_TargetFrameworkDirectories)" />
      <ReferencePath Include="%(ReferenceAssemblyPaths.Identity)*.dll">
        <WinMDFile>false</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGroupingDisplayName>.NET for Windows Store apps</ReferenceGroupingDisplayName>
        <ReferenceGrouping>$(TargetFrameworkMoniker)</ReferenceGrouping>
        <ResolvedFrom>ImplicitlyExpandTargetFramework</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </ReferencePath>
    </ItemGroup>
    <Message Importance="Low" Text="TargetMonikerDisplayName: $(TargetFrameworkMonikerDisplayName) ReferenceAssemblyPaths: @(ReferenceAssemblyPaths)" />
    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    <ItemGroup>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    </ItemGroup>
  </Target>
  <!--
      The ImplicitlyExpandTargetPlatform target will expand all
      of the winmd files in the windowsSDK and add them the the
      ReferencePath item which is the itemgroup which contains
      resolved items.
    -->
  <Target Name="ImplicitlyExpandTargetPlatform" Condition="'$(ImplicitlyExpandTargetPlatform)' == 'true'">
    <ItemGroup>
      <ReferencePath Include="$(TargetPlatformWinMDLocation)\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>ImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </ReferencePath>
    </ItemGroup>
    <Warning Condition="!Exists($(TargetPlatformWinMDLocation))" Text="The path to the $(TargetPlatformIdentifier) SDK [$(TargetPlatformWinMDLocation)] was not found!" />
    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetPlatform'" />
    <ItemGroup>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetPlatform'" />
    </ItemGroup>
  </Target>
  <!-- 
      Enable warning when referenced projects have higher version than the current project
      for Windows Store projects 
    -->
  <PropertyGroup>
    <FindInvalidProjectReferences Condition="'$(TargetPlatformIdentifier)' == 'Windows' and &#xD;&#xA;                                              '$(TargetPlatformVersion)' &gt;= '8.0'">true</FindInvalidProjectReferences>
  </PropertyGroup>
  <!-- 
      Enable warning when referenced ESDKs do not have MaxPlatformVersion 
      specified for Windows Store projects 
    -->
  <PropertyGroup>
    <SDKReferenceWarnOnMissingMaxPlatformVersion Condition="'$(SDKReferenceWarnOnMissingMaxPlatformVersion)' == '' and &#xD;&#xA;                                                             '$(TargetPlatformIdentifier)' == 'Windows' and &#xD;&#xA;                                                             '$(TargetPlatformVersion)' &gt;= '8.0'">true</SDKReferenceWarnOnMissingMaxPlatformVersion>
  </PropertyGroup>
  <!--<Import Project="ImportAfter\*" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\VisualStudio\v14.0\Microsoft.Portable.CurrentVersion.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- As there is not a good way to filter architectures/configurations from a VS perspective, we 
             opt into all architectures, and then error when the user targets a platform that is not supported. 
             NOTE: That Common targets blindly sets AvailablePlatforms, so we need to set it after them.
         -->
    <AvailablePlatforms>Any CPU,x86,x64,ARM</AvailablePlatforms>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.VisualStudio.PortableLibrary.Build.Tasks.GetPlatformWinMDLocation" AssemblyFile="Microsoft.VisualStudio.PortableLibrary.Build.Tasks.dll" />
  <PropertyGroup>
    <ResolveReferencesDependsOn>
            $(ResolveReferencesDependsOn);
            ImplicitlyExpandTargetPlatform
        </ResolveReferencesDependsOn>
    <ImplicitlyExpandTargetPlatformDependsOn>
            $(ImplicitlyExpandTargetPlatformDependsOn);
            GetTargetPlatformWinMDLocation
        </ImplicitlyExpandTargetPlatformDependsOn>
    <PrepareForRunDependsOn>
            DeterminePortablePlatformSdkPath;
            DeterminePortableBuildCapabilities;
            $(PrepareForRunDependsOn)
        </PrepareForRunDependsOn>
    <DeterminePortablePlatformSdkPathDependsOn>
            $(DeterminePortablePlatformSdkPathDependsOn);
            GetTargetPlatformWinMDLocation
        </DeterminePortablePlatformSdkPathDependsOn>
    <DeterminePortableBuildCapabilitiesDependsOn>
            $(DeterminePortableBuildCapabilitiesDependsOn);
            ImplicitlyExpandTargetFramework;
        </DeterminePortableBuildCapabilitiesDependsOn>
    <GetPackagingOutputsDependsOn>
            $(GetPackagingOutputsDependsOn);
            DeterminePortableBuildCapabilities
        </GetPackagingOutputsDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <TargetPlatformRootPath Condition="'$(TargetPlatformRootPath)' == ''">$(PortableSDKRoot)</TargetPlatformRootPath>
  </PropertyGroup>
  <!-- 
        Given two or more targeted platforms, finds the location of the WinMDs 
        that represent the intersection between those platforms.
    -->
  <Target Name="GetTargetPlatformWinMDLocation" Condition="'@(TargetPlatform)' != '' and $(TargetPlatformWinMDLocation) == ''">
    <GetPlatformWinMDLocation Platforms="@(TargetPlatform)" RootPath="$(TargetPlatformRootPath)">
      <Output TaskParameter="PlatformWinMDLocation" PropertyName="TargetPlatformWinMDLocation" />
    </GetPlatformWinMDLocation>
  </Target>
  <!--
        The ImplicitlyExpandTargetPlatform target will expand all of the winmd 
        files in the Windows SDK and add them the the ReferencePath item which is 
        the itemgroup which contains resolved items.
    -->
  <Target Name="ImplicitlyExpandTargetPlatform" Condition="'$(ImplicitlyExpandTargetPlatform)' == 'true'" DependsOnTargets="$(ImplicitlyExpandTargetPlatformDependsOn)">
    <ItemGroup>
      <ReferencePath Include="$(TargetPlatformWinMDLocation)\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformMonikerDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>ImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </ReferencePath>
    </ItemGroup>
    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetPlatform'" />
    <ItemGroup>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetPlatform'" />
    </ItemGroup>
  </Target>
  <!--
        Determines which path to use for PlatformSDK.
     -->
  <Target Name="DeterminePortablePlatformSdkPath" DependsOnTargets="$(DeterminePortablePlatformSdkPathDependsOn)">
    <ItemGroup>
      <!--
              Allow for SDK configuration next to the intersected WinMD, this enables scenarios where we
              need different tool configuration based on the target platform combination.
            -->
      <_PortableTargetPlatformSdkRootOverride Condition="'$(TargetPlatformWinMDLocation)' != ''" Include="$(TargetPlatformWinMDLocation)\**\windows.props" />
    </ItemGroup>
    <PropertyGroup>
      <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == '' and '@(_PortableTargetPlatformSdkRootOverride)' != ''">$(TargetPlatformWinMDLocation)</TargetPlatformSdkRootOverride>
      <!-- Default to the per version root if we don't have per-intersection configuration -->
      <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == ''">$(PortableSDKRoot)</TargetPlatformSdkRootOverride>
    </PropertyGroup>
  </Target>
  <Target Name="DeterminePortableBuildCapabilities" DependsOnTargets="$(DeterminePortableBuildCapabilitiesDependsOn)">
    <PropertyGroup>
      <!-- Use a heuristic to determine if resources are supported.  Currently this matches the check used by the project system.
                 Ideally this would be the result of a type lookup in Windows.winmd -->
      <_PortablePriResourcesEnabled Condition="'%(ReferencePath.FileName)' == 'System.Runtime.WindowsRuntime.UI.Xaml'">true</_PortablePriResourcesEnabled>
      <!-- Use a heuristic to determine if we can enable references in GetPackageOutputs.
                 Currently we use the same heuristic as we do for resources.
                 Older platforms don't support conflict resolution for reference in packaging outputs,
                 instead we'll rely on ResolveAssemblyReferences to flow the right refernces to the app. -->
      <PortableReferencePackagingEnabled Condition="'$(PortableReferencePackagingEnabled)' ==''">$(_PortablePriResourcesEnabled)</PortableReferencePackagingEnabled>
    </PropertyGroup>
    <Message Importance="Low" Condition="'$(_PortablePriResourcesEnabled)' != 'true'" Text="Disabling pri resource targets." />
    <PropertyGroup Condition="'$(_PortablePriResourcesEnabled)' != 'true'">
      <AppxGeneratePriEnabled>false</AppxGeneratePriEnabled>
      <AppxGeneratePrisForPortableLibrariesEnabled>false</AppxGeneratePrisForPortableLibrariesEnabled>
      <AppxGetPackagePropertiesEnabled>false</AppxGetPackagePropertiesEnabled>
      <IncludeProjectPriFile>false</IncludeProjectPriFile>
    </PropertyGroup>
    <Message Importance="Low" Condition="'$(PortableReferencePackagingEnabled)' != 'true'" Text="Excluding copy local references from packaging output." />
    <PropertyGroup Condition="'$(PortableReferencePackagingEnabled)' != 'true'">
      <IncludeCopyLocalFilesOutputGroup>false</IncludeCopyLocalFilesOutputGroup>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\Microsoft.Portable.Core.targets
============================================================================================================================================
-->
  <Target Name="_CheckForInvalidTargetFrameworkProfile" AfterTargets="_CheckForInvalidConfigurationAndPlatform">
    <Error Condition="'$(TargetFrameworkProfile)' == '' AND '$(PortableNuGetMode)' != 'true'" Text="The TargetFrameworkProfile property is not set for project '$(MSBuildProjectFile)'. Portable projects must specify a profile." />
  </Target>
  <!-- 
        To prevent framework assembly references from being unified to the ones in the full 
        framework (for example, System.Net.Primitives, v3.9.0.0 -> System.Net.Primitives, v4.0.0.0), 
        we set the full framework folder to the profile folder so that RAR thinks that the 
        profile itself is the full framework. Given that we don't actually use our full framework,
        we do not need any of the warnings from RAR that are turned off because of this.
    -->
  <Target Name="_SetFullFrameworkFolderToProfile" AfterTargets="GetReferenceAssemblyPaths">
    <PropertyGroup>
      <_FullFrameworkReferenceAssemblyPaths>$(TargetFrameworkDirectory)</_FullFrameworkReferenceAssemblyPaths>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <ResolveReferencesDependsOn>
            $(ResolveReferencesDependsOn);
            ImplicitlyExpandTargetFramework;
        </ResolveReferencesDependsOn>
    <ImplicitlyExpandTargetFrameworkDependsOn>
            $(ImplicitlyExpandTargetFrameworkDependsOn);
            GetReferenceAssemblyPaths
        </ImplicitlyExpandTargetFrameworkDependsOn>
  </PropertyGroup>
  <!--
        The ImplicitlyExpandTargetFramework target will expand all 
        of the dll reference assemblies in the TargetFrameworkDirectory 
        for the project and place the items into the ReferencePath itemgroup 
        which contains resolved items.
    -->
  <Target Name="ImplicitlyExpandTargetFramework" Condition="'$(ImplicitlyExpandTargetFramework)' == 'true'" DependsOnTargets="$(ImplicitlyExpandTargetFrameworkDependsOn)">
    <ItemGroup>
      <ReferenceAssemblyPaths Include="$(_TargetFrameworkDirectories)" />
      <ReferencePath Include="%(ReferenceAssemblyPaths.Identity)*.dll">
        <WinMDFile>false</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGroupingDisplayName>.NET</ReferenceGroupingDisplayName>
        <ReferenceGrouping>$(TargetFrameworkIdentifier),$(TargetFrameworkVersion)</ReferenceGrouping>
        <ResolvedFrom>ImplicitlyExpandTargetFramework</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </ReferencePath>
    </ItemGroup>
    <Message Importance="Low" Text="TargetMonikerDisplayName: $(TargetFrameworkMonikerDisplayName) ReferenceAssemblyPaths: @(ReferenceAssemblyPaths)" />
    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    <ItemGroup>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\MSBuild\Microsoft\Portable\v5.0\Microsoft.Portable.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\dir.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)/publishexe.targets">

D:\OSS\NetCoreGameEngine\publishexe.targets
============================================================================================================================================
-->
  <Target Name="PublishFilesToRuntime" AfterTargets="CopyFilesToOutputDirectory" Condition="'$(OutputType)' == 'Exe' ">
    <ItemGroup>
      <PublishedRuntimeItems Include="@(ReferenceCopyLocalPaths)">
        <DestinationRelativePath>%(FileName)%(Extension)</DestinationRelativePath>
      </PublishedRuntimeItems>
      <PublishedRuntimeItems Include="@(Content)">
        <DestinationRelativePath>%(FileName)%(Extension)</DestinationRelativePath>
      </PublishedRuntimeItems>
      <PublishedRuntimeItems Include="@(None)">
        <DestinationRelativePath>%(Filename)%(Extension)</DestinationRelativePath>
      </PublishedRuntimeItems>
    </ItemGroup>
    <Copy SourceFiles="%(PublishedRuntimeItems.Identity)" DestinationFiles="$(Outdir)%(DestinationRelativePath)" SkipUnchangedFiles="true" />
    <CallTarget Targets="FixUpCoreConsoleNames" Condition="Exists('$(Outdir)CoreConsole.exe')" />
    <Message Text="Published $(AssemblyName) executable to $(Outdir) [@(PublishedRuntimeItems-&gt;Count()) items]" Importance="high" />
  </Target>
  <!-- If CoreConsole.exe is being used, rename it and the actual project's exe to their correct names -->
  <Target Name="FixUpCoreConsoleNames">
    <Move SourceFiles="$(Outdir)$(AssemblyName).exe" DestinationFiles="$(Outdir)$(AssemblyName).dll" />
    <Move SourceFiles="$(Outdir)CoreConsole.exe" DestinationFiles="$(Outdir)$(AssemblyName).exe" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\dir.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\src\dir.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

D:\OSS\NetCoreGameEngine\src\EngineCore\EngineCore.csproj
============================================================================================================================================
-->
</Project>