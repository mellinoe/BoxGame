<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ImageProcessor</name>
    </assembly>
    <members>
        <member name="T:ImageProcessor.IImage">
            <summary>
            Encapsulates an image, which consists of the pixel data for a graphics image and its attributes.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImage.HorizontalResolution">
            <summary>
            Gets or sets the resolution of the image in x- direction. It is defined as
             number of dots per inch and should be an positive value.
            </summary>
            <value>The density of the image in x- direction.</value>
        </member>
        <member name="P:ImageProcessor.IImage.VerticalResolution">
            <summary>
            Gets or sets the resolution of the image in y- direction. It is defined as
            number of dots per inch and should be an positive value.
            </summary>
            <value>The density of the image in y- direction.</value>
        </member>
        <member name="P:ImageProcessor.IImage.InchWidth">
            <summary>
            Gets the width of the image in inches. It is calculated as the width of the image
            in pixels multiplied with the density. When the density is equals or less than zero
            the default value is used.
            </summary>
            <value>The width of the image in inches.</value>
        </member>
        <member name="P:ImageProcessor.IImage.InchHeight">
            <summary>
            Gets the height of the image in inches. It is calculated as the height of the image
            in pixels multiplied with the density. When the density is equals or less than zero
            the default value is used.
            </summary>
            <value>The height of the image in inches.</value>
        </member>
        <member name="P:ImageProcessor.IImage.IsAnimated">
            <summary>
            Gets a value indicating whether this image is animated.
            </summary>
            <value>
            <c>True</c> if this image is animated; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ImageProcessor.IImage.RepeatCount">
            <summary>
            Gets or sets the number of times any animation is repeated.
            <remarks>0 means to repeat indefinitely.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.IImage.CurrentImageFormat">
            <summary>
            Gets the currently loaded image format.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImage.Frames">
            <summary>
            Gets the other frames for the animation.
            </summary>
            <value>The list of frame images.</value>
        </member>
        <member name="P:ImageProcessor.IImage.Properties">
            <summary>
            Gets the list of properties for storing meta information about this image.
            </summary>
            <value>A list of image properties.</value>
        </member>
        <member name="M:ImageProcessor.IImage.Save(System.IO.Stream)">
            <summary>
            Saves the image to the given stream using the currently loaded image format.
            </summary>
            <param name="stream">The stream to save the image to.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="M:ImageProcessor.IImage.Save(System.IO.Stream,ImageProcessor.Formats.IImageFormat)">
            <summary>
            Saves the image to the given stream using the given image format.
            </summary>
            <param name="stream">The stream to save the image to.</param>
            <param name="format">The format to save the image as.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="T:ImageProcessor.IImageBase">
            <summary>
            Encapsulates the basic properties and methods required to manipulate images.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.Pixels">
            <summary>
            Gets the image pixels as byte array.
            </summary>
            <remarks>
            The returned array has a length of Width * Height * 4 bytes
            and stores the blue, the green, the red and the alpha value for
            each pixel in this order.
            </remarks>
        </member>
        <member name="P:ImageProcessor.IImageBase.Width">
            <summary>
            Gets the width in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.Height">
            <summary>
            Gets the height in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.PixelRatio">
            <summary>
            Gets the pixel ratio made up of the width and height.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.Bounds">
            <summary>
            Gets the <see cref="T:ImageProcessor.Rectangle"/> representing the bounds of the image.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.Quality">
            <summary>
            Gets or sets th quality of the image. This affects the output quality of lossy image formats.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.FrameDelay">
            <summary>
            Gets or sets the frame delay for animated images.
            If not 0, this field specifies the number of hundredths (1/100) of a second to
            wait before continuing with the processing of the Data Stream.
            The clock starts ticking immediately after the graphic is rendered.
            </summary>
        </member>
        <member name="P:ImageProcessor.IImageBase.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the color of a pixel at the specified position.
            </summary>
            <param name="x">
            The x-coordinate of the pixel. Must be greater
            than zero and smaller than the width of the pixel.
            </param>
            <param name="y">
            The y-coordinate of the pixel. Must be greater
            than zero and smaller than the width of the pixel.
            </param>
            <returns>The <see cref="T:ImageProcessor.Color"/> at the specified position.</returns>
        </member>
        <member name="M:ImageProcessor.IImageBase.SetPixels(System.Int32,System.Int32,System.Single[])">
            <summary>
            Sets the pixel array of the image.
            </summary>
            <param name="width">
            The new width of the image. Must be greater than zero.</param>
            <param name="height">The new height of the image. Must be greater than zero.</param>
            <param name="pixels">
            The array with colors. Must be a multiple
            of four, width and height.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if either <paramref name="width"/> or <paramref name="height"/> are less than or equal to 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the <paramref name="pixels"/> length is not equal to Width * Height * 4.
            </exception>
        </member>
        <member name="T:ImageProcessor.IImageProcessor">
            <summary>
            Encapsulates methods to alter the pixels of an image.
            </summary>
        </member>
        <member name="M:ImageProcessor.IImageProcessor.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle)">
            <summary>
            Applies the process to the specified portion of the specified <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="target">Target image to apply the process to.</param>
            <param name="source">The source image. Cannot be null.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <remarks>
            The method keeps the source image unchanged and returns the
            the result of image processing filter as new image.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="target"/> is null or <paramref name="source"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="sourceRectangle"/> doesnt fit the dimension of the image.
            </exception>
        </member>
        <member name="M:ImageProcessor.IImageProcessor.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,System.Int32,System.Int32,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <summary>
            Applies the process to the specified portion of the specified <see cref="T:ImageProcessor.ImageBase"/> at the specified
            location and with the specified size.
            </summary>
            <param name="target">Target image to apply the process to.</param>
            <param name="source">The source image. Cannot be null.</param>
            <param name="width">The target width.</param>
            <param name="height">The target height.</param>
            <param name="targetRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the location and size of the drawn image.
            The image is scaled to fit the rectangle.
            </param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <remarks>
            The method keeps the source image unchanged and returns the
            the result of image process as new image.
            </remarks>
        </member>
        <member name="T:ImageProcessor.Image">
            <summary>
            Encapsulates an image, which consists of the pixel data for a graphics image and its attributes.
            </summary>
            <remarks>
            The image data is always stored in BGRA format, where the blue, green, red, and
            alpha values are simple bytes.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Image.DefaultHorizontalResolution">
            <summary>
            The default horizontal resolution value (dots per inch) in x direction.
            <remarks>The default value is 96 dots per inch.</remarks>
            </summary>
        </member>
        <member name="F:ImageProcessor.Image.DefaultVerticalResolution">
            <summary>
            The default vertical resolution value (dots per inch) in y direction.
            <remarks>The default value is 96 dots per inch.</remarks>
            </summary>
        </member>
        <member name="F:ImageProcessor.Image.DefaultFormats">
            <summary>
            The default collection of <see cref="T:ImageProcessor.Formats.IImageFormat"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Image.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Image"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.Image.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Image"/> class
            with the height and the width of the image.
            </summary>
            <param name="width">The width of the image in pixels.</param>
            <param name="height">The height of the image in pixels.</param>
        </member>
        <member name="M:ImageProcessor.Image.#ctor(ImageProcessor.Image)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Image"/> class
            by making a copy from another image.
            </summary>
            <param name="other">The other image, where the clone should be made from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="M:ImageProcessor.Image.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Image"/> class.
            </summary>
            <param name="stream">
            The stream containing image information.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown if the <paramref name="stream"/> is null.</exception>
        </member>
        <member name="M:ImageProcessor.Image.#ctor(System.IO.Stream,ImageProcessor.Formats.IImageFormat[])">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Image"/> class.
            </summary>
            <param name="stream">
            The stream containing image information.
            </param>
            <param name="formats">
            The collection of <see cref="T:ImageProcessor.Formats.IImageFormat"/>.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="P:ImageProcessor.Image.Formats">
            <summary>
            Gets a list of supported image formats.
            </summary>
        </member>
        <member name="P:ImageProcessor.Image.HorizontalResolution">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.VerticalResolution">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.InchWidth">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.InchHeight">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.IsAnimated">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.RepeatCount">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.Frames">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.Properties">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Image.CurrentImageFormat">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Image.Save(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Image.Save(System.IO.Stream,ImageProcessor.Formats.IImageFormat)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Image.Load(System.IO.Stream,System.Collections.Generic.IList{ImageProcessor.Formats.IImageFormat})">
            <summary>
            Loads the image from the given stream.
            </summary>
            <param name="stream">
            The stream containing image information.
            </param>
            <param name="formats">
            The collection of <see cref="T:ImageProcessor.Formats.IImageFormat"/>.
            </param>
            <exception cref="T:System.NotSupportedException">
            Thrown if the stream is not readable nor seekable.
            </exception>
        </member>
        <member name="T:ImageProcessor.ImageBase">
            <summary>
            The base class of all images. Encapsulates the basic properties and methods
            required to manipulate images.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageBase"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageBase.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageBase"/> class.
            </summary>
            <param name="width">
            The width of the image in pixels.
            </param>
            <param name="height">
            The height of the image in pixels.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if either <paramref name="width"/> or <paramref name="height"/> are less than or equal to 0.
            </exception>
        </member>
        <member name="M:ImageProcessor.ImageBase.#ctor(ImageProcessor.ImageBase)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageBase"/> class.
            </summary>
            <param name="other">
            The other <see cref="T:ImageProcessor.ImageBase"/> to create this instance from.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the given <see cref="T:ImageProcessor.ImageBase"/> is null.
            </exception>
        </member>
        <member name="P:ImageProcessor.ImageBase.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.MaxHeight">
            <summary>
            Gets or sets the maximum allowable height in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.Pixels">
            <summary>
            Gets the image pixels as byte array.
            </summary>
            <remarks>
            The returned array has a length of Width * Height * 4 bytes
            and stores the blue, the green, the red and the alpha value for
            each pixel in this order.
            </remarks>
        </member>
        <member name="P:ImageProcessor.ImageBase.Width">
            <summary>
            Gets the width in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.Height">
            <summary>
            Gets the height in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.PixelRatio">
            <summary>
            Gets the pixel ratio made up of the width and height.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.Bounds">
            <summary>
            Gets the <see cref="T:ImageProcessor.Rectangle"/> representing the bounds of the image.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.Quality">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.ImageBase.FrameDelay">
            <summary>
            Gets or sets the frame delay for animated images.
            If not 0, this field specifies the number of hundredths (1/100) of a second to
            wait before continuing with the processing of the Data Stream.
            The clock starts ticking immediately after the graphic is rendered.
            </summary>
        </member>
        <member name="P:ImageProcessor.ImageBase.Item(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.ImageBase.SetPixels(System.Int32,System.Int32,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.ImageExtensions">
            <summary>
            Exstension methods for the <see cref="T:ImageProcessor.Image"/> type.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.SaveAsBmp(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Saves the image to the given stream with the bmp format.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="stream">The stream to save the image to.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.SaveAsPng(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Saves the image to the given stream with the png format.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="stream">The stream to save the image to.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.SaveAsJpeg(ImageProcessor.ImageBase,System.IO.Stream,System.Int32)">
            <summary>
            Saves the image to the given stream with the jpeg format.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="stream">The stream to save the image to.</param>
            <param name="quality">The quality to save the image to. Between 1 and 100.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.SaveAsGif(ImageProcessor.ImageBase,System.IO.Stream,System.Int32)">
            <summary>
            Saves the image to the given stream with the gif format.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="stream">The stream to save the image to.</param>
            <param name="quality">The quality to save the image to representing the number of colors. Between 1 and 100.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the stream is null.</exception>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.Process(ImageProcessor.Image,ImageProcessor.IImageProcessor[])">
            <summary>
            Applies the collection of processors to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="processors">Any processors to apply to the image.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.Process(ImageProcessor.Image,ImageProcessor.Rectangle,ImageProcessor.IImageProcessor[])">
            <summary>
            Applies the collection of processors to the image.
            <remarks>This method does not resize the target image.</remarks>
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <param name="processors">Any processors to apply to the image.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.Process(ImageProcessor.Image,System.Int32,System.Int32,ImageProcessor.IImageProcessor[])">
            <summary>
            Applies the collection of processors to the image.
            </summary>
            <param name="source">The source image. Cannot be null.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <param name="processors">Any processors to apply to the image.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.Process(ImageProcessor.Image,System.Int32,System.Int32,ImageProcessor.Rectangle,ImageProcessor.Rectangle,ImageProcessor.IImageProcessor[])">
            <summary>
            Applies the collection of processors to the image.
            <remarks>
            This method does will resize the target image if the source and target
            rectangles are different.
            </remarks>
            </summary>
            <param name="source">The source image. Cannot be null.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <param name="targetRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the location and size of the drawn image.
            The image is scaled to fit the rectangle.
            </param>
            <param name="processors">Any processors to apply to the image.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.ImageExtensions.PerformAction(ImageProcessor.Image,System.Boolean,System.Action{ImageProcessor.ImageBase,ImageProcessor.ImageBase})">
            <summary>
            Performs the given action on the source image.
            </summary>
            <param name="source">The image to perform the action against.</param>
            <param name="clone">Whether to clone the image.</param>
            <param name="action">The <see cref="T:System.Action"/> to perform against the image.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="T:ImageProcessor.ImageFrame">
            <summary>
            Represents a single frame in a animation.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageFrame.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageFrame"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageFrame.#ctor(ImageProcessor.ImageFrame)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageFrame"/> class.
            </summary>
            <param name="other">
            The other <see cref="T:ImageProcessor.ImageBase"/> to create this instance from.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the given <see cref="T:ImageProcessor.ImageFrame"/> is null.
            </exception>
        </member>
        <member name="T:ImageProcessor.ImageProperty">
            <summary>
            Stores meta information about a image, like the name of the author,
            the copyright information, the date, where the image was created
            or some other information.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageProperty.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageProperty"/> struct.
            </summary>
            <param name="name">
            The name of the property.
            </param>
            <param name="value">
            The value of the property.
            </param>
        </member>
        <member name="P:ImageProcessor.ImageProperty.Name">
            <summary>
            Gets the name of this <see cref="T:ImageProcessor.ImageProperty"/> indicating which kind of
            information this property stores.
            </summary>
            <example>
            Typical properties are the author, copyright
            information or other meta information.
            </example>
        </member>
        <member name="P:ImageProcessor.ImageProperty.Value">
            <summary>
            The value of this <see cref="T:ImageProcessor.ImageProperty"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageProperty.op_Equality(ImageProcessor.ImageProperty,ImageProcessor.ImageProperty)">
            <summary>
            Compares two <see cref="T:ImageProcessor.ImageProperty"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.ImageProperty.Name"/> or <see cref="P:ImageProcessor.ImageProperty.Value"/> properties of the two
            <see cref="T:ImageProcessor.ImageProperty"/> objects are equal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.ImageProperty"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.ImageProperty"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageProperty.op_Inequality(ImageProcessor.ImageProperty,ImageProcessor.ImageProperty)">
            <summary>
            Compares two <see cref="T:ImageProcessor.ImageProperty"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.ImageProperty.Name"/> or <see cref="P:ImageProcessor.ImageProperty.Value"/> properties of the two
            <see cref="T:ImageProcessor.ImageProperty"/> objects are unequal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.ImageProperty"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.ImageProperty"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageProperty.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <param name="obj">
            The object to compare with the current instance.
            </param>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the
            same value; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageProperty.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageProperty.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageProperty.Equals(ImageProcessor.ImageProperty)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            True if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="T:ImageProcessor.ParallelImageProcessor">
            <summary>
            Allows the application of processors using parallel processing.
            </summary>
        </member>
        <member name="P:ImageProcessor.ParallelImageProcessor.Parallelism">
            <summary>
            Gets or sets the count of workers to run the process in parallel.
            </summary>
        </member>
        <member name="M:ImageProcessor.ParallelImageProcessor.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.ParallelImageProcessor.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,System.Int32,System.Int32,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.ParallelImageProcessor.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <summary>
            This method is called before the process is applied to prepare the processor.
            </summary>
            <param name="source">The source image. Cannot be null.</param>
            <param name="targetRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the location and size of the drawn image.
            The image is scaled to fit the rectangle.
            </param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
        </member>
        <member name="M:ImageProcessor.ParallelImageProcessor.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <summary>
            Applies the process to the specified portion of the specified <see cref="T:ImageProcessor.ImageBase"/> at the specified location
            and with the specified size.
            </summary>
            <param name="target">Target image to apply the process to.</param>
            <param name="source">The source image. Cannot be null.</param>
            <param name="targetRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the location and size of the drawn image.
            The image is scaled to fit the rectangle.
            </param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <param name="startY">The index of the row within the source image to start processing.</param>
            <param name="endY">The index of the row within the source image to end processing.</param>
            <remarks>
            The method keeps the source image unchanged and returns the
            the result of image process as new image.
            </remarks>
        </member>
        <member name="T:ImageProcessor.Color">
            <summary>
            Represents a four-component color using red, green, blue, and alpha data.
            </summary>
            <remarks>
            This struct is fully mutable. This is done (against the guidelines) for the sake of performance,
            as it avoids the need to create new values for modification operations.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Color.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Color"/> that has R, G, B, and A values set to zero.
            </summary>
        </member>
        <member name="F:ImageProcessor.Color.Epsilon">
            <summary>
            The epsilon for comparing floating point numbers.
            </summary>
        </member>
        <member name="F:ImageProcessor.Color.backingVector">
            <summary>
            The backing vector for SIMD support.
            </summary>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct with the alpha component set to 1.
            </summary>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Color"/>.</param>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct.
            </summary>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="a">The alpha component of this <see cref="T:ImageProcessor.Color"/>.</param>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct.
            </summary>
            <param name="hex">
            The hexadecimal representation of the combined color components arranged
            in rgb, rrggbb, or aarrggbb format to match web syntax.
            </param>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.Numerics.Vector4)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct.
            </summary>
            <param name="vector">
            The vector.
            </param>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.Numerics.Vector3)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct.
            </summary>
            <param name="vector">
            The vector representing the red, green, and blue componenets.
            </param>
        </member>
        <member name="M:ImageProcessor.Color.#ctor(System.Numerics.Vector3,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Color"/> struct.
            </summary>
            <param name="vector">
            The vector representing the red, green, and blue componenets.
            </param>
            <param name="alpha">The alpha component.</param>
        </member>
        <member name="P:ImageProcessor.Color.R">
            <summary>
            Gets or sets the red component of the color.
            </summary>
        </member>
        <member name="P:ImageProcessor.Color.G">
            <summary>
            Gets or sets the green component of the color.
            </summary>
        </member>
        <member name="P:ImageProcessor.Color.B">
            <summary>
            Gets or sets the blue component of the color.
            </summary>
        </member>
        <member name="P:ImageProcessor.Color.A">
            <summary>
            Gets or sets the alpha component of the color.
            </summary>
        </member>
        <member name="P:ImageProcessor.Color.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Color"/> is empty.
            </summary>
        </member>
        <member name="P:ImageProcessor.Color.Limited">
            <summary>
            Gets this color with the component values clamped from 0 to 1.
            </summary>
        </member>
        <member name="M:ImageProcessor.Color.op_Implicit(ImageProcessor.Bgra32)~ImageProcessor.Color">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Color"/> to a
            <see cref="T:ImageProcessor.Bgra32"/>.
            </summary>
            <param name="color">The instance of <see cref="T:ImageProcessor.Color"/> to convert.</param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Bgra32"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Implicit(ImageProcessor.Cmyk)~ImageProcessor.Color">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Cmyk"/> to a
            <see cref="T:ImageProcessor.Color"/>.
            </summary>
            <param name="cmykColor">The instance of <see cref="T:ImageProcessor.Cmyk"/> to convert.</param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Implicit(ImageProcessor.YCbCr)~ImageProcessor.Color">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.YCbCr"/> to a
            <see cref="T:ImageProcessor.Color"/>.
            </summary>
            <param name="color">The instance of <see cref="T:ImageProcessor.YCbCr"/> to convert.</param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Implicit(ImageProcessor.Hsv)~ImageProcessor.Color">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Hsv"/> to a
            <see cref="T:ImageProcessor.Color"/>.
            </summary>
            <param name="color">The instance of <see cref="T:ImageProcessor.Hsv"/> to convert.</param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Multiply(ImageProcessor.Color,System.Single)">
            <summary>
            Computes the product of multiplying a color by a given factor.
            </summary>
            <param name="color">The color.</param>
            <param name="factor">The multiplication factor.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Multiply(System.Single,ImageProcessor.Color)">
            <summary>
            Computes the product of multiplying a color by a given factor.
            </summary>
            <param name="factor">The multiplication factor.</param>
            <param name="color">The color.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Multiply(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Computes the product of multiplying two colors.
            </summary>
            <param name="left">The color on the left hand of the operand.</param>
            <param name="right">The color on the right hand of the operand.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Addition(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Computes the sum of adding two colors.
            </summary>
            <param name="left">The color on the left hand of the operand.</param>
            <param name="right">The color on the right hand of the operand.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Subtraction(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Computes the difference left by subtracting one color from another.
            </summary>
            <param name="left">The color on the left hand of the operand.</param>
            <param name="right">The color on the right hand of the operand.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Equality(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Color"/> objects for equality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Color"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Color"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.op_Inequality(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Hsv"/> objects for inequality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Color"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Color"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.Average(ImageProcessor.Color,ImageProcessor.Color)">
            <summary>
            Returns a new color whose components are the average of the components of first and second.
            </summary>
            <param name="first">The first color.</param>
            <param name="second">The second color.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.Lerp(ImageProcessor.Color,ImageProcessor.Color,System.Single)">
            <summary>
            Linearly interpolates from one color to another based on the given amount.
            </summary>
            <param name="from">The first color value.</param>
            <param name="to">The second color value.</param>
            <param name="amount">
            The weight value. At amount = 0, "from" is returned, at amount = 1, "to" is returned.
            </param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.Compand(ImageProcessor.Color)">
            <summary>
            Compresseses a linear color signal to its sRGB equivalent.
            <see href="http://www.4p8.com/eric.brasseur/gamma.html#formulas"/>
            <see href="http://entropymine.com/imageworsener/srgbformula/"/>
            </summary>
            <param name="linear">The <see cref="T:ImageProcessor.Color"/> whos signal to compress.</param>
            <returns>The <see cref="T:ImageProcessor.Color"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Color.InverseCompand(ImageProcessor.Color)">
            <summary>
            Expands an sRGB color signal to its linear equivalent.
            <see href="http://www.4p8.com/eric.brasseur/gamma.html#formulas"/>
            <see href="http://entropymine.com/imageworsener/srgbformula/"/>
            </summary>
            <param name="gamma">The <see cref="T:ImageProcessor.Color"/> whos signal to expand.</param>
            <returns>The <see cref="T:ImageProcessor.Color"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Color.FromNonPremultiplied(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Converts a non-premultipled alpha <see cref="T:ImageProcessor.Color"/> to a <see cref="T:ImageProcessor.Color"/>
            that contains premultiplied alpha.
            </summary>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="a">The alpha component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <returns>The <see cref="T:ImageProcessor.Color"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Color.ToNonPremultiplied(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Converts a premultipled alpha <see cref="T:ImageProcessor.Color"/> to a <see cref="T:ImageProcessor.Color"/>
            that contains non-premultiplied alpha.
            </summary>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <param name="a">The alpha component of this <see cref="T:ImageProcessor.Color"/>.</param>
            <returns>The <see cref="T:ImageProcessor.Color"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Color.ToVector4">
            <summary>
            Gets a <see cref="T:System.Numerics.Vector4"/> representation for this <see cref="T:ImageProcessor.Color"/>.
            </summary>
            <returns>A <see cref="T:System.Numerics.Vector4"/> representation for this object.</returns>
        </member>
        <member name="M:ImageProcessor.Color.ToVector3">
            <summary>
            Gets a <see cref="T:System.Numerics.Vector3"/> representation for this <see cref="T:ImageProcessor.Color"/>.
            </summary>
            <returns>A <see cref="T:System.Numerics.Vector3"/> representation for this object.</returns>
        </member>
        <member name="M:ImageProcessor.Color.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Color.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Color.ToString">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Color.Equals(ImageProcessor.Color)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Color.Compand(System.Single)">
            <summary>
            Gets the compressed sRGB value from an linear signal.
            <see href="http://www.4p8.com/eric.brasseur/gamma.html#formulas"/>
            <see href="http://entropymine.com/imageworsener/srgbformula/"/>
            </summary>
            <param name="signal">The signal value to compress.</param>
            <returns>
            The <see cref="T:System.Single"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.InverseCompand(System.Single)">
            <summary>
            Gets the expanded linear value from an sRGB signal.
            <see href="http://www.4p8.com/eric.brasseur/gamma.html#formulas"/>
            <see href="http://entropymine.com/imageworsener/srgbformula/"/>
            </summary>
            <param name="signal">The signal value to expand.</param>
            <returns>
            The <see cref="T:System.Single"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Color.GetHashCode(ImageProcessor.Color)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Color"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Bgra32">
            <summary>
            Represents an BGRA (blue, green, red, alpha) color.
            </summary>
        </member>
        <member name="F:ImageProcessor.Bgra32.Empty">
            <summary>
            Represents a 32 bit <see cref="T:ImageProcessor.Bgra32"/> that has B, G, R, and A values set to zero.
            </summary>
        </member>
        <member name="F:ImageProcessor.Bgra32.backingVector">
            <summary>
            The backing vector for SIMD support.
            </summary>
        </member>
        <member name="M:ImageProcessor.Bgra32.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Bgra32"/> struct.
            </summary>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
        </member>
        <member name="M:ImageProcessor.Bgra32.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Bgra32"/> struct.
            </summary>
            <param name="b">The blue component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
            <param name="g">The green component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
            <param name="r">The red component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
            <param name="a">The alpha component of this <see cref="T:ImageProcessor.Bgra32"/>.</param>
        </member>
        <member name="P:ImageProcessor.Bgra32.B">
            <summary>
            Gets the blue component of the color
            </summary>
        </member>
        <member name="P:ImageProcessor.Bgra32.G">
            <summary>
            Gets the green component of the color
            </summary>
        </member>
        <member name="P:ImageProcessor.Bgra32.R">
            <summary>
            Gets the red component of the color
            </summary>
        </member>
        <member name="P:ImageProcessor.Bgra32.A">
            <summary>
            Gets the alpha component of the color
            </summary>
        </member>
        <member name="P:ImageProcessor.Bgra32.Bgra">
            <summary>
            Gets the <see cref="T:ImageProcessor.Bgra32"/> integer representation of the color.
            </summary>
        </member>
        <member name="P:ImageProcessor.Bgra32.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Bgra32"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.Bgra32.op_Implicit(ImageProcessor.Color)~ImageProcessor.Bgra32">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Color"/> to a
            <see cref="T:ImageProcessor.Bgra32"/>.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Color"/> to convert.
            </param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Bgra32"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Bgra32.op_Equality(ImageProcessor.Bgra32,ImageProcessor.Bgra32)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Bgra32"/> objects for equality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Bgra32"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Bgra32"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Bgra32.op_Inequality(ImageProcessor.Bgra32,ImageProcessor.Bgra32)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Bgra32"/> objects for inequality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Bgra32"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Bgra32"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Bgra32.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
        </member>
        <member name="M:ImageProcessor.Bgra32.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:ImageProcessor.Bgra32.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="M:ImageProcessor.Bgra32.Equals(ImageProcessor.Bgra32)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            True if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ImageProcessor.Bgra32.GetHashCode(ImageProcessor.Bgra32)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Cmyk"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Cmyk">
            <summary>
            Represents an CMYK (cyan, magenta, yellow, keyline) color.
            </summary>
        </member>
        <member name="F:ImageProcessor.Cmyk.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Cmyk"/> that has C, M, Y, and K values set to zero.
            </summary>
        </member>
        <member name="F:ImageProcessor.Cmyk.Epsilon">
            <summary>
            The epsilon for comparing floating point numbers.
            </summary>
        </member>
        <member name="F:ImageProcessor.Cmyk.backingVector">
            <summary>
            The backing vector for SIMD support.
            </summary>
        </member>
        <member name="M:ImageProcessor.Cmyk.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Cmyk"/> struct.
            </summary>
            <param name="cyan">The cyan component.</param>
            <param name="magenta">The magenta component.</param>
            <param name="yellow">The yellow component.</param>
            <param name="keyline">The keyline black component.</param>
        </member>
        <member name="P:ImageProcessor.Cmyk.C">
            <summary>
            Gets the cyan color component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Cmyk.M">
            <summary>
            Gets the magenta color component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Cmyk.Y">
            <summary>
            Gets the yellow color component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Cmyk.K">
            <summary>
            Gets the keyline black color component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Cmyk.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Cmyk"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.Cmyk.op_Implicit(ImageProcessor.Color)~ImageProcessor.Cmyk">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Color"/> to a
            <see cref="T:ImageProcessor.Cmyk"/>.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Bgra32"/> to convert.
            </param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Cmyk"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Cmyk.op_Equality(ImageProcessor.Cmyk,ImageProcessor.Cmyk)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Cmyk"/> objects for equality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Cmyk"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Cmyk"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Cmyk.op_Inequality(ImageProcessor.Cmyk,ImageProcessor.Cmyk)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Cmyk"/> objects for inequality
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Cmyk"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Cmyk"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Cmyk.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Cmyk.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Cmyk.ToString">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Cmyk.Equals(ImageProcessor.Cmyk)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Cmyk.Clamp(System.Single)">
            <summary>
            Checks the range of the given value to ensure that it remains within the acceptable boundaries.
            </summary>
            <param name="value">
            The value to check.
            </param>
            <returns>
            The sanitized <see cref="T:System.Single"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Cmyk.GetHashCode(ImageProcessor.Cmyk)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Cmyk"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Hsv">
            <summary>
            Represents a HSV (hue, saturation, value) color. Also known as HSB (hue, saturation, brightness).
            </summary>
        </member>
        <member name="F:ImageProcessor.Hsv.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Hsv"/> that has H, S, and V values set to zero.
            </summary>
        </member>
        <member name="F:ImageProcessor.Hsv.Epsilon">
            <summary>
            The epsilon for comparing floating point numbers.
            </summary>
        </member>
        <member name="F:ImageProcessor.Hsv.backingVector">
            <summary>
            The backing vector for SIMD support.
            </summary>
        </member>
        <member name="M:ImageProcessor.Hsv.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Hsv"/> struct.
            </summary>
            <param name="h">The h hue component.</param>
            <param name="s">The s saturation component.</param>
            <param name="v">The v value (brightness) component.</param>
        </member>
        <member name="P:ImageProcessor.Hsv.H">
            <summary>
            Gets the hue component.
            <remarks>A value ranging between 0 and 360.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Hsv.S">
            <summary>
            Gets the saturation component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Hsv.V">
            <summary>
            Gets the value (brightness) component.
            <remarks>A value ranging between 0 and 1.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.Hsv.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Hsv"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.Hsv.op_Implicit(ImageProcessor.Color)~ImageProcessor.Hsv">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Color"/> to a
            <see cref="T:ImageProcessor.Hsv"/>.
            </summary>
            <param name="color">The instance of <see cref="T:ImageProcessor.Color"/> to convert.</param>
            <returns>
            An instance of <see cref="T:ImageProcessor.Hsv"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Hsv.op_Equality(ImageProcessor.Hsv,ImageProcessor.Hsv)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Hsv"/> objects for equality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Hsv"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Hsv"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Hsv.op_Inequality(ImageProcessor.Hsv,ImageProcessor.Hsv)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Hsv"/> objects for inequality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Hsv"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Hsv"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Hsv.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Hsv.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Hsv.ToString">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Hsv.Equals(ImageProcessor.Hsv)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Hsv.GetHashCode(ImageProcessor.Hsv)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Hsv"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.YCbCr">
            <summary>
            Represents an YCbCr (luminance, chroma, chroma) color conforming to the
            Full range standard used in digital imaging systems.
            <see href="http://en.wikipedia.org/wiki/YCbCr"/>
            </summary>
        </member>
        <member name="F:ImageProcessor.YCbCr.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.YCbCr"/> that has Y, Cb, and Cr values set to zero.
            </summary>
        </member>
        <member name="F:ImageProcessor.YCbCr.backingVector">
            <summary>
            The backing vector for SIMD support.
            </summary>
        </member>
        <member name="M:ImageProcessor.YCbCr.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.YCbCr"/> struct.
            </summary>
            <param name="y">The y luminance component.</param>
            <param name="cb">The cb chroma component.</param>
            <param name="cr">The cr chroma component.</param>
        </member>
        <member name="P:ImageProcessor.YCbCr.Y">
            <summary>
            Gets the Y luminance component.
            <remarks>A value ranging between 0 and 255.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.YCbCr.Cb">
            <summary>
            Gets the Cb chroma component.
            <remarks>A value ranging between 0 and 255.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.YCbCr.Cr">
            <summary>
            Gets the Cr chroma component.
            <remarks>A value ranging between 0 and 255.</remarks>
            </summary>
        </member>
        <member name="P:ImageProcessor.YCbCr.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.YCbCr"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.YCbCr.op_Implicit(ImageProcessor.Color)~ImageProcessor.YCbCr">
            <summary>
            Allows the implicit conversion of an instance of <see cref="T:ImageProcessor.Color"/> to a
            <see cref="T:ImageProcessor.YCbCr"/>.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Color"/> to convert.
            </param>
            <returns>
            An instance of <see cref="T:ImageProcessor.YCbCr"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.YCbCr.op_Equality(ImageProcessor.YCbCr,ImageProcessor.YCbCr)">
            <summary>
            Compares two <see cref="T:ImageProcessor.YCbCr"/> objects for equality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.YCbCr"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.YCbCr"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.YCbCr.op_Inequality(ImageProcessor.YCbCr,ImageProcessor.YCbCr)">
            <summary>
            Compares two <see cref="T:ImageProcessor.YCbCr"/> objects for inequality.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.YCbCr"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.YCbCr"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.YCbCr.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.YCbCr.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.YCbCr.ToString">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.YCbCr.Equals(ImageProcessor.YCbCr)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.YCbCr.GetHashCode(ImageProcessor.YCbCr)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="color">
            The instance of <see cref="T:ImageProcessor.Hsv"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.ImageFormatException">
            <summary>
            The exception that is thrown when the library tries to load
            an image, which has an invalid format.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageFormatException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageFormatException"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageFormatException"/> class with the name of the
            parameter that causes this exception.
            </summary>
            <param name="errorMessage">The error message that explains the reason for this exception.</param>
        </member>
        <member name="M:ImageProcessor.ImageFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.ImageFormatException"/> class with a specified
            error message and the exception that is the cause of this exception.
            </summary>
            <param name="errorMessage">The error message that explains the reason for this exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic)
            if no inner exception is specified.</param>
        </member>
        <member name="T:ImageProcessor.ByteExtensions">
            <summary>
            Extension methods for the <see cref="T:System.Byte"/> struct.
            </summary>
        </member>
        <member name="M:ImageProcessor.ByteExtensions.ToArrayByBitsLength(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array to a new array where each value in the original array is represented
            by a the specified number of bits.
            </summary>
            <param name="bytes">The bytes to convert from. Cannot be null.</param>
            <param name="bits">The number of bits per value.</param>
            <returns>The resulting <see cref="T:byte[]"/> array. Is never null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="bits"/> is less than or equals than zero.</exception>
        </member>
        <member name="T:ImageProcessor.ComparableExtensions">
            <summary>
            Extension methods for classes that implement <see cref="T:System.IComparable`1"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.Clamp(System.Byte,System.Byte,System.Byte)">
            <summary>
            Restricts a <see cref="T:System.Byte"/> to be within a specified range.
            </summary>
            <param name="value">The The value to clamp.</param>
            <param name="min">The minimum value. If value is less than min, min will be returned.</param>
            <param name="max">The maximum value. If value is greater than max, max will be returned.</param>
            <returns>
            The <see cref="T:System.Byte"/> representing the clamped value.
            </returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Restricts a <see cref="T:System.Int32"/> to be within a specified range.
            </summary>
            <param name="value">The The value to clamp.</param>
            <param name="min">The minimum value. If value is less than min, min will be returned.</param>
            <param name="max">The maximum value. If value is greater than max, max will be returned.</param>
            <returns>
            The <see cref="T:System.Int32"/> representing the clamped value.
            </returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Restricts a <see cref="T:System.Single"/> to be within a specified range.
            </summary>
            <param name="value">The The value to clamp.</param>
            <param name="min">The minimum value. If value is less than min, min will be returned.</param>
            <param name="max">The maximum value. If value is greater than max, max will be returned.</param>
            <returns>
            The <see cref="T:System.Single"/> representing the clamped value.
            </returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Restricts a <see cref="T:System.Double"/> to be within a specified range.
            </summary>
            <param name="value">The The value to clamp.</param>
            <param name="min">The minimum value. If value is less than min, min will be returned.</param>
            <param name="max">The maximum value. If value is greater than max, max will be returned.</param>
            <returns>
            The <see cref="T:System.Double"/> representing the clamped value.
            </returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.ToByte(System.Int32)">
            <summary>
            Converts an <see cref="T:System.Int32"/> to a <see cref="T:System.Byte"/> first restricting the value between the
            minimum and maximum allowable ranges.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> this method extends.</param>
            <returns>The <see cref="T:System.Byte"/></returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.ToByte(System.Single)">
            <summary>
            Converts an <see cref="T:System.Single"/> to a <see cref="T:System.Byte"/> first restricting the value between the
            minimum and maximum allowable ranges.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> this method extends.</param>
            <returns>The <see cref="T:System.Byte"/></returns>
        </member>
        <member name="M:ImageProcessor.ComparableExtensions.ToByte(System.Double)">
            <summary>
            Converts an <see cref="T:System.Double"/> to a <see cref="T:System.Byte"/> first restricting the value between the
            minimum and maximum allowable ranges.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> this method extends.</param>
            <returns>The <see cref="T:System.Byte"/></returns>
        </member>
        <member name="T:ImageProcessor.EnumerableExtensions">
            <summary>
            Encapsulates a series of time saving extension methods to the <see cref="T:System.Collections.IEnumerable"/> interface.
            </summary>
        </member>
        <member name="M:ImageProcessor.EnumerableExtensions.SteppedRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="fromInclusive">
            The start index, inclusive.
            </param>
            <param name="toExclusive">
            The end index, exclusive.
            </param>
            <param name="step">
            The incremental step.
            </param>
            <returns>
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a range of sequential integral numbers.
            </returns>
        </member>
        <member name="M:ImageProcessor.EnumerableExtensions.SteppedRange(System.Int32,System.Func{System.Int32,System.Boolean},System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="fromInclusive">
            The start index, inclusive.
            </param>
            <param name="toDelegate">
            A method that has one parameter and returns a <see cref="T:System.Boolean"/> calculating the end index
            </param>
            <param name="step">
            The incremental step.
            </param>
            <returns>
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a range of sequential integral numbers.
            </returns>
        </member>
        <member name="M:ImageProcessor.EnumerableExtensions.RangeIterator(System.Int32,System.Func{System.Int32,System.Boolean},System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="fromInclusive">
            The start index, inclusive.
            </param>
            <param name="toDelegate">
            A method that has one parameter and returns a <see cref="T:System.Boolean"/> calculating the end index
            </param>
            <param name="step">
            The incremental step.
            </param>
            <returns>
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a range of sequential integral numbers.
            </returns>
        </member>
        <member name="T:ImageProcessor.Guard">
            <summary>
            Provides methods to protect against invalid parameters.
            </summary>
        </member>
        <member name="M:ImageProcessor.Guard.NotNull(System.Object,System.String,System.String)">
            <summary>
            Verifies, that the method parameter with specified object value is not null
            and throws an exception if it is found to be so.
            </summary>
            <param name="target">
            The target object, which cannot be null.
            </param>
            <param name="parameterName">
            The name of the parameter that is to be checked.
            </param>
            <param name="message">
            The error message, if any to add to the exception.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="target"/> is null
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.NotNullOrEmpty(System.String,System.String)">
            <summary>
            Verifies, that the string method parameter with specified object value and message
            is not null, not empty and does not contain only blanks and throws an exception
            if the object is null.
            </summary>
            <param name="target">The target string, which should be checked against being null or empty.</param>
            <param name="parameterName">Name of the parameter.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="target"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="target"/> is
            empty or contains only blanks.
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.MustBeLessThan``1(``0,``0,System.String)">
            <summary>
            Verifies that the specified value is less than a maximum value
            and throws an exception if it is not.
            </summary>
            <param name="value">The target value, which should be validated.</param>
            <param name="max">The maximum value.</param>
            <param name="parameterName">The name of the parameter that is to be checked.</param>
            <typeparam name="TValue">The type of the value.</typeparam>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is greater than the maximum value.
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.MustBeLessThanOrEqualTo``1(``0,``0,System.String)">
            <summary>
            Verifies that the specified value is less than or equal to a maximum value
            and throws an exception if it is not.
            </summary>
            <param name="value">The target value, which should be validated.</param>
            <param name="max">The maximum value.</param>
            <param name="parameterName">The name of the parameter that is to be checked.</param>
            <typeparam name="TValue">The type of the value.</typeparam>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is greater than the maximum value.
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.MustBeGreaterThan``1(``0,``0,System.String)">
            <summary>
            Verifies that the specified value is greater than a minimum value
            and throws an exception if it is not.
            </summary>
            <param name="value">The target value, which should be validated.</param>
            <param name="min">The minimum value.</param>
            <param name="parameterName">The name of the parameter that is to be checked.</param>
            <typeparam name="TValue">The type of the value.</typeparam>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is less than the minimum value.
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.MustBeGreaterThanOrEqualTo``1(``0,``0,System.String)">
            <summary>
            Verifies that the specified value is greater than or equal to a minimum value
            and throws an exception if it is not.
            </summary>
            <param name="value">The target value, which should be validated.</param>
            <param name="min">The minimum value.</param>
            <param name="parameterName">The name of the parameter that is to be checked.</param>
            <typeparam name="TValue">The type of the value.</typeparam>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is less than the minimum value.
            </exception>
        </member>
        <member name="M:ImageProcessor.Guard.MustBeBetweenOrEqualTo``1(``0,``0,``0,System.String)">
            <summary>
            Verifies that the specified value is greater than or equal to a minimum value and less than
            or equal to a maximum value and throws an exception if it is not.
            </summary>
            <param name="value">The target value, which should be validated.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <param name="parameterName">The name of the parameter that is to be checked.</param>
            <typeparam name="TValue">The type of the value.</typeparam>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is less than the minimum value of greater than the maximum value.
            </exception>
        </member>
        <member name="T:ImageProcessor.ImageMaths">
            <summary>
            Provides common mathematical methods.
            </summary>
        </member>
        <member name="F:ImageProcessor.ImageMaths.PI">
            <summary>
            Represents PI, the ratio of a circle's circumference to its diameter.
            </summary>
        </member>
        <member name="M:ImageProcessor.ImageMaths.Gaussian(System.Single,System.Single)">
            <summary>
            Implementation of 1D Gaussian G(x) function
            </summary>
            <param name="x">The x provided to G(x).</param>
            <param name="sigma">The spread of the blur.</param>
            <returns>The Gaussian G(x)</returns>
        </member>
        <member name="M:ImageProcessor.ImageMaths.GetBcValue(System.Single,System.Single,System.Single)">
            <summary>
            Returns the result of a B-C filter against the given value.
            <see href="http://www.imagemagick.org/Usage/filter/#cubic_bc"/>
            </summary>
            <param name="x">The value to process.</param>
            <param name="b">The B-Spline curve variable.</param>
            <param name="c">The Cardinal curve variable.</param>
            <returns>
            The <see cref="T:System.Single"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageMaths.SinC(System.Single)">
            <summary>
            Gets the result of a sine cardinal function for the given value.
            </summary>
            <param name="x">
            The value to calculate the result for.
            </param>
            <returns>
            The <see cref="T:System.Single"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.ImageMaths.Clean(System.Single)">
            <summary>
            Ensures that any passed double is correctly rounded to zero
            </summary>
            <param name="x">The value to clean.</param>
            <returns>
            The <see cref="T:System.Single"/>
            </returns>.
        </member>
        <member name="T:ImageProcessor.Filters.Alpha">
            <summary>
            An <see cref="T:ImageProcessor.IImageProcessor"/> to change the Alpha of an <see cref="T:ImageProcessor.Image"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Alpha.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.Alpha"/> class.
            </summary>
            <param name="percent">The percentage to adjust the opacity of the image. Must be between 0 and 100.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="percent"/> is less than 0 or is greater than 100.
            </exception>
        </member>
        <member name="P:ImageProcessor.Filters.Alpha.Value">
            <summary>
            Gets the alpha value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Alpha.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Blend">
            <summary>
            Combines two images together by blending the pixels.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.Blend.toBlend">
            <summary>
            The image to blend.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Blend.#ctor(ImageProcessor.ImageBase,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.Blend"/> class.
            </summary>
            <param name="image">The image to blend.</param>
            <param name="alpha">The opacity of the image to blend. Between 0 and 100.</param>
        </member>
        <member name="P:ImageProcessor.Filters.Blend.Value">
            <summary>
            Gets the alpha percentage value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Blend.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Brightness">
            <summary>
            An <see cref="T:ImageProcessor.IImageProcessor"/> to change the brightness of an <see cref="T:ImageProcessor.Image"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Brightness.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.Brightness"/> class.
            </summary>
            <param name="brightness">The new brightness of the image. Must be between -100 and 100.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="brightness"/> is less than -100 or is greater than 100.
            </exception>
        </member>
        <member name="P:ImageProcessor.Filters.Brightness.Value">
            <summary>
            Gets the brightness value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Brightness.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.Brightness.AdjustBrightness(ImageProcessor.Color,System.Single)">
            <summary>
            Returns a <see cref="T:ImageProcessor.Color"/> with the brightness adjusted.
            </summary>
            <param name="color">The source color.</param>
            <param name="brightness">The brightness adjustment factor.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="T:ImageProcessor.Filters.Contrast">
            <summary>
            An <see cref="T:ImageProcessor.IImageProcessor"/> to change the contrast of an <see cref="T:ImageProcessor.Image"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Contrast.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.Contrast"/> class.
            </summary>
            <param name="contrast">The new contrast of the image. Must be between -100 and 100.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="contrast"/> is less than -100 or is greater than 100.
            </exception>
        </member>
        <member name="P:ImageProcessor.Filters.Contrast.Value">
            <summary>
            Gets the contrast value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Contrast.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.Contrast.AdjustContrast(ImageProcessor.Color,System.Single)">
            <summary>
            Returns a <see cref="T:ImageProcessor.Color"/> with the contrast adjusted.
            </summary>
            <param name="color">The source color.</param>
            <param name="contrast">The contrast adjustment factor.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="T:ImageProcessor.Filters.ImageFilterExtensions">
            <summary>
            Extensions methods for <see cref="T:ImageProcessor.Image"/> to apply filters to the image.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Alpha(ImageProcessor.Image,System.Int32)">
            <summary>
            Alters the alpha component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="percent">The new opacity of the image. Must be between 0 and 100.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Alpha(ImageProcessor.Image,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Alters the alpha component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="percent">The new opacity of the image. Must be between 0 and 100.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Blend(ImageProcessor.Image,ImageProcessor.ImageBase,System.Int32)">
            <summary>
            Combines the given image together with the current one by blending their pixels.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="image">The image to blend with the currently processing image.</param>
            <param name="percent">The opacity of the image image to blend. Must be between 0 and 100.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Blend(ImageProcessor.Image,ImageProcessor.ImageBase,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Combines the given image together with the current one by blending their pixels.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="image">The image to blend with the currently processing image.</param>
            <param name="percent">The opacity of the image image to blend. Must be between 0 and 100.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.BlackWhite(ImageProcessor.Image)">
            <summary>
            Applies black and white toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.BlackWhite(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Applies black and white toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Brightness(ImageProcessor.Image,System.Int32)">
            <summary>
            Alters the brightness component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new brightness of the image. Must be between -100 and 100.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Brightness(ImageProcessor.Image,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Alters the brightness component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new brightness of the image. Must be between -100 and 100.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Contrast(ImageProcessor.Image,System.Int32)">
            <summary>
            Alters the contrast component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new contrast of the image. Must be between -100 and 100.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Contrast(ImageProcessor.Image,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Alters the contrast component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new contrast of the image. Must be between -100 and 100.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.DetectEdges(ImageProcessor.Image)">
            <summary>
            Detects any edges within the image. Uses the <see cref="T:ImageProcessor.Filters.Sobel"/> filter
            operating in greyscale mode.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.DetectEdges(ImageProcessor.Image,ImageProcessor.Filters.IEdgeDetectorFilter)">
            <summary>
            Detects any edges within the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="filter">The filter for detecting edges.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.DetectEdges(ImageProcessor.Image,ImageProcessor.Rectangle,ImageProcessor.Filters.IEdgeDetectorFilter)">
            <summary>
            Detects any edges within the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <param name="filter">The filter for detecting edges.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Greyscale(ImageProcessor.Image,ImageProcessor.Filters.GreyscaleMode)">
            <summary>
            Applies greyscale toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="mode">The formula to apply to perform the operation.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Greyscale(ImageProcessor.Image,ImageProcessor.Rectangle,ImageProcessor.Filters.GreyscaleMode)">
            <summary>
            Applies greyscale toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <param name="mode">The formula to apply to perform the operation.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Invert(ImageProcessor.Image)">
            <summary>
            Inverts the colors of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Invert(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Inverts the colors of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Kodachrome(ImageProcessor.Image)">
            <summary>
            Alters the colors of the image recreating an old Kodachrome camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Kodachrome(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Alters the colors of the image recreating an old Kodachrome camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Lomograph(ImageProcessor.Image)">
            <summary>
            Alters the colors of the image recreating an old Lomograph camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Lomograph(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Alters the colors of the image recreating an old Lomograph camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Polaroid(ImageProcessor.Image)">
            <summary>
            Alters the colors of the image recreating an old Polaroid camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Polaroid(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Alters the colors of the image recreating an old Polaroid camera effect.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Saturation(ImageProcessor.Image,System.Int32)">
            <summary>
            Alters the saturation component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new saturation of the image. Must be between -100 and 100.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Saturation(ImageProcessor.Image,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Alters the saturation component of the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="amount">The new saturation of the image. Must be between -100 and 100.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Sepia(ImageProcessor.Image)">
            <summary>
            Applies sepia toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="M:ImageProcessor.Filters.ImageFilterExtensions.Sepia(ImageProcessor.Image,ImageProcessor.Rectangle)">
            <summary>
            Applies sepia toning to the image.
            </summary>
            <param name="source">The image this method extends.</param>
            <param name="rectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to alter.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/>.</returns>
        </member>
        <member name="T:ImageProcessor.Filters.Invert">
            <summary>
            An <see cref="T:ImageProcessor.IImageProcessor"/> to invert the colors of an <see cref="T:ImageProcessor.Image"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Invert.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.BlackWhite">
            <summary>
            Converts the colors of the image to their black and white equivalent.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.BlackWhite.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.ColorMatrixFilter">
            <summary>
            The color matrix filter.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.ColorMatrixFilter.Matrix">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.ColorMatrixFilter.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.ColorMatrixFilter.ApplyMatrix(ImageProcessor.Color,System.Numerics.Matrix4x4)">
            <summary>
            Applies the color matrix against the given color.
            </summary>
            <param name="color">The source color.</param>
            <param name="matrix">The matrix.</param>
            <returns>
            The <see cref="T:ImageProcessor.Color"/>.
            </returns>
        </member>
        <member name="T:ImageProcessor.Filters.GreyscaleBt601">
            <summary>
            Converts the colors of the image to greyscale applying the formula as specified by
            ITU-R Recommendation BT.601 <see href="https://en.wikipedia.org/wiki/Luma_%28video%29#Rec._601_luma_versus_Rec._709_luma_coefficients"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.GreyscaleBt601.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.GreyscaleBt709">
            <summary>
            Converts the colors of the image to greyscale applying the formula as specified by
            ITU-R Recommendation BT.709 <see href="https://en.wikipedia.org/wiki/Rec._709#Luma_coefficients"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.GreyscaleBt709.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.GreyscaleMode">
            <summary>
            Provides enumeration over the various greyscale methods available.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GreyscaleMode.Bt709">
            <summary>
            ITU-R Recommendation BT.709
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GreyscaleMode.Bt601">
            <summary>
            ITU-R Recommendation BT.601
            </summary>
        </member>
        <member name="T:ImageProcessor.Filters.IColorMatrixFilter">
            <summary>
            Encapsulates properties and methods for creating processors that utilize a matrix to
            alter the image pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.IColorMatrixFilter.Matrix">
            <summary>
            Gets the <see cref="T:System.Numerics.Matrix4x4"/> used to alter the image.
            </summary>
        </member>
        <member name="T:ImageProcessor.Filters.Kodachrome">
            <summary>
            Converts the colors of the image recreating an old Kodachrome camera effect.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Kodachrome.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Lomograph">
            <summary>
            Converts the colors of the image recreating an old Lomograph effect.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Lomograph.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Polaroid">
            <summary>
            Converts the colors of the image recreating an old Polaroid effect.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Polaroid.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Saturation">
            <summary>
            An <see cref="T:ImageProcessor.IImageProcessor"/> to change the saturation of an <see cref="T:ImageProcessor.Image"/>.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.Saturation.saturation">
            <summary>
            The saturation to be applied to the image.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.Saturation.matrix">
            <summary>
            The <see cref="T:System.Numerics.Matrix4x4"/> used to alter the image.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Saturation.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.Saturation"/> class.
            </summary>
            <param name="saturation">The new saturation of the image. Must be between -100 and 100.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="saturation"/> is less than -100 or is greater than 100.
            </exception>
        </member>
        <member name="P:ImageProcessor.Filters.Saturation.Matrix">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.Saturation.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Sepia">
            <summary>
            Converts the colors of the image to their sepia equivalent recreating an old photo effect.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Sepia.Matrix">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Convolution2DFilter">
            <summary>
            Defines a filter that uses two one-dimensional matrices to perform convolution against an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Convolution2DFilter.KernelX">
            <summary>
            Gets the horizontal gradient operator.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Convolution2DFilter.KernelY">
            <summary>
            Gets the vertical gradient operator.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Convolution2DFilter.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Convolution2PassFilter">
            <summary>
            Defines a filter that uses two one-dimensional matrices to perform two-pass convolution against an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Convolution2PassFilter.KernelX">
            <summary>
            Gets the horizontal gradient operator.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Convolution2PassFilter.KernelY">
            <summary>
            Gets the vertical gradient operator.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.Convolution2PassFilter.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.Convolution2PassFilter.ApplyConvolution(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,System.Int32,System.Int32,System.Single[0:,0:])">
            <summary>
            Applies the process to the specified portion of the specified <see cref="T:ImageProcessor.ImageBase"/> at the specified location
            and with the specified size.
            </summary>
            <param name="target">Target image to apply the process to.</param>
            <param name="source">The source image. Cannot be null.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <param name="startY">The index of the row within the source image to start processing.</param>
            <param name="endY">The index of the row within the source image to end processing.</param>
            <param name="kernel">The kernel operator.</param>
        </member>
        <member name="T:ImageProcessor.Filters.ConvolutionFilter">
            <summary>
            Defines a filter that uses a 2 dimensional matrix to perform convolution against an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.ConvolutionFilter.KernelXY">
            <summary>
            Gets the 2d gradient operator.
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.ConvolutionFilter.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.GuassianBlur">
            <summary>
            Applies a Gaussian blur filter to the image.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianBlur.kernelSize">
            <summary>
            The maximum size of the kernal in either direction.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianBlur.sigma">
            <summary>
            The spread of the blur.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianBlur.kernelY">
            <summary>
            The vertical kernel
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianBlur.kernelX">
            <summary>
            The horizontal kernel
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianBlur.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianBlur"/> class.
            </summary>
            <param name="sigma">
            The 'sigma' value representing the weight of the blur.
            </param>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianBlur.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianBlur"/> class.
            </summary>
            <param name="radius">
            The 'radius' value representing the size of the area to sample.
            </param>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianBlur.#ctor(System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianBlur"/> class.
            </summary>
            <param name="sigma">
            The 'sigma' value representing the weight of the blur.
            </param>
            <param name="radius">
            The 'radius' value representing the size of the area to sample.
            This should be at least twice the sigma value.
            </param>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianBlur.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianBlur.KernelY">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianBlur.Parallelism">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianBlur.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianBlur.CreateGaussianKernel(System.Boolean)">
            <summary>
            Create a 1 dimensional Gaussian kernel using the Gaussian G(x) function
            </summary>
            <param name="horizontal">Whether to calculate a horizontal kernel.</param>
            <returns>The <see cref="T:float[,]"/></returns>
        </member>
        <member name="T:ImageProcessor.Filters.GuassianSharpen">
            <summary>
            Applies a Gaussian sharpening filter to the image.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianSharpen.kernelSize">
            <summary>
            The maximum size of the kernal in either direction.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianSharpen.sigma">
            <summary>
            The spread of the blur.
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianSharpen.kernelY">
            <summary>
            The vertical kernel
            </summary>
        </member>
        <member name="F:ImageProcessor.Filters.GuassianSharpen.kernelX">
            <summary>
            The horizontal kernel
            </summary>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianSharpen.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianSharpen"/> class.
            </summary>
            <param name="sigma">
            The 'sigma' value representing the weight of the sharpening.
            </param>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianSharpen.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianSharpen"/> class.
            </summary>
            <param name="radius">
            The 'radius' value representing the size of the area to sample.
            </param>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianSharpen.#ctor(System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Filters.GuassianSharpen"/> class.
            </summary>
            <param name="sigma">
            The 'sigma' value representing the weight of the sharpen.
            </param>
            <param name="radius">
            The 'radius' value representing the size of the area to sample.
            This should be at least twice the sigma value.
            </param>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianSharpen.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianSharpen.KernelY">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.GuassianSharpen.Parallelism">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianSharpen.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.GuassianSharpen.CreateGaussianKernel(System.Boolean)">
            <summary>
            Create a 1 dimensional Gaussian kernel using the Gaussian G(x) function
            </summary>
            <param name="horizontal">Whether to calculate a horizontal kernel.</param>
            <returns>The <see cref="T:float[,]"/></returns>
        </member>
        <member name="T:ImageProcessor.Filters.EdgeDetector2DFilter">
            <summary>
            Defines a filter that detects edges within an image using two
            one-dimensional matrices.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.EdgeDetector2DFilter.Greyscale">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.EdgeDetector2DFilter.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.EdgeDetectorFilter">
            <summary>
            Defines a filter that detects edges within an image using a single
            two dimensional matrix.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.EdgeDetectorFilter.Greyscale">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Filters.EdgeDetectorFilter.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.IEdgeDetectorFilter">
            <summary>
            Provides properties and methods allowing the detection of edges within an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.IEdgeDetectorFilter.Greyscale">
            <summary>
            Gets or sets a value indicating whether to convert the
            image to greyscale before performing edge detection.
            </summary>
        </member>
        <member name="T:ImageProcessor.Filters.Kayyali">
            <summary>
            The Kayyali operator filter.
            <see href="http://edgedetection.webs.com/"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Kayyali.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.Kayyali.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Kirsch">
            <summary>
            The Kirsch operator filter.
            <see href="http://en.wikipedia.org/wiki/Kirsch_operator"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Kirsch.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.Kirsch.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Laplacian3X3">
            <summary>
            The Laplacian 3 x 3 operator filter.
            <see href="http://en.wikipedia.org/wiki/Discrete_Laplace_operator"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Laplacian3X3.KernelXY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Laplacian5X5">
            <summary>
            The Laplacian 5 x 5 operator filter.
            <see href="http://en.wikipedia.org/wiki/Discrete_Laplace_operator"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Laplacian5X5.KernelXY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.LaplacianOfGaussian">
            <summary>
            The Laplacian of Gaussian operator filter.
            <see href="http://fourier.eng.hmc.edu/e161/lectures/gradient/node8.html"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.LaplacianOfGaussian.KernelXY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Prewitt">
            <summary>
            The Prewitt operator filter.
            <see href="http://en.wikipedia.org/wiki/Prewitt_operator"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Prewitt.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.Prewitt.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.RobertsCross">
            <summary>
            The Roberts Cross operator filter.
            <see href="http://en.wikipedia.org/wiki/Roberts_cross"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.RobertsCross.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.RobertsCross.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Scharr">
            <summary>
            The Scharr operator filter.
            <see href="http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Scharr.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.Scharr.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Filters.Sobel">
            <summary>
            The Sobel operator filter.
            <see href="http://en.wikipedia.org/wiki/Sobel_operator"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Filters.Sobel.KernelX">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Filters.Sobel.KernelY">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.IImageDecoder">
            <summary>
            Encapsulates properties and methods required for decoding an image from a stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageDecoder.HeaderSize">
            <summary>
            Gets the size of the header for this image type.
            </summary>
            <value>The size of the header.</value>
        </member>
        <member name="M:ImageProcessor.Formats.IImageDecoder.IsSupportedFileExtension(System.String)">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="extension">The <see cref="T:System.String"/> containing the file extension.</param>
            <returns>
            True if the decoder supports the file extension; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.IImageDecoder.IsSupportedFileFormat(System.Byte[])">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="header">The <see cref="T:byte[]"/> containing the file header.</param>
            <returns>
            True if the decoder supports the file header; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.IImageDecoder.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified stream to the <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to decode to.</param>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="T:ImageProcessor.Formats.IImageEncoder">
            <summary>
            Encapsulates properties and methods required for encoding an image to a stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageEncoder.Quality">
            <summary>
            Gets or sets the quality of output for images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageEncoder.MimeType">
            <summary>
            Gets the standard identifier used on the Internet to indicate the type of data that a file contains.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageEncoder.Extension">
            <summary>
            Gets the default file extension for this encoder.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.IImageEncoder.IsSupportedFileExtension(System.String)">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageEncoder"/> supports the specified
            file header.
            </summary>
            <param name="extension">The <see cref="T:System.String"/> containing the file extension.</param>
            <returns>
            <c>True</c> if the decoder supports the file extension; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.IImageEncoder.Encode(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Encodes the image to the specified stream from the <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to encode from.</param>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to encode the image data to.</param>
        </member>
        <member name="T:ImageProcessor.Formats.IImageFormat">
            <summary>
            Encapsulates a supported image format, providing means to encode and decode an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageFormat.Encoder">
            <summary>
            Gets the image encoder for encoding an image from a stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IImageFormat.Decoder">
            <summary>
            Gets the image decoder for decoding an image from a stream.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.BmpCompression">
            <summary>
            Defines how the compression type of the image data
            in the bitmap file.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.RGB">
            <summary>
            Each image row has a multiple of four elements. If the
            row has less elements, zeros will be added at the right side.
            The format depends on the number of bits, stored in the info header.
            If the number of bits are one, four or eight each pixel data is
            a index to the palette. If the number of bits are sixteen,
            twenty-four or thirty-two each pixel contains a color.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.RLE8">
            <summary>
            Two bytes are one data record. If the first byte is not zero, the
            next two half bytes will be repeated as much as the value of the first byte.
            If the first byte is zero, the record has different meanings, depending
            on the second byte. If the second byte is zero, it is the end of the row,
            if it is one, it is the end of the image.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.RLE4">
            <summary>
            Two bytes are one data record. If the first byte is not zero, the
            next byte will be repeated as much as the value of the first byte.
            If the first byte is zero, the record has different meanings, depending
            on the second byte. If the second byte is zero, it is the end of the row,
            if it is one, it is the end of the image.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.BitFields">
            <summary>
            Each image row has a multiple of four elements. If the
            row has less elements, zeros will be added at the right side.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.JPEG">
            <summary>
            The bitmap contains a JPG image.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpCompression.PNG">
            <summary>
            The bitmap contains a PNG image.
            Not supported at the moment.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.BmpDecoder">
            <summary>
            Image decoder for generating an image out of a Windows bitmap stream.
            </summary>
            <remarks>
            Does not support the following formats at the moment:
            <list type="bullet">
               <item>JPG</item>
               <item>PNG</item>
               <item>RLE4</item>
               <item>RLE8</item>
               <item>BitFields</item>
            </list>
            Formats will be supported in a later releases. We advise always
            to use only 24 Bit Windows bitmaps.
            </remarks>
        </member>
        <member name="P:ImageProcessor.Formats.BmpDecoder.HeaderSize">
            <summary>
            Gets the size of the header for this image type.
            </summary>
            <value>The size of the header.</value>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoder.IsSupportedFileExtension(System.String)">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="extension">The <see cref="T:System.String"/> containing the file extension.</param>
            <returns>
            True if the decoder supports the file extension; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoder.IsSupportedFileFormat(System.Byte[])">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="header">The <see cref="T:byte[]"/> containing the file header.</param>
            <returns>
            True if the decoder supports the file header; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoder.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified stream to the <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to decode to.</param>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="T:ImageProcessor.Formats.BmpDecoderCore">
            <summary>
            Performs the bmp decoding operation.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.Rgb16RMask">
            <summary>
            The mask for the red part of the color for 16 bit rgb bitmaps.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.Rgb16GMask">
            <summary>
            The mask for the green part of the color for 16 bit rgb bitmaps.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.Rgb16BMask">
            <summary>
            The mask for the blue part of the color for 16 bit rgb bitmaps.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.currentStream">
            <summary>
            The stream to decode from.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.fileHeader">
            <summary>
            The file header containing general information.
            TODO: Why is this not used? We advance the stream but do not use the values parsed.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpDecoderCore.infoHeader">
            <summary>
            The info header containing detailed information about the bitmap.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified this._stream and sets
            the data to image.
            </summary>
            <param name="image">The image, where the data should be set to.
            Cannot be null (Nothing in Visual Basic).</param>
            <param name="stream">The this._stream, where the image should be
            decoded from. Cannot be null (Nothing in Visual Basic).</param>
            <exception cref="T:System.ArgumentNullException">
               <para><paramref name="image"/> is null.</para>
               <para>- or -</para>
               <para><paramref name="stream"/> is null.</para>
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.Invert(System.Int32,System.Int32)">
            <summary>
            Returns the y- value based on the given height.
            </summary>
            <param name="y">The y- value representing the current row.</param>
            <param name="height">The height of the bitmap.</param>
            <returns>The <see cref="T:System.Int32"/> representing the inverted value.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadRgbPalette(System.Single[],System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the color palette from the stream.
            </summary>
            <param name="imageData">The <see cref="T:float[]"/> image data to assign the palette to.</param>
            <param name="colors">The <see cref="T:byte[]"/> containing the colors.</param>
            <param name="width">The width of the bitmap.</param>
            <param name="height">The height of the bitmap.</param>
            <param name="bits">The number of bits per pixel.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadRgb16(System.Single[],System.Int32,System.Int32)">
            <summary>
            Reads the 16 bit color palette from the stream
            </summary>
            <param name="imageData">The <see cref="T:float[]"/> image data to assign the palette to.</param>
            <param name="width">The width of the bitmap.</param>
            <param name="height">The height of the bitmap.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadRgb24(System.Single[],System.Int32,System.Int32)">
            <summary>
            Reads the 24 bit color palette from the stream
            </summary>
            <param name="imageData">The <see cref="T:float[]"/> image data to assign the palette to.</param>
            <param name="width">The width of the bitmap.</param>
            <param name="height">The height of the bitmap.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadRgb32(System.Single[],System.Int32,System.Int32)">
            <summary>
            Reads the 32 bit color palette from the stream
            </summary>
            <param name="imageData">The <see cref="T:float[]"/> image data to assign the palette to.</param>
            <param name="width">The width of the bitmap.</param>
            <param name="height">The height of the bitmap.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.GetImageArray(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Returns a <see cref="T:byte[]"/> containing the pixels for the current bitmap.
            </summary>
            <param name="width">The width of the bitmap.</param>
            <param name="height">The height.</param>
            <param name="bytes">The number of bytes per pixel.</param>
            <param name="alignment">The alignment of the pixels.</param>
            <returns>
            The <see cref="T:byte[]"/> containing the pixels.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadInfoHeader">
            <summary>
            Reads the <see cref="T:ImageProcessor.Formats.BmpInfoHeader"/> from the stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BmpDecoderCore.ReadFileHeader">
            <summary>
            Reads the <see cref="T:ImageProcessor.Formats.BmpFileHeader"/> from the stream.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.BmpEncoder">
            <summary>
            Image encoder for writing an image to a stream as a Windows bitmap.
            </summary>
            <remarks>The encoder can currently only write 24-bit rgb images to streams.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.BmpEncoder.Quality">
            <summary>
            Gets or sets the quality of output for images.
            </summary>
            <remarks>Bitmap is a lossless format so this is not used in this encoder.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.BmpEncoder.MimeType">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.BmpEncoder.Extension">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.BmpEncoder.IsSupportedFileExtension(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.BmpEncoder.Encode(ImageProcessor.ImageBase,System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.BmpEncoder.WriteImage(System.IO.BinaryWriter,ImageProcessor.ImageBase)">
            <summary>
            Writes the pixel data to the binary stream.
            </summary>
            <param name="writer">
            The <see cref="T:System.IO.BinaryWriter"/> containing the stream to write to.
            </param>
            <param name="image">
            The <see cref="T:ImageProcessor.ImageBase"/> containing pixel data.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpEncoder.WriteHeader(System.IO.BinaryWriter,ImageProcessor.Formats.BmpFileHeader)">
            <summary>
            Writes the bitmap header data to the binary stream.
            </summary>
            <param name="writer">
            The <see cref="T:System.IO.BinaryWriter"/> containing the stream to write to.
            </param>
            <param name="fileHeader">
            The <see cref="T:ImageProcessor.Formats.BmpFileHeader"/> containing the header data.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.BmpEncoder.WriteInfo(System.IO.BinaryWriter,ImageProcessor.Formats.BmpInfoHeader)">
            <summary>
            Writes the bitmap information to the binary stream.
            </summary>
            <param name="writer">
            The <see cref="T:System.IO.BinaryWriter"/> containing the stream to write to.
            </param>
            <param name="infoHeader">
            The <see cref="T:ImageProcessor.Formats.BmpFileHeader"/> containing the detailed information about the image.
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.BmpFileHeader">
            <summary>
            Stores general information about the Bitmap file.
            <see href="https://en.wikipedia.org/wiki/BMP_file_format" />
            </summary>
            <remarks>
            The first two bytes of the Bitmap file format
            (thus the Bitmap header) are stored in big-endian order.
            All of the other integer values are stored in little-endian format
            (i.e. least-significant byte first).
            </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.BmpFileHeader.Size">
            <summary>
            Defines of the data structure in the bitmap file.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFileHeader.Type">
            <summary>
            Gets or sets the Bitmap identifier.
            The field used to identify the bitmap file: 0x42 0x4D
            (Hex code points for B and M)
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFileHeader.FileSize">
            <summary>
            Gets or sets the size of the bitmap file in bytes.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFileHeader.Reserved">
            <summary>
            Gets or sets any reserved data; actual value depends on the application
            that creates the image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFileHeader.Offset">
            <summary>
            Gets or sets the offset, i.e. starting address, of the byte where
            the bitmap data can be found.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.BmpFormat">
            <summary>
            Encapsulates the means to encode and decode bitmap images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFormat.Decoder">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.BmpFormat.Encoder">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.BmpInfoHeader">
            <summary>
            This block of bytes tells the application detailed information
            about the image, which will be used to display the image on
            the screen.
            <see href="https://en.wikipedia.org/wiki/BMP_file_format"/>
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BmpInfoHeader.Size">
            <summary>
            Defines of the data structure in the bitmap file.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.HeaderSize">
            <summary>
            Gets or sets the size of this header (40 bytes)
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.Width">
            <summary>
            Gets or sets the bitmap width in pixels (signed integer).
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.Height">
            <summary>
            Gets or sets the bitmap height in pixels (signed integer).
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.Planes">
            <summary>
            Gets or sets the number of color planes being used. Must be set to 1.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.BitsPerPixel">
            <summary>
            Gets or sets the number of bits per pixel, which is the color depth of the image.
            Typical values are 1, 4, 8, 16, 24 and 32.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.Compression">
            <summary>
            Gets or sets the compression method being used.
            See the next table for a list of possible values.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.ImageSize">
            <summary>
            Gets or sets the image size. This is the size of the raw bitmap data (see below),
            and should not be confused with the file size.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.XPelsPerMeter">
            <summary>
            Gets or sets the horizontal resolution of the image.
            (pixel per meter, signed integer)
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.YPelsPerMeter">
            <summary>
            Gets or sets the vertical resolution of the image.
            (pixel per meter, signed integer)
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.ClrUsed">
            <summary>
            Gets or sets the number of colors in the color palette,
            or 0 to default to 2^n.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BmpInfoHeader.ClrImportant">
            <summary>
            Gets or sets the number of important colors used,
            or 0 when every color is important{ get; set; } generally ignored.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.BitEncoder">
            <summary>
            Handles the encoding of bits for compression.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitEncoder.list">
            <summary>
            The inner list for collecting the bits.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitEncoder.currentBit">
            <summary>
            The current working bit.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitEncoder.currentValue">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.BitEncoder"/> class.
            </summary>
            <param name="initial">
            The initial bits.
            </param>
        </member>
        <member name="P:ImageProcessor.Formats.BitEncoder.IntitialBit">
            <summary>
            Gets or sets the intitial bit.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BitEncoder.Length">
            <summary>
            The number of bytes in the encoder.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.Add(System.Int32)">
            <summary>
            Adds the current byte to the end of the encoder.
            </summary>
            <param name="item">
            The byte to add.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.AddRange(System.Byte[])">
            <summary>
            Adds the collection of bytes to the end of the encoder.
            </summary>
            <param name="collection">
            The collection of bytes to add.
            The collection itself cannot be null but can contain elements that are null.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the encoder to a compatible one-dimensional array,
            starting at the specified index of the target array.
            </summary>
            <param name="index">
            The zero-based index in the source <see cref="T:ImageProcessor.Formats.BitEncoder"/> at which copying begins.
            </param>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied
            from <see cref="T:ImageProcessor.Formats.BitEncoder"/>. The Array must have zero-based indexing
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of bytes to copy.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.Clear">
            <summary>
            Removes all the bytes from the encoder.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.ToArray">
            <summary>
            Copies the bytes into a new array.
            </summary>
            <returns><see cref="T:byte[]"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitEncoder.End">
            <summary>
            The end.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.DisposalMethod">
            <summary>
            Provides enumeration for instructing the decoder what to do with the last image
            in an animation sequence.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DisposalMethod.Unspecified">
            <summary>
            No disposal specified. The decoder is not required to take any action.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DisposalMethod.NotDispose">
            <summary>
            Do not dispose. The graphic is to be left in place.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DisposalMethod.RestoreToBackground">
            <summary>
            Restore to background color. The area used by the graphic must be restored to
            the background color.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DisposalMethod.RestoreToPrevious">
            <summary>
            Restore to previous. The decoder is required to restore the area overwritten by the
            graphic with what was there prior to rendering the graphic.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.GifConstants">
            <summary>
            Constants that define specific points within a gif.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.FileType">
            <summary>
            The file type.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.FileVersion">
            <summary>
            The file version.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ExtensionIntroducer">
            <summary>
            The extension block introducer <value>!</value>.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.GraphicControlLabel">
            <summary>
            The graphic control label.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ApplicationExtensionLabel">
            <summary>
            The application extension label.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ApplicationIdentification">
            <summary>
            The application identification.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ApplicationBlockSize">
            <summary>
            The application block size.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.CommentLabel">
            <summary>
            The comment label.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.MaxCommentLength">
            <summary>
            The maximum comment length.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ImageDescriptorLabel">
            <summary>
            The image descriptor label <value>,</value>.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.PlainTextLabel">
            <summary>
            The plain text label.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.ImageLabel">
            <summary>
            The image label introducer <value>,</value>.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.Terminator">
            <summary>
            The terminator.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifConstants.EndIntroducer">
            <summary>
            The end introducer trailer <value>;</value>.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.GifDecoder">
            <summary>
            Decoder for generating an image out of a gif encoded stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifDecoder.HeaderSize">
            <summary>
            Gets the size of the header for this image type.
            </summary>
            <value>The size of the header.</value>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoder.IsSupportedFileExtension(System.String)">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="extension">The <see cref="T:System.String"/> containing the file extension.</param>
            <returns>
            True if the decoder supports the file extension; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoder.IsSupportedFileFormat(System.Byte[])">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="header">The <see cref="T:byte[]"/> containing the file header.</param>
            <returns>
            True if the decoder supports the file header; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoder.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified stream to the <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to decode to.</param>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="T:ImageProcessor.Formats.GifDecoderCore">
            <summary>
            Performs the gif decoding operation.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.decodedImage">
            <summary>
            The image to decode the information to.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.currentStream">
            <summary>
            The currently loaded stream.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.globalColorTable">
            <summary>
            The global color table.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.currentFrame">
            <summary>
            The current frame.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.logicalScreenDescriptor">
            <summary>
            The logical screen descriptor.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GifDecoderCore.graphicsControlExtension">
            <summary>
            The graphics control extension.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the stream to the image.
            </summary>
            <param name="image">The image to decode to.</param>
            <param name="stream">The stream containing image data. </param>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadGraphicalControlExtension">
            <summary>
            Reads the graphic control extension.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadImageDescriptor">
            <summary>
            Reads the image descriptor
            </summary>
            <returns><see cref="T:ImageProcessor.Formats.GifImageDescriptor"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadLogicalScreenDescriptor">
            <summary>
            Reads the logical screen descriptor.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.Skip(System.Int32)">
            <summary>
            Skips the designated number of bytes in the stream.
            </summary>
            <param name="length">The number of bytes to skip.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadComments">
            <summary>
            Reads the gif comments.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadFrame">
            <summary>
            Reads an individual gif frame.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadFrameIndices(ImageProcessor.Formats.GifImageDescriptor)">
            <summary>
            Reads the frame indices marking the color to use for each pixel.
            </summary>
            <param name="imageDescriptor">The <see cref="T:ImageProcessor.Formats.GifImageDescriptor"/>.</param>
            <returns>The <see cref="T:byte[]"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadFrameLocalColorTable(ImageProcessor.Formats.GifImageDescriptor)">
            <summary>
            Reads the local color table from the current frame.
            </summary>
            <param name="imageDescriptor">The <see cref="T:ImageProcessor.Formats.GifImageDescriptor"/>.</param>
            <returns>The <see cref="T:byte[]"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifDecoderCore.ReadFrameColors(System.Byte[],System.Byte[],ImageProcessor.Formats.GifImageDescriptor)">
            <summary>
            Reads the frames colors, mapping indices to colors.
            </summary>
            <param name="indices">The indexed pixels.</param>
            <param name="colorTable">The color table containing the available colors.</param>
            <param name="descriptor">The <see cref="T:ImageProcessor.Formats.GifImageDescriptor"/></param>
        </member>
        <member name="T:ImageProcessor.Formats.GifEncoder">
            <summary>
            Image encoder for writing image data to a stream in gif format.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifEncoder.Quality">
            <summary>
            Gets or sets the quality of output for images.
            </summary>
            <remarks>For gifs the value ranges from 1 to 256.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.GifEncoder.Extension">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.GifEncoder.MimeType">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.IsSupportedFileExtension(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.Encode(ImageProcessor.ImageBase,System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteGlobalLogicalScreenDescriptor(ImageProcessor.Image,System.IO.Stream,System.Int32)">
            <summary>
            Writes the logical screen descriptor to the stream.
            </summary>
            <param name="image">The image to encode.</param>
            <param name="stream">The stream to write to.</param>
            <param name="bitDepth">The bit depth.</param>
            <returns>The <see cref="T:ImageProcessor.Formats.GifLogicalScreenDescriptor"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteColorTable(ImageProcessor.ImageBase,System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Writes the color table to the stream.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to encode.</param>
            <param name="stream">The stream to write to.</param>
            <param name="quality">The quality (number of colors) to encode the image to.</param>
            <param name="bitDepth">The bit depth.</param>
            <returns>The <see cref="T:ImageProcessor.Formats.QuantizedImage"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteGraphicalControlExtension(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Writes the graphics control extension to the stream.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to encode.</param>
            <param name="stream">The stream to write to.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteApplicationExtension(System.IO.Stream,System.UInt16,System.Int32)">
            <summary>
            Writes the application exstension to the stream.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="repeatCount">The animated image repeat count.</param>
            <param name="frames">Th number of image frames.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteImageDescriptor(ImageProcessor.Formats.QuantizedImage,System.Int32,System.IO.Stream)">
            <summary>
            Writes the image descriptor to the stream.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.Formats.QuantizedImage"/> containing indexed pixels.</param>
            <param name="quality">The quality (number of colors) to encode the image to.</param>
            <param name="stream">The stream to write to.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteFrameImageDescriptor(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Writes the image descriptor to the stream.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to be encoded.</param>
            <param name="stream">The stream to write to.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteImageData(ImageProcessor.Formats.QuantizedImage,System.IO.Stream,System.Int32)">
            <summary>
            Writes the image pixel data to the stream.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.Formats.QuantizedImage"/> containing indexed pixels.</param>
            <param name="stream">The stream to write to.</param>
            <param name="bitDepth">The bit depth of the image.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteShort(System.IO.Stream,System.Int32)">
            <summary>
            Writes a short to the given stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteByte(System.IO.Stream,System.Int32)">
            <summary>
            Writes a byte to the given stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.WriteString(System.IO.Stream,System.String)">
            <summary>
            Writes a string to the given stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.GifEncoder.GetBitsNeededForColorDepth(System.Int32)">
            <summary>
            Returns how many bits are required to store the specified number of colors.
            Performs a Log2() on the value.
            </summary>
            <param name="colors">The number of colors.</param>
            <returns>
            The <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.GifFormat">
            <summary>
            Encapsulates the means to encode and decode gif images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifFormat.Decoder">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.GifFormat.Encoder">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.LzwDecoder">
            <summary>
            Decompresses data using the LZW algorithms.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwDecoder.MaxStackSize">
            <summary>
            One more than the maximum value 12 bit integer.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwDecoder.NullCode">
            <summary>
            The null code.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwDecoder.stream">
            <summary>
            The stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.LzwDecoder.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.LzwDecoder"/> class
            and sets the stream, where the compressed data should be read from.
            </summary>
            <param name="stream">The stream to read from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
        </member>
        <member name="M:ImageProcessor.Formats.LzwDecoder.DecodePixels(System.Int32,System.Int32,System.Int32)">
            <summary>
            Decodes and decompresses all pixel indices from the stream.
            <remarks>
            </remarks>
            </summary>
            <param name="width">The width of the pixel index array.</param>
            <param name="height">The height of the pixel index array.</param>
            <param name="dataSize">Size of the data.</param>
            <returns>The decoded and uncompressed array.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.LzwDecoder.ReadBlock">
            <summary>
            Reads the next data block from the stream. A data block begins with a byte,
            which defines the size of the block, followed by the block itself.
            </summary>
            <returns>
            The <see cref="T:byte[]"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.LzwDecoder.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes from the data stream.
            </summary>
            <param name="length">
            The number of bytes to read.
            </param>
            <returns>
            The <see cref="T:byte[]"/>.
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.LzwEncoder">
            <summary>
            Encodes an image pixels used on a method based on LZW compression.
            <see href="http://matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp"/>
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwEncoder.MaxStackSize">
            <summary>
            One more than the maximum value 12 bit integer.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwEncoder.initDataSize">
            <summary>
            The initial bit depth.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwEncoder.indexedPixels">
            <summary>
            The indexed pixels to encode.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.LzwEncoder.colorDepth">
            <summary>
            The color depth in bits.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.LzwEncoder.#ctor(System.Byte[],System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.LzwEncoder"/> class.
            </summary>
            <param name="indexedPixels">The array of indexed pixels.</param>
            <param name="colorDepth">The color depth in bits.</param>
        </member>
        <member name="M:ImageProcessor.Formats.LzwEncoder.Encode(System.IO.Stream)">
            <summary>
            Encodes the compressed indexed pixel data to the given stream.
            </summary>
            <param name="stream">The stream to add the data to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
        </member>
        <member name="T:ImageProcessor.Formats.IQuantizer">
            <summary>
            Provides methods for allowing quantization of images pixels.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.IQuantizer.Quantize(ImageProcessor.ImageBase)">
            <summary>
            Quantize an image and return the resulting output pixels.
            </summary>
            <param name="imageBase">The image to quantize.</param>
            <returns>
            A <see cref="T:QuantizedImage"/> representing a quantized version of the image pixels.
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.OctreeQuantizer">
            <summary>
            Encapsulates methods to calculate the colour palette if an image using an Octree pattern.
            <see href="http://msdn.microsoft.com/en-us/library/aa479306.aspx"/>
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.octree">
            <summary>
            Stores the tree
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.maxColors">
            <summary>
            Maximum allowed color depth
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.OctreeQuantizer"/> class.
            </summary>
            <remarks>
            The Octree quantizer is a two pass algorithm. The initial pass sets up the Octree,
            the second pass quantizes a color based on the nodes in the tree.
            <para>
            Defaults to return a maximum of 255 colors plus transparency with 8 significant bits.
            </para>
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.OctreeQuantizer"/> class.
            </summary>
            <remarks>
            The Octree quantizer is a two pass algorithm. The initial pass sets up the Octree,
            the second pass quantizes a color based on the nodes in the tree
            </remarks>
            <param name="maxColors">The maximum number of colors to return</param>
            <param name="maxColorBits">The number of significant bits</param>
        </member>
        <member name="P:ImageProcessor.Formats.OctreeQuantizer.Threshold">
            <summary>
            Gets or sets the transparency threshold.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.InitialQuantizePixel(ImageProcessor.Bgra32)">
            <summary>
            Process the pixel in the first pass of the algorithm
            </summary>
            <param name="pixel">
            The pixel to quantize
            </param>
            <remarks>
            This function need only be overridden if your quantize algorithm needs two passes,
            such as an Octree quantizer.
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.QuantizePixel(ImageProcessor.Bgra32)">
            <summary>
            Override this to process the pixel in the second pass of the algorithm
            </summary>
            <param name="pixel">
            The pixel to quantize
            </param>
            <returns>
            The quantized value
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.GetPalette">
            <summary>
            Retrieve the palette for the quantized image.
            </summary>
            <returns>
            The new color palette
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.OctreeQuantizer.Octree">
            <summary>
            Class which does the actual quantization
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.Mask">
            <summary>
            Mask used when getting the appropriate pixels for a given node
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.root">
            <summary>
            The root of the Octree
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.reducibleNodes">
            <summary>
            Array of reducible nodes
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.maxColorBits">
            <summary>
            Maximum number of significant bits in the image
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.leafCount">
            <summary>
            Number of leaves in the tree
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.previousNode">
            <summary>
            Store the last node quantized
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.previousColor">
            <summary>
            Cache the previous color quantized
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.OctreeQuantizer.Octree"/> class.
            </summary>
            <param name="maxColorBits">
            The maximum number of significant bits in the image
            </param>
        </member>
        <member name="P:ImageProcessor.Formats.OctreeQuantizer.Octree.Leaves">
            <summary>
            Gets or sets the number of leaves in the tree
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.OctreeQuantizer.Octree.ReducibleNodes">
            <summary>
            Gets the array of reducible nodes
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.AddColor(ImageProcessor.Bgra32)">
            <summary>
            Add a given color value to the Octree
            </summary>
            <param name="pixel">
            The <see cref="T:ImageProcessor.Bgra32"/>containing color information to add.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.Palletize(System.Int32)">
            <summary>
            Convert the nodes in the Octree to a palette with a maximum of colorCount colors
            </summary>
            <param name="colorCount">
            The maximum number of colors
            </param>
            <returns>
            An <see cref="T:System.Collections.Generic.List`1"/> with the palletized colors
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.GetPaletteIndex(ImageProcessor.Bgra32)">
            <summary>
            Get the palette index for the passed color
            </summary>
            <param name="pixel">
            The <see cref="T:ImageProcessor.Bgra32"/> containing the pixel data.
            </param>
            <returns>
            The index of the given structure.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.TrackPrevious(ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode)">
            <summary>
            Keep track of the previous node that was quantized
            </summary>
            <param name="node">
            The node last quantized
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.Reduce">
            <summary>
            Reduce the depth of the tree
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode">
            <summary>
            Class which encapsulates each node in the tree
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.children">
            <summary>
            Pointers to any child nodes
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.leaf">
            <summary>
            Flag indicating that this is a leaf node
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.pixelCount">
            <summary>
            Number of pixels in this node
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.red">
            <summary>
            Red component
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.green">
            <summary>
            Green Component
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.blue">
            <summary>
            Blue component
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.paletteIndex">
            <summary>
            The index of this node in the palette
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.#ctor(System.Int32,System.Int32,ImageProcessor.Formats.OctreeQuantizer.Octree)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode"/> class.
            </summary>
            <param name="level">
            The level in the tree = 0 - 7
            </param>
            <param name="colorBits">
            The number of significant color bits in the image
            </param>
            <param name="octree">
            The tree to which this node belongs
            </param>
        </member>
        <member name="P:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.NextReducible">
            <summary>
            Gets the next reducible node
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.AddColor(ImageProcessor.Bgra32,System.Int32,System.Int32,ImageProcessor.Formats.OctreeQuantizer.Octree)">
            <summary>
            Add a color into the tree
            </summary>
            <param name="pixel">
            The color
            </param>
            <param name="colorBits">
            The number of significant color bits
            </param>
            <param name="level">
            The level in the tree
            </param>
            <param name="octree">
            The tree to which this node belongs
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.Reduce">
            <summary>
            Reduce this node by removing all of its children
            </summary>
            <returns>The number of leaves removed</returns>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.ConstructPalette(System.Collections.Generic.List{ImageProcessor.Bgra32},System.Int32@)">
            <summary>
            Traverse the tree, building up the color palette
            </summary>
            <param name="palette">
            The palette
            </param>
            <param name="index">
            The current palette index
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.GetPaletteIndex(ImageProcessor.Bgra32,System.Int32)">
            <summary>
            Return the palette index for the passed color
            </summary>
            <param name="pixel">
            The <see cref="T:ImageProcessor.Bgra32"/> representing the pixel.
            </param>
            <param name="level">
            The level.
            </param>
            <returns>
            The <see cref="T:System.Int32"/> representing the index of the pixel in the palette.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.OctreeQuantizer.Octree.OctreeNode.Increment(ImageProcessor.Bgra32)">
            <summary>
            Increment the pixel count and add to the color information
            </summary>
            <param name="pixel">
            The pixel to add.
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.QuantizedImage">
            <summary>
            Represents a quantized image where the pixels indexed by a color palette.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.QuantizedImage.#ctor(System.Int32,System.Int32,ImageProcessor.Bgra32[],System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.QuantizedImage"/> class.
            </summary>
            <param name="width">The image width.</param>
            <param name="height">The image height.</param>
            <param name="palette">The color palette.</param>
            <param name="pixels">The quantized pixels.</param>
        </member>
        <member name="P:ImageProcessor.Formats.QuantizedImage.Width">
            <summary>
            Gets the width of this <see cref="T:QuantizedImage"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.QuantizedImage.Height">
            <summary>
            Gets the height of this <see cref="T:QuantizedImage"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.QuantizedImage.Palette">
            <summary>
            Gets the color palette of this <see cref="T:QuantizedImage"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.QuantizedImage.Pixels">
            <summary>
            Gets the pixels of this <see cref="T:QuantizedImage"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.QuantizedImage.ToImage">
            <summary>
            Converts this quantized image to a normal image.
            </summary>
            <returns>
            The <see cref="T:ImageProcessor.Image"/>
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.Quantizer">
            <summary>
            Encapsulates methods to calculate the color palette of an image.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Quantizer.singlePass">
            <summary>
            Flag used to indicate whether a single pass or two passes are needed for quantization.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Quantizer"/> class.
            </summary>
            <param name="singlePass">
            If true, the quantization only needs to loop through the source pixels once
            </param>
            <remarks>
            If you construct this class with a true value for singlePass, then the code will, when quantizing your image,
            only call the 'QuantizeImage' function. If two passes are required, the code will call 'InitialQuantizeImage'
            and then 'QuantizeImage'.
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.Quantize(ImageProcessor.ImageBase)">
            <summary>
            Quantize an image and return the resulting output pixels.
            </summary>
            <param name="imageBase">The image to quantize.</param>
            <returns>
            A <see cref="T:byte[]"/> representing a quantized version of the image pixels.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.FirstPass(ImageProcessor.ImageBase,System.Int32,System.Int32)">
            <summary>
            Execute the first pass through the pixels in the image
            </summary>
            <param name="source">The source data</param>
            <param name="width">The width in pixels of the image.</param>
            <param name="height">The height in pixels of the image.</param>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.SecondPass(ImageProcessor.ImageBase,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Execute a second pass through the bitmap
            </summary>
            <param name="source">The source image.</param>
            <param name="output">The output pixel array</param>
            <param name="width">The width in pixels of the image</param>
            <param name="height">The height in pixels of the image</param>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.InitialQuantizePixel(ImageProcessor.Bgra32)">
            <summary>
            Override this to process the pixel in the first pass of the algorithm
            </summary>
            <param name="pixel">
            The pixel to quantize
            </param>
            <remarks>
            This function need only be overridden if your quantize algorithm needs two passes,
            such as an Octree quantizer.
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.QuantizePixel(ImageProcessor.Bgra32)">
            <summary>
            Override this to process the pixel in the second pass of the algorithm
            </summary>
            <param name="pixel">
            The pixel to quantize
            </param>
            <returns>
            The quantized value
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.Quantizer.GetPalette">
            <summary>
            Retrieve the palette for the quantized image
            </summary>
            <returns>
            The new color palette
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.GifGraphicsControlExtension">
            <summary>
            The Graphic Control Extension contains parameters used when
            processing a graphic rendering block.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifGraphicsControlExtension.DisposalMethod">
            <summary>
            Gets or sets the disposal method which indicates the way in which the
            graphic is to be treated after being displayed.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifGraphicsControlExtension.TransparencyFlag">
            <summary>
            Gets or sets a value indicating whether transparency flag is to be set.
            This indicates whether a transparency index is given in the Transparent Index field.
            (This field is the least significant bit of the byte.)
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifGraphicsControlExtension.TransparencyIndex">
            <summary>
            Gets or sets the transparency index.
            The Transparency Index is such that when encountered, the corresponding pixel
            of the display device is not modified and processing goes on to the next pixel.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifGraphicsControlExtension.DelayTime">
            <summary>
            Gets or sets the delay time.
            If not 0, this field specifies the number of hundredths (1/100) of a second to
            wait before continuing with the processing of the Data Stream.
            The clock starts ticking immediately after the graphic is rendered.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.GifImageDescriptor">
            <summary>
            Each image in the Data Stream is composed of an Image Descriptor,
            an optional Local Color Table, and the image data.
            Each image must fit within the boundaries of the
            Logical Screen, as defined in the Logical Screen Descriptor.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.Left">
            <summary>
            Gets or sets the column number, in pixels, of the left edge of the image,
            with respect to the left edge of the Logical Screen.
            Leftmost column of the Logical Screen is 0.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.Top">
            <summary>
            Gets or sets the row number, in pixels, of the top edge of the image with
            respect to the top edge of the Logical Screen.
            Top row of the Logical Screen is 0.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.Width">
            <summary>
            Gets or sets the width of the image in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.Height">
            <summary>
            Gets or sets the height of the image in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.LocalColorTableFlag">
            <summary>
            Gets or sets a value indicating whether the presence of a Local Color Table immediately
            follows this Image Descriptor.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.LocalColorTableSize">
            <summary>
            Gets or sets the local color table size.
            If the Local Color Table Flag is set to 1, the value in this field
            is used to calculate the number of bytes contained in the Local Color Table.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifImageDescriptor.InterlaceFlag">
            <summary>
            Gets or sets a value indicating whether the image is to be interlaced.
            An image is interlaced in a four-pass interlace pattern.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.GifLogicalScreenDescriptor">
            <summary>
            The Logical Screen Descriptor contains the parameters
            necessary to define the area of the display device
            within which the images will be rendered
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.Width">
            <summary>
            Gets or sets the width, in pixels, of the Logical Screen where the images will
            be rendered in the displaying device.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.Height">
            <summary>
            Gets or sets the height, in pixels, of the Logical Screen where the images will be
            rendered in the displaying device.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.BackgroundColorIndex">
            <summary>
            Gets or sets the index at the Global Color Table for the Background Color.
            The Background Color is the color used for those
            pixels on the screen that are not covered by an image.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.PixelAspectRatio">
            <summary>
            Gets or sets the pixel aspect ratio. Default to 0.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.GlobalColorTableFlag">
            <summary>
            Gets or sets a value indicating whether a flag denoting the presence of a Global Color Table
            should be set.
            If the flag is set, the Global Color Table will immediately
            follow the Logical Screen Descriptor.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.GifLogicalScreenDescriptor.GlobalColorTableSize">
            <summary>
            Gets or sets the global color table size.
            If the Global Color Table Flag is set to 1,
            the value in this field is used to calculate the number of
            bytes contained in the Global Color Table.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.JpegDecoder">
            <summary>
            Image decoder for generating an image out of a jpg stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.JpegDecoder.HeaderSize">
            <summary>
            Gets the size of the header for this image type.
            </summary>
            <value>The size of the header.</value>
        </member>
        <member name="M:ImageProcessor.Formats.JpegDecoder.IsSupportedFileExtension(System.String)">
            <summary>
            Indicates if the image decoder supports the specified
            file extension.
            </summary>
            <param name="extension">The file extension.</param>
            <returns>
            <c>true</c>, if the decoder supports the specified
            extensions; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="extension"/>
            is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="extension"/> is a string
            of length zero or contains only blanks.</exception>
        </member>
        <member name="M:ImageProcessor.Formats.JpegDecoder.IsSupportedFileFormat(System.Byte[])">
            <summary>
            Indicates if the image decoder supports the specified
            file header.
            </summary>
            <param name="header">The file header.</param>
            <returns>
            <c>true</c>, if the decoder supports the specified
            file header; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="header"/>
            is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:ImageProcessor.Formats.JpegDecoder.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified stream and sets
            the data to image.
            </summary>
            <param name="image">The image, where the data should be set to.
            Cannot be null (Nothing in Visual Basic).</param>
            <param name="stream">The stream, where the image should be
            decoded from. Cannot be null (Nothing in Visual Basic).</param>
            <exception cref="T:System.ArgumentNullException">
            	<para><paramref name="image"/> is null (Nothing in Visual Basic).</para>
            	<para>- or -</para>
            	<para><paramref name="stream"/> is null (Nothing in Visual Basic).</para>
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.JpegDecoder.IsJpeg(System.Byte[])">
            <summary>
            Returns a value indicating whether the given bytes identify Jpeg data.
            </summary>
            <param name="header">The bytes representing the file header.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.JpegDecoder.IsExif(System.Byte[])">
            <summary>
            Returns a value indicating whether the given bytes identify EXIF data.
            </summary>
            <param name="header">The bytes representing the file header.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="T:ImageProcessor.Formats.JpegEncoder">
            <summary>
            Encoder for writing the data image to a stream in jpeg format.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.JpegEncoder.quality">
            <summary>
            The jpeg quality.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.JpegEncoder.Quality">
            <summary>
            Gets or sets the quality, that will be used to encode the image. Quality
            index must be between 0 and 100 (compression from max to min).
            </summary>
            <value>The quality of the jpg image from 0 to 100.</value>
        </member>
        <member name="P:ImageProcessor.Formats.JpegEncoder.MimeType">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.JpegEncoder.Extension">
            <summary>
            Gets the default file extension for this encoder.
            </summary>
            <value>The default file extension for this encoder.</value>
        </member>
        <member name="M:ImageProcessor.Formats.JpegEncoder.IsSupportedFileExtension(System.String)">
            <summary>
            Indicates if the image encoder supports the specified
            file extension.
            </summary>
            <param name="extension">The file extension.</param>
            <returns>
            	<c>true</c>, if the encoder supports the specified
            extensions; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="extension"/>
            is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="extension"/> is a string
            of length zero or contains only blanks.</exception>
        </member>
        <member name="M:ImageProcessor.Formats.JpegEncoder.Encode(ImageProcessor.ImageBase,System.IO.Stream)">
            <summary>
            Encodes the data of the specified image and writes the result to
            the specified stream.
            </summary>
            <param name="image">The image, where the data should be get from.
            Cannot be null (Nothing in Visual Basic).</param>
            <param name="stream">The stream, where the image data should be written to.
            Cannot be null (Nothing in Visual Basic).</param>
            <exception cref="T:System.ArgumentNullException">
            	<para><paramref name="image"/> is null (Nothing in Visual Basic).</para>
            	<para>- or -</para>
            	<para><paramref name="stream"/> is null (Nothing in Visual Basic).</para>
            </exception>
        </member>
        <member name="T:ImageProcessor.Formats.JpegFormat">
            <summary>
            Encapsulates the means to encode and decode jpeg images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.JpegFormat.Decoder">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.JpegFormat.Encoder">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.BitStream">
            <summary>
            A stream for reading bits in a sequence of bytes.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitStream.BitsInByte">
            <summary>
            The number of bits in byte.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitStream.isDisposed">
            <summary>
            A value indicating whether this instance of the given entity has been disposed.
            </summary>
            <value><see langword="true"/> if this instance has been disposed; otherwise, <see langword="false"/>.</value>
            <remarks>
            If the entity is disposed, it must not be disposed a second
            time. The isDisposed field is set the first time the entity
            is disposed. If the isDisposed field is true, then the Dispose()
            method will not dispose again. This help not to prolong the entity's
            life in the Garbage Collector.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.BitStream.stream">
            <summary>
            The underlying stream.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitStream.currentPosition">
            <summary>
            The current position.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.BitStream.size">
            <summary>
            The size of the underlying stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.BitStream"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.BitStream"/> class based on the 
            specified byte array.
            </summary>
            <param name="stream">
            The <see cref="T:Stream"/> from which to create the current stream.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the given stream is null.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.BitStream"/> class based on the 
            specified byte array.
            </summary>
            <param name="buffer">
            The <see cref="T:byte[]"/> from which to create the current stream.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the given buffer is null.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:ImageProcessor.Formats.BitStream"/> class. 
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.BitStream.UnderlyingStream">
            <summary>
            Gets the underlying stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Dispose">
            <summary>
            Disposes the object and frees resources for the Garbage Collector.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Size">
            <summary>
            Returns the size of the stream.
            </summary>
            <returns>
            The <see cref="T:System.Int32"/> representing the size.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Read(System.Int32)">
            <summary>
            Returns a number representing the given number of bits read from the stream
            advancing the stream by that number.
            </summary>
            <param name="bitCount">The number of bits to read.</param>
            <returns>
            The <see cref="T:System.Int32"/> representing the total number of bits read.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Write(System.Int32,System.Int32)">
            <summary>
            Writes a block of bits represented by an <see cref="T:System.Int32"/> to the current stream.
            </summary>
            <param name="bitStorage">The bits to write.</param>
            <param name="bitCount">The number of bits to write.</param>
            <returns>
            The <see cref="T:System.Int32"/> representing the number of bits written.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream to the specified value.
            </summary>
            <param name="position">
            The new position within the stream. 
            This is relative to the <paramref name="location"/> parameter, and can be positive or negative.
            </param>
            <param name="location">
            A value of type <see cref="T:System.IO.SeekOrigin"/>, which acts as the seek reference point.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Tell">
            <summary>
            TODO: Document this.
            </summary>
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.Dispose(System.Boolean)">
            <summary>
            Disposes the object and frees resources for the Garbage Collector.
            </summary>
            <param name="disposing">If true, the object gets disposed.</param>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.BitsAllocated">
            <summary>
            Returns the number of bits allocated to the stream.
            </summary>
            <returns>
            The <see cref="T:System.Int32"/> representing the number of bits.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.ReadBits(System.Int32)">
            <summary>
            Returns a number representing the given number of bits read from the stream.
            </summary>
            <param name="bitsCount">The number of bits to read.</param>
            <returns>
            The <see cref="T:System.Int32"/> representing the total number of bits read.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.WriteBits(System.Byte)">
            <summary>
            Writes a block of bits represented to the current stream.
            </summary>
            <param name="bits">
            The bits to write.
            </param>
            <returns>
            True. TODO: investigate this as it always returns true.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.SeekSet(System.Int32)">
            <summary>
            Sets the position within the current stream to the specified value.
            </summary>
            <param name="position">
            The new position within the stream. Can be positive or negative.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.BitStream.SeekCurrent(System.Int32)">
            <summary>
            Sets the position to current position in the current stream.
            </summary>
            <param name="position">
            The new position within the stream. Can be positive or negative.
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.GrayscaleReader">
            <summary>
            Color reader for reading grayscale colors from a png file.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GrayscaleReader.useAlpha">
            <summary>
            Whether t also read the alpha channel.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GrayscaleReader.row">
            <summary>
            The current row.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.GrayscaleReader.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.GrayscaleReader"/> class.
            </summary>
            <param name="useAlpha">
            If set to <c>true</c> the color reader will also read the
            alpha channel from the scanline.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.GrayscaleReader.ReadScanline(System.Byte[],System.Single[],ImageProcessor.Formats.PngHeader)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.IColorReader">
            <summary>
            Encapsulates methods for color readers, which are responsible for reading
            different color formats from a png file.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.IColorReader.ReadScanline(System.Byte[],System.Single[],ImageProcessor.Formats.PngHeader)">
            <summary>
            Reads the specified scanline.
            </summary>
            <param name="scanline">The scanline.</param>
            <param name="pixels">The pixels, where the colors should be stored in RGBA format.</param>
            <param name="header">
            The header, which contains information about the png file, like
            the width of the image and the height.
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.PaletteIndexReader">
            <summary>
            A color reader for reading palette indices from the png file.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PaletteIndexReader.palette">
            <summary>
            The palette.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PaletteIndexReader.paletteAlpha">
            <summary>
            The alpha palette.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PaletteIndexReader.row">
            <summary>
            The current row.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PaletteIndexReader.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.PaletteIndexReader"/> class.
            </summary>
            <param name="palette">The palette as simple byte array. It will contains 3 values for each
            color, which represents the red-, the green- and the blue channel.</param>
            <param name="paletteAlpha">The alpha palette. Can be null, if the image does not have an
            alpha channel and can contain less entries than the number of colors in the palette.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PaletteIndexReader.ReadScanline(System.Byte[],System.Single[],ImageProcessor.Formats.PngHeader)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.PngChunk">
            <summary>
            Stores header information about a chunk.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngChunk.Length">
            <summary>
            Gets or sets the length.
            An unsigned integer giving the number of bytes in the chunk's 
            data field. The length counts only the data field, not itself, 
            the chunk type code, or the CRC. Zero is a valid length
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngChunk.Type">
            <summary>
            Gets or sets the chunk type as string with 4 chars.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngChunk.Data">
            <summary>
            Gets or sets the data bytes appropriate to the chunk type, if any. 
            This field can be of zero length. 
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngChunk.Crc">
            <summary>
            Gets or sets a CRC (Cyclic Redundancy Check) calculated on the preceding bytes in the chunk, 
            including the chunk type code and chunk data fields, but not including the length field. 
            The CRC is always present, even for chunks containing no data
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.PngChunkTypes">
            <summary>
            Contains a list of possible chunk type identifiers.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Header">
            <summary>
            The first chunk in a png file. Can only exists once. Contains 
            common information like the width and the height of the image or
            the used compression method.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Palette">
            <summary>
            The PLTE chunk contains from 1 to 256 palette entries, each a three byte
            series in the RGB format.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Data">
            <summary>
            The IDAT chunk contains the actual image data. The image can contains more
            than one chunk of this type. All chunks together are the whole image.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.End">
            <summary>
            This chunk must appear last. It marks the end of the PNG data stream. 
            The chunk's data field is empty. 
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.PaletteAlpha">
            <summary>
            This chunk specifies that the image uses simple transparency: 
            either alpha values associated with palette entries (for indexed-color images) 
            or a single transparent color (for grayscale and true color images). 
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Text">
            <summary>
            Textual information that the encoder wishes to record with the image can be stored in 
            tEXt chunks. Each tEXt chunk contains a keyword and a text string.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Gamma">
            <summary>
            This chunk specifies the relationship between the image samples and the desired 
            display output intensity.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngChunkTypes.Physical">
            <summary>
            The pHYs chunk specifies the intended pixel size or aspect ratio for display of the image. 
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.PngColorTypeInformation">
            <summary>
            Contains information that are required when loading a png with a specific color type.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PngColorTypeInformation.#ctor(System.Int32,System.Int32[],System.Func{System.Byte[],System.Byte[],ImageProcessor.Formats.IColorReader})">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.PngColorTypeInformation"/> class with 
            the scanline factory, the function to create the color reader and the supported bit depths.
            </summary>
            <param name="scanlineFactor">The scanline factor.</param>
            <param name="supportedBitDepths">The supported bit depths.</param>
            <param name="scanlineReaderFactory">The factory to create the color reader.</param>
        </member>
        <member name="P:ImageProcessor.Formats.PngColorTypeInformation.SupportedBitDepths">
            <summary>
            Gets an array with the bit depths that are supported for the color type
            where this object is created for.
            </summary>
            <value>The supported bit depths that can be used in combination with this color type.</value>
        </member>
        <member name="P:ImageProcessor.Formats.PngColorTypeInformation.ScanlineReaderFactory">
            <summary>
            Gets a function that is used the create the color reader for the color type where 
            this object is created for.
            </summary>
            <value>The factory function to create the color type.</value>
        </member>
        <member name="P:ImageProcessor.Formats.PngColorTypeInformation.ChannelsPerColor">
            <summary>
            Gets a factor that is used when iterating through the scan lines.
            </summary>
            <value>The scanline factor.</value>
        </member>
        <member name="M:ImageProcessor.Formats.PngColorTypeInformation.CreateColorReader(System.Byte[],System.Byte[])">
            <summary>
            Creates the color reader for the color type where this object is create for.
            </summary>
            <param name="palette">The palette of the image. Can be null when no palette is used.</param>
            <param name="paletteAlpha">The alpha palette of the image. Can be null when 
            no palette is used for the image or when the image has no alpha.</param>
            <returns>The color reader for the image.</returns>
        </member>
        <member name="T:ImageProcessor.Formats.PngDecoder">
            <summary>
            Encoder for generating an image out of a png encoded stream.
            </summary>
            <remarks>
            At the moment the following features are supported:
            <para>
            <b>Filters:</b> all filters are supported.
            </para>
            <para>
            <b>Pixel formats:</b>
            <list type="bullet">
                <item>RGBA (True color) with alpha (8 bit).</item>
                <item>RGB (True color) without alpha (8 bit).</item>
                <item>Greyscale with alpha (8 bit).</item>
                <item>Greyscale without alpha (8 bit).</item>
                <item>Palette Index with alpha (8 bit).</item>
                <item>Palette Index without alpha (8 bit).</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:ImageProcessor.Formats.PngDecoder.HeaderSize">
            <summary>
            Gets the size of the header for this image type.
            </summary>
            <value>The size of the header.</value>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoder.IsSupportedFileExtension(System.String)">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="extension">The <see cref="T:System.String"/> containing the file extension.</param>
            <returns>
            True if the decoder supports the file extension; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoder.IsSupportedFileFormat(System.Byte[])">
            <summary>
            Returns a value indicating whether the <see cref="T:ImageProcessor.Formats.IImageDecoder"/> supports the specified
            file header.
            </summary>
            <param name="header">The <see cref="T:byte[]"/> containing the file header.</param>
            <returns>
            True if the decoder supports the file header; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoder.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the image from the specified stream to the <see cref="T:ImageProcessor.ImageBase"/>.
            </summary>
            <param name="image">The <see cref="T:ImageProcessor.ImageBase"/> to decode to.</param>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="T:ImageProcessor.Formats.PngDecoderCore">
            <summary>
            Performs the png decoding operation.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngDecoderCore.MaxChunkSize">
            <summary>
            The maximum chunk size.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngDecoderCore.ColorTypes">
            <summary>
            The dictionary of available color types.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngDecoderCore.currentImage">
            <summary>
            The image to decode.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngDecoderCore.currentStream">
            <summary>
            The stream to decode from.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngDecoderCore.header">
            <summary>
            The png header.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.#cctor">
            <summary>
            Initializes static members of the <see cref="T:ImageProcessor.Formats.PngDecoderCore"/> class.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.Decode(ImageProcessor.Image,System.IO.Stream)">
            <summary>
            Decodes the stream to the image.
            </summary>
            <param name="image">The image to decode to.</param>
            <param name="stream">The stream containing image data. </param>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Thrown if the stream does not contain and end chunk.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the image is larger than the maximum allowable size.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.PaethPredicator(System.Byte,System.Byte,System.Byte)">
            <summary>
            Computes a simple linear function of the three neighboring pixels (left, above, upper left), then chooses
            as predictor the neighboring pixel closest to the computed value.
            </summary>
            <param name="left">The left neighbour pixel.</param>
            <param name="above">The above neighbour pixel.</param>
            <param name="upperLeft">The upper left neighbour pixel.</param>
            <returns>
            The <see cref="T:System.Byte"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadPhysicalChunk(System.Byte[])">
            <summary>
            Reads the data chunk containing physical dimension data.
            </summary>
            <param name="data">The data containing physical data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.CalculateScanlineLength(ImageProcessor.Formats.PngColorTypeInformation)">
            <summary>
            Calculates the scanline length.
            </summary>
            <param name="colorTypeInformation">The color type information.</param>
            <returns>The <see cref="T:System.Int32"/> representing the length.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.CalculateScanlineStep(ImageProcessor.Formats.PngColorTypeInformation)">
            <summary>
            Calculates a scanline step.
            </summary>
            <param name="colorTypeInformation">The color type information.</param>
            <returns>The <see cref="T:System.Int32"/> representing the length of each step.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadScanlines(System.IO.MemoryStream,System.Single[],ImageProcessor.Formats.IColorReader,ImageProcessor.Formats.PngColorTypeInformation)">
            <summary>
            Reads the scanlines within the image.
            </summary>
            <param name="dataStream">The <see cref="T:System.IO.MemoryStream"/> containing data.</param>
            <param name="pixels">
            The <see cref="T:float[]"/> containing pixel data.</param>
            <param name="colorReader">The color reader.</param>
            <param name="colorTypeInformation">The color type information.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadTextChunk(System.Byte[])">
            <summary>
            Reads a text chunk containing image properties from the data.
            </summary>
            <param name="data">The <see cref="T:byte[]"/> containing  data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadHeaderChunk(System.Byte[])">
            <summary>
            Reads a header chunk from the data.
            </summary>
            <param name="data">The <see cref="T:byte[]"/> containing  data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ValidateHeader">
            <summary>
            Validates the png header.
            </summary>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Thrown if the image does pass validation.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadChunk">
            <summary>
            Reads a chunk from the stream.
            </summary>
            <returns>
            The <see cref="T:ImageProcessor.Formats.PngChunk"/>.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadChunkCrc(ImageProcessor.Formats.PngChunk,System.Byte[])">
            <summary>
            Reads the cycle redundancy chunk from the data.
            </summary>
            <param name="chunk">The chunk.</param>
            <param name="typeBuffer">The type buffer.</param>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Thrown if the input stream is not valid or corrupt.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadChunkData(ImageProcessor.Formats.PngChunk)">
            <summary>
            Reads the chunk data from the stream.
            </summary>
            <param name="chunk">The chunk.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if the chunk length exceeds the maximum allowable size.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadChunkType(ImageProcessor.Formats.PngChunk)">
            <summary>
            Identifies the chunk type from the chunk.
            </summary>
            <param name="chunk">The chunk.</param>
            <returns>
            The <see cref="T:byte[]"/> containing identifying information.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Thrown if the input stream is not valid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.ReadChunkLength(ImageProcessor.Formats.PngChunk)">
            <summary>
            Calculates the length of the given chunk.
            </summary>
            <param name="chunk">he chunk.</param>
            <returns>
            The <see cref="T:System.Int32"/> representing the chunk length.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Thrown if the input stream is not valid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.PngDecoderCore.Swap``1(``0@,``0@)">
            <summary>
            Swaps two references.
            </summary>
            <typeparam name="TRef">The type of the references to swap.</typeparam>
            <param name="lhs">The first reference.</param>
            <param name="rhs">The second reference.</param>
        </member>
        <member name="T:ImageProcessor.Formats.PngEncoder">
            <summary>
            Image encoder for writing image data to a stream in png format.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PngEncoder.MaxBlockSize">
            <summary>
            The maximum block size.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.PngEncoder"/> class.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.Quality">
            <summary>
            Gets or sets the quality of output for images.
            </summary>
            <remarks>Png is a lossless format so this is not used in this encoder.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.MimeType">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.Extension">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.IsWritingUncompressed">
            <summary>
            Gets or sets a value indicating whether this encoder
            will write the image uncompressed the stream.
            </summary>
            <value>
            <c>true</c> if the image should be written uncompressed to
            the stream; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.IsWritingGamma">
            <summary>
            Gets or sets a value indicating whether this instance is writing
            gamma information to the stream. The default value is false.
            </summary>
            <value>
            <c>True</c> if this instance is writing gamma
            information to the stream.; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ImageProcessor.Formats.PngEncoder.Gamma">
            <summary>
            Gets or sets the gamma value, that will be written
            the the stream, when the <see cref="P:ImageProcessor.Formats.PngEncoder.IsWritingGamma"/> property
            is set to true. The default value is 2.2f.
            </summary>
            <value>The gamma value of the image.</value>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.IsSupportedFileExtension(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.Encode(ImageProcessor.ImageBase,System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteInteger(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an integer to the byte array.
            </summary>
            <param name="data">The <see cref="T:byte[]"/> containing image data.</param>
            <param name="offset">The amount to offset by.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteInteger(System.IO.Stream,System.Int32)">
            <summary>
            Writes an integer to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteInteger(System.IO.Stream,System.UInt32)">
            <summary>
            Writes an unsigned integer to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WritePhysicalChunk(System.IO.Stream,ImageProcessor.ImageBase)">
            <summary>
            Writes the physical dimension information to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="imageBase">The image base.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteGammaChunk(System.IO.Stream)">
            <summary>
            Writes the gamma information to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteDataChunksFast(System.IO.Stream,ImageProcessor.ImageBase)">
            <summary>
            Writes the pixel information to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="imageBase">The image base.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteDataChunks(System.IO.Stream,ImageProcessor.ImageBase)">
            <summary>
            Writes the pixel information to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="imageBase">The image base.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteEndChunk(System.IO.Stream)">
            <summary>
            Writes the chunk end to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteHeaderChunk(System.IO.Stream,ImageProcessor.Formats.PngHeader)">
            <summary>
            Writes the header chunk to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing image data.</param>
            <param name="header">The <see cref="T:ImageProcessor.Formats.PngHeader"/>.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteChunk(System.IO.Stream,System.String,System.Byte[])">
            <summary>
            Writes a chunk to the stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to write to.</param>
            <param name="type">The type of chunk to write.</param>
            <param name="data">The <see cref="T:byte[]"/> containing data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PngEncoder.WriteChunk(System.IO.Stream,System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a chunk  of a specified length to the stream at the given offset.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to write to.</param>
            <param name="type">The type of chunk to write.</param>
            <param name="data">The <see cref="T:byte[]"/> containing data.</param>
            <param name="offset">The position to offset the data at.</param>
            <param name="length">The of the data to write.</param>
        </member>
        <member name="T:ImageProcessor.Formats.PngFormat">
            <summary>
            Encapsulates the means to encode and decode png images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngFormat.Decoder">
            <inheritdoc/>
        </member>
        <member name="P:ImageProcessor.Formats.PngFormat.Encoder">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.PngHeader">
            <summary>
            Represents the png header chunk.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.Width">
            <summary>
            Gets or sets the dimension in x-direction of the image in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.Height">
            <summary>
            Gets or sets the dimension in y-direction of the image in pixels.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.BitDepth">
            <summary>
            Gets or sets the bit depth.
            Bit depth is a single-byte integer giving the number of bits per sample 
            or per palette index (not per pixel). Valid values are 1, 2, 4, 8, and 16, 
            although not all values are allowed for all color types. 
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.ColorType">
            <summary>
            Gets or sets the color type.
            Color type is a integer that describes the interpretation of the 
            image data. Color type codes represent sums of the following values: 
            1 (palette used), 2 (color used), and 4 (alpha channel used).
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.CompressionMethod">
            <summary>
            Gets or sets the compression method.
            Indicates the method used to compress the image data. At present, 
            only compression method 0 (deflate/inflate compression with a sliding 
            window of at most 32768 bytes) is defined.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.FilterMethod">
            <summary>
            Gets or sets the preprocessing method.
            Indicates the preprocessing method applied to the image 
            data before compression. At present, only filter method 0 
            (adaptive filtering with five basic filter types) is defined.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.PngHeader.InterlaceMethod">
            <summary>
            Gets or sets the  transmission order.
            Indicates the transmission order of the image data. 
            Two values are currently defined: 0 (no interlace) or 1 (Adam7 interlace).
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.TrueColorReader">
            <summary>
            Color reader for reading true colors from a png file. Only colors
            with 24 or 32 bit (3 or 4 bytes) per pixel are supported at the moment.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.TrueColorReader.useAlpha">
            <summary>
            Whether t also read the alpha channel.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.TrueColorReader.row">
            <summary>
            The current row.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.TrueColorReader.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.TrueColorReader"/> class.
            </summary>
            <param name="useAlpha">if set to <c>true</c> the color reader will also read the
            alpha channel from the scanline.</param>
        </member>
        <member name="M:ImageProcessor.Formats.TrueColorReader.ReadScanline(System.Byte[],System.Single[],ImageProcessor.Formats.PngHeader)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Formats.Adler32">
             <summary>
             Computes Adler32 checksum for a stream of data. An Adler32
             checksum is not as reliable as a CRC32 checksum, but a lot faster to
             compute.
             </summary>
             <remarks>
             The specification for Adler32 may be found in RFC 1950.
             ZLIB Compressed Data Format Specification version 3.3)
            
            
             From that document:
            
                  "ADLER32 (Adler-32 checksum)
                   This contains a checksum value of the uncompressed data
                   (excluding any dictionary data) computed according to Adler-32
                   algorithm. This algorithm is a 32-bit extension and improvement
                   of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                   standard.
            
                   Adler-32 is composed of two sums accumulated per byte: s1 is
                   the sum of all bytes, s2 is the sum of all s1 values. Both sums
                   are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                   Adler-32 checksum is stored as s2*65536 + s1 in most-
                   significant-byte first (network) order."
            
              "8.2. The Adler-32 algorithm
            
                The Adler-32 algorithm is much faster than the CRC32 algorithm yet
                still provides an extremely low probability of undetected errors.
            
                The modulo on unsigned long accumulators can be delayed for 5552
                bytes, so the modulo operation time is negligible.  If the bytes
                are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
                and order sensitive, unlike the first sum, which is just a
                checksum.  That 65521 is prime is important to avoid a possible
                large class of two-byte errors that leave the check unchanged.
                (The Fletcher checksum uses 255, which is not prime and which also
                makes the Fletcher check insensitive to single byte changes 0 -
                255.)
            
                The sum s1 is initialized to 1 instead of zero to make the length
                of the sequence part of s2, so that the length does not have to be
                checked separately. (Any sequence of zeroes has a Fletcher
                checksum of zero.)"
             </remarks>
             <see cref="T:ImageProcessor.Formats.InflaterInputStream"/>
             <see cref="T:ImageProcessor.Formats.DeflaterOutputStream"/>
        </member>
        <member name="F:ImageProcessor.Formats.Adler32.Base">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Adler32.checksum">
            <summary>
            The checksum calculated to far.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Adler32.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Adler32"/> class. The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with a byte value.
            </summary>
            <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with an array of bytes.
            </summary>
            <param name="buffer">
            The source of the data to update with.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            an array of bytes
            </param>
            <param name="offset">
            the start of the data used for this update
            </param>
            <param name="count">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
             </summary>
             <remarks>
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.Crc32.CrcSeed">
            <summary>
            The crc seed
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Crc32.CrcTable">
            <summary>
            The table of all possible eight bit values for fast lookup.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name="value">The byte is taken as the lower 8 bits of value.</param>
        </member>
        <member name="M:ImageProcessor.Formats.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Crc32.ComputeCrc32(System.UInt32,System.Byte)">
            <summary>
            Computes the crc value for the given byte.
            </summary>
            <param name="oldCrc">The previous value.</param>
            <param name="value">The byte to compute against.</param>
            <returns>The <see cref="T:System.UInt32"/></returns>
        </member>
        <member name="T:ImageProcessor.Formats.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.BestCompression">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.BestSpeed">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.DefaultCompression">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.NoCompression">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.Deflated">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.IsSetdict">
            <summary>
            The is dictionary set flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.IsFlushing">
            <summary>
            Flags whether flushing.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.IsFinishing">
            <summary>
            Flags whether finishing.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.InitState">
            <summary>
            The initial stat flag
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.SetdictState">
            <summary>
            Flags setting the dictionary.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.BusyState">
            <summary>
            The busy state flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.FlushingState">
            <summary>
            The flushing state flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.FinishingState">
            <summary>
            The finishing state flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.FinishedState">
            <summary>
            The finished state flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.ClosedState">
            <summary>
            The closed state flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.deflaterLevel">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Deflater"/> class with the default compression level.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Deflater"/> class with the given compressin level.
            </summary>
            <param name="level">
            The compression level, a value between NoCompression and BestCompression, or DefaultCompression.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">If level is out of range.</exception>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Deflater"/> class with the given compressin level.
            </summary>
            <param name="level">
            The compression level, a value between NoCompression and BestCompression, or DefaultCompression.
            </param>
            <param name="noZlibHeaderOrFooter">
            True, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="P:ImageProcessor.Formats.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput().
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetStrategy(ImageProcessor.Formats.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.StoredBlock">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.StaticTrees">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.DynTrees">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.PresetDict">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.DefaultMemLevel">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.MaxMatch">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.MinMatch">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.MaxWbits">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.Wsize">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.Wmask">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.HashBits">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.HashSize">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.HashMask">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.HashShift">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.MinLookahead">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.MaxDist">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.PendingBufSize">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.Deflatestored">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.Deflatefast">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterConstants.Deflateslow">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.MaxBlockSize">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.GoodLength">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.MaxLazy">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.NiceLength">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.MaxChain">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterConstants.ComprFunc">
            <summary>
            Internal compression engine constant
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterEngine">
             <summary>
             Low level compression engine for deflate algorithm which uses a 32K sliding window
             with secondary compression from Huffman/Shannon-Fano codes.
             </summary>
             <remarks>
             DEFLATE ALGORITHM:
            
             The uncompressed stream is inserted into the window array.  When
             the window array is full the first half is thrown away and the
             second half is copied to the beginning.
            
             The head array is a hash table.  Three characters build a hash value
             and they the value points to the corresponding index in window of
             the last string with this hash.  The prev array implements a
             linked list of matches with the same hash: prev[index &amp; WMASK] points
             to the previous index with the same hash.
             </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.TooFar">
            <summary>
            One more than the maximum upper bounds.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.previousIndex">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.pending">
            <summary>
            Stores the pending output of the deflator
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.huffman">
            <summary>
            The huffman deflator
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.insertHashIndex">
            <summary>
            Hash index of string to be inserted.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.matchStart">
            <summary>
            Index of the beginning of a match.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.matchLen">
            <summary>
            Length of best match
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.prevAvailable">
            <summary>
            Set if previous match exists
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.blockStart">
            <summary>
            The index of the beinning of a block
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.maxChain">
            <summary>
            The maximum chain length
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.maxLazy">
            <summary>
            The maximum lazy length
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.niceLength">
            <summary>
            The nice length
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.goodLength">
            <summary>
            The good length
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.#ctor(ImageProcessor.Formats.DeflaterPending)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterEngine"/> class with a pending buffer.
            </summary>
            <param name="pending">The pending buffer to use</param>>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterEngine.Strategy">
            <summary>
            Get or sets the <see cref="T:ImageProcessor.Formats.DeflateStrategy"/>
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:ImageProcessor.Formats.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>
            <returns>Return true if input is needed via <see cref="M:ImageProcessor.Formats.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.FillWindow">
            <summary>
            Fills the window
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.UpdateHash">
            <summary>
            Updates this hash.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.SlideWindow">
            <summary>
            Slides the current byte window to the ewlefvent part of the uncompressed stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch">The current match.</param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.DeflateStored(System.Boolean,System.Boolean)">
            <summary>
            Returns a value indicating whether the uncompressed block is stored.
            </summary>
            <param name="flush">Whether to flush the stream.</param>
            <param name="finish">Whether to finish the stream.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.DeflateFast(System.Boolean,System.Boolean)">
            <summary>
            Performs a fast deflation of the input stream return a value to indicate succes.
            </summary>
            <param name="flush">Whether to flush the stream.</param>
            <param name="finish">Whether to finish the stream.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterEngine.DeflateSlow(System.Boolean,System.Boolean)">
            <summary>
            Performs a slow deflation of the input stream return a value to indicate succes.
            </summary>
            <param name="flush">Whether to flush the stream.</param>
            <param name="finish">Whether to finish the stream.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterHuffman">
             <summary>
             This is the DeflaterHuffman class.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of Deflate and SetInput.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Buffersize">
            <summary>
            The buffer size.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.LiteralCount">
            <summary>
            The number of literals.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.DistanceCodeCount">
            <summary>
            Number of distance codes
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.BitLengthCount">
            <summary>
            Number of codes used to transfer bit lengths
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Repeat3To6">
            <summary>
            Repeat previous bit length 3-6 times (2 bits of repeat count)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Repeat3To10">
            <summary>
            Repeat a zero length 3-10 times  (3 bits of repeat count)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Repeat11To138">
            <summary>
            Repeat a zero length 11-138 times  (7 bits of repeat count)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Eof">
            <summary>
            The end of file flag.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.BitLengthOrder">
            <summary>
            The lengths of the bit length codes are sent in order of decreasing
            probability, to avoid transmitting the lengths for unused bit length codes.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Bit4Reverse">
            <summary>
            Bit data reversed.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.staticLCodes">
            <summary>
            The literal codes.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterHuffman.Tree">
            <summary>
            A binary tree, with the property, that the parent node is smaller than both child nodes.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Tree.minimumNumberOfCodes">
            <summary>
            The minimum number of codes.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.Tree.codes">
            <summary>
            The array of codes.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.#ctor(ImageProcessor.Formats.DeflaterHuffman,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterHuffman.Tree"/> class.
            </summary>
            <param name="huffman">The <see cref="T:ImageProcessor.Formats.DeflaterHuffman"/></param>
            <param name="elems">The elements.</param>
            <param name="minCodes">The minimum number of codes.</param>
            <param name="maxLength">The maximum length.</param>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterHuffman.Tree.NumberOfCodes">
            <summary>
            Gets the number of codes.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterHuffman.Tree.Frequencies">
            <summary>
            Gets the frequencies.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterHuffman.Tree.Length">
            <summary>
            Gets or sets the length.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.WriteSymbol(System.Int32)">
            <summary>
            Writes a code symbol.
            </summary>
            <param name="code">The code index.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.CalcBLFreq(ImageProcessor.Formats.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Tree.WriteTree(ImageProcessor.Formats.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.#ctor(ImageProcessor.Formats.DeflaterPending)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterHuffman"/> class with a pending buffer.
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.Reset">
            <summary>
            Resets the internal state
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.deflater">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.baseOutputStream">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.bytebuffer">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.password">
            <summary>
            The password
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.keys">
            <summary>
            The keys
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.isClosed">
            <summary>
            Whether the stream is closed
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflaterOutputStream.isStreamOwner">
            <summary>
            Whether dispose should close the underlying stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterOutputStream"/> class
            with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.#ctor(System.IO.Stream,ImageProcessor.Formats.Deflater)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterOutputStream"/> class
            with the given Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.#ctor(System.IO.Stream,ImageProcessor.Formats.Deflater,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterOutputStream"/> class
            with the given Deflater and buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size in bytes to use when deflating (minimum value 512)
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">buffersize is less than or equal to zero.</exception>
            <exception cref="T:System.ArgumentException">baseOutputStream does not support writing.</exception>
            <exception cref="T:System.ArgumentNullException">deflater instance is null.</exception>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:ImageProcessor.Formats.DeflaterOutputStream.Dispose(System.Boolean)"></see> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.
            </summary>
            <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater.
            </summary>
            <exception cref="T:ImageProcessor.ImageFormatException">
            Not all input is deflated
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:ImageProcessor.Formats.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given <paramref name="pssword"/>.
            </summary>
            <param name="pssword">The password.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.EncryptByte">
            <summary>
            Encrypt a single byte
            </summary>
            <returns>
            The encrypted value
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys
            </summary>
            <param name="ch">The character.</param>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterOutputStream.Dispose(System.Boolean)">
            <summary>
            Calls <see cref="M:ImageProcessor.Formats.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:ImageProcessor.Formats.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
            <param name="disposing">If true, the object gets disposed.</param>
        </member>
        <member name="T:ImageProcessor.Formats.DeflaterPending">
             <summary>
             This class stores the pending output of the Deflater.
            
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ImageProcessor.Formats.DeflaterPending.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.DeflaterPending"/> class.
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set indicates strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and 
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "value">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="T:ImageProcessor.Formats.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
            
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream.
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or
            footer.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Inflater"/> class.
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.#ctor(System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:ImageProcessor.Formats.Inflater"/> class.
             </summary>
             <param name="noHeader">
             True if no RFC1950/Zlib header and footer fields are expected in the input data
            
             This is used for GZIPed/Zipped input.
            
             For compatibility with
             Sun JDK you should provide one byte of input more than needed in
             this case.
             </param>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:ImageProcessor.ImageFormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:ImageProcessor.ImageFormatException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput().
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:ImageProcessor.Formats.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterDynHeader.mode">
            <summary>
            The current decode mode
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterHuffmanTree.GetSymbol(ImageProcessor.Formats.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:ImageProcessor.Formats.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ImageProcessor.Formats.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:ImageProcessor.Formats.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:ImageProcessor.Formats.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:ImageProcessor.Formats.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.SetInflaterInput(ImageProcessor.Formats.Inflater)">
            <summary>
            Call <see cref="M:ImageProcessor.Formats.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="T:ImageProcessor.Formats.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="!:ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.#ctor(System.IO.Stream,ImageProcessor.Formats.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.#ctor(System.IO.Stream,ImageProcessor.Formats.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:ImageProcessor.Formats.InflaterInputStream.Dispose(System.Boolean)"/> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="!:SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ImageProcessor.Formats.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="!:SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:ImageProcessor.Formats.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.InflaterInputStream.isStreamOwner">
            <summary>
            Flag indicating wether this instance is designated the stream owner.
            When closing if this flag is true the underlying stream is closed.
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.CopyStored(ImageProcessor.Formats.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:ImageProcessor.Formats.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:ImageProcessor.Formats.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.PendingBuffer.buffer_">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="P:ImageProcessor.Formats.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="P:ImageProcessor.Formats.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:ImageProcessor.Formats.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="T:ImageProcessor.Formats.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ImageProcessor.Formats.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:ImageProcessor.Formats.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:ImageProcessor.Formats.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:ImageProcessor.Formats.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:ImageProcessor.Formats.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry. </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.VERSION_AES">
            <summary>
            Version indicating AES encryption
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions (4.5 or higher)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ImageProcessor.Formats.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="P:ImageProcessor.Formats.ZipConstants.DefaultEncoding">
            <summary>
            PCL don't support CodePage so we used Encoding instead of
            </summary>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string.
            </summary>
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[count - 1] converted to a string
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">Byte array to convert</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ImageProcessor.Formats.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="flags">The applicable <see cref="T:ImageProcessor.Formats.GeneralBitFlags">general purpose bits flags</see></param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="T:ImageProcessor.Point">
            <summary>
            Represents an ordered pair of integer x- and y-coordinates that defines a point in
            a two-dimensional plane.
            </summary>
            <remarks>
            This struct is fully mutable. This is done (against the guidelines) for the sake of performance,
            as it avoids the need to create new values for modification operations.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Point.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Point"/> that has X and Y values set to zero.
            </summary>
        </member>
        <member name="M:ImageProcessor.Point.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Point"/> struct.
            </summary>
            <param name="x">The horizontal position of the point.</param>
            <param name="y">The vertical position of the point.</param>
        </member>
        <member name="P:ImageProcessor.Point.X">
            <summary>
            The x-coordinate of this <see cref="T:ImageProcessor.Point"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Point.Y">
            <summary>
            The y-coordinate of this <see cref="T:ImageProcessor.Point"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Point.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Point"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.Point.op_Equality(ImageProcessor.Point,ImageProcessor.Point)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Point"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.Point.X"/> or <see cref="P:ImageProcessor.Point.Y"/> properties of the two
            <see cref="T:ImageProcessor.Point"/> objects are equal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Point"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Point"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Point.op_Inequality(ImageProcessor.Point,ImageProcessor.Point)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Point"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.Point.X"/> or <see cref="P:ImageProcessor.Point.Y"/> properties of the two
            <see cref="T:ImageProcessor.Point"/> objects are unequal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Point"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Point"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Point.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <param name="obj">
            The object to compare with the current instance.
            </param>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the
            same value; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Point.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:ImageProcessor.Point.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="M:ImageProcessor.Point.Equals(ImageProcessor.Point)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            True if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ImageProcessor.Point.GetHashCode(ImageProcessor.Point)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="point">
            The instance of <see cref="T:ImageProcessor.Point"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Rectangle">
            <summary>
            Stores a set of four integers that represent the location and size of a rectangle.
            </summary>
            <remarks>
            This struct is fully mutable. This is done (against the guidelines) for the sake of performance,
            as it avoids the need to create new values for modification operations.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Rectangle.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Rectangle"/> that has X, Y, Width, and Height values set to zero.
            </summary>
        </member>
        <member name="M:ImageProcessor.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Rectangle"/> struct.
            </summary>
            <param name="x">The horizontal position of the rectangle.</param>
            <param name="y">The vertical position of the rectangle.</param>
            <param name="width">The width of the rectangle.</param>
            <param name="height">The height of the rectangle.</param>
        </member>
        <member name="M:ImageProcessor.Rectangle.#ctor(ImageProcessor.Point,ImageProcessor.Size)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Rectangle"/> struct.
            </summary>
            <param name="point">
            The <see cref="T:ImageProcessor.Point"/> which specifies the rectangles point in a two-dimensional plane.
            </param>
            <param name="size">
            The <see cref="T:ImageProcessor.Size"/> which specifies the rectangles height and width.
            </param>
        </member>
        <member name="P:ImageProcessor.Rectangle.X">
            <summary>
            The x-coordinate of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Y">
            <summary>
            The y-coordinate of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Width">
            <summary>
            The width of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Height">
            <summary>
            The height of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Rectangle"/> is empty.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Top">
            <summary>
            Gets the y-coordinate of the top edge of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Right">
            <summary>
            Gets the x-coordinate of the right edge of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Bottom">
            <summary>
            Gets the y-coordinate of the bottom edge of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Rectangle.Left">
            <summary>
            Gets the x-coordinate of the left edge of this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
        </member>
        <member name="M:ImageProcessor.Rectangle.op_Equality(ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Rectangle"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.Rectangle.X"/>, <see cref="P:ImageProcessor.Rectangle.Y"/>, <see cref="P:ImageProcessor.Rectangle.Width"/>,
            and the <see cref="P:ImageProcessor.Rectangle.Height"/>properties of the two
            <see cref="T:ImageProcessor.Rectangle"/> objects are equal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Rectangle"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Rectangle"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Rectangle.op_Inequality(ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Rectangle"/> objects. The result specifies whether the values
            of the <see cref="P:ImageProcessor.Rectangle.X"/>, <see cref="P:ImageProcessor.Rectangle.Y"/>, <see cref="P:ImageProcessor.Rectangle.Width"/>,
            and the <see cref="P:ImageProcessor.Rectangle.Height"/>properties of the two
            <see cref="T:ImageProcessor.Rectangle"/> objects are unequal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Rectangle"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Rectangle"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Rectangle.Contains(System.Int32,System.Int32)">
            <summary>
            Determines if the specfied point is contained within the rectangular region defined by
            this <see cref="T:ImageProcessor.Rectangle"/>.
            </summary>
            <param name="x">The x-coordinate of the given point.</param>
            <param name="y">The y-coordinate of the given point.</param>
            <returns>The <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:ImageProcessor.Rectangle.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            True if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:ImageProcessor.Rectangle.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:ImageProcessor.Rectangle.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="M:ImageProcessor.Rectangle.Equals(ImageProcessor.Rectangle)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            True if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ImageProcessor.Rectangle.GetHashCode(ImageProcessor.Rectangle)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="rectangle">
            The instance of <see cref="T:ImageProcessor.Rectangle"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Size">
            <summary>
            Stores an ordered pair of integers, which specify a height and width.
            </summary>
            <remarks>
            This struct is fully mutable. This is done (against the guidelines) for the sake of performance,
            as it avoids the need to create new values for modification operations.
            </remarks>
        </member>
        <member name="F:ImageProcessor.Size.Empty">
            <summary>
            Represents a <see cref="T:ImageProcessor.Size"/> that has Width and Height values set to zero.
            </summary>
        </member>
        <member name="M:ImageProcessor.Size.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Size"/> struct.
            </summary>
            <param name="width">
            The width of the size.
            </param>
            <param name="height">
            The height of the size.
            </param>
        </member>
        <member name="P:ImageProcessor.Size.Width">
            <summary>
            The width of this <see cref="T:ImageProcessor.Size"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Size.Height">
            <summary>
            The height of this <see cref="T:ImageProcessor.Size"/>.
            </summary>
        </member>
        <member name="P:ImageProcessor.Size.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:ImageProcessor.Size"/> is empty.
            </summary>
        </member>
        <member name="M:ImageProcessor.Size.op_Equality(ImageProcessor.Size,ImageProcessor.Size)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Size"/> objects. The result specifies whether the values
            <see cref="P:ImageProcessor.Size.Width"/> and the <see cref="P:ImageProcessor.Size.Height"/>properties of the two
            <see cref="T:ImageProcessor.Size"/> objects are equal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Size"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Size"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is equal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Size.op_Inequality(ImageProcessor.Size,ImageProcessor.Size)">
            <summary>
            Compares two <see cref="T:ImageProcessor.Size"/> objects. The result specifies whether the values
            <see cref="P:ImageProcessor.Size.Width"/> and the <see cref="P:ImageProcessor.Size.Height"/>properties of the two
            <see cref="T:ImageProcessor.Size"/> objects are unequal.
            </summary>
            <param name="left">
            The <see cref="T:ImageProcessor.Size"/> on the left side of the operand.
            </param>
            <param name="right">
            The <see cref="T:ImageProcessor.Size"/> on the right side of the operand.
            </param>
            <returns>
            True if the current left is unequal to the <paramref name="right"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:ImageProcessor.Size.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            True if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current instance. </param>
        </member>
        <member name="M:ImageProcessor.Size.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:ImageProcessor.Size.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing a fully qualified type name.
            </returns>
        </member>
        <member name="M:ImageProcessor.Size.Equals(ImageProcessor.Size)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            True if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ImageProcessor.Size.GetHashCode(ImageProcessor.Size)">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <param name="size">
            The instance of <see cref="T:ImageProcessor.Size"/> to return the hash code for.
            </param>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="T:ImageProcessor.Samplers.Crop">
            <summary>
            Provides methods to allow the cropping of an image.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.Crop.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.ImageSampleExtensions">
            <summary>
            Extensions methods for <see cref="T:ImageProcessor.Image"/> to apply samplers to the image.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.ImageSampleExtensions.Resize(ImageProcessor.Image,System.Int32,System.Int32)">
            <summary>
            Resizes an image to the given width and height.
            </summary>
            <param name="source">The image to resize.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/></returns>
        </member>
        <member name="M:ImageProcessor.Samplers.ImageSampleExtensions.Resize(ImageProcessor.Image,System.Int32,System.Int32,ImageProcessor.Samplers.IResampler)">
            <summary>
            Resizes an image to the given width and height with the given sampler.
            </summary>
            <param name="source">The image to resize.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <param name="sampler">The <see cref="T:ImageProcessor.Samplers.IResampler"/> to perform the resampling.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/></returns>
        </member>
        <member name="M:ImageProcessor.Samplers.ImageSampleExtensions.Resize(ImageProcessor.Image,System.Int32,System.Int32,ImageProcessor.Samplers.IResampler,ImageProcessor.Rectangle)">
            <summary>
            Resizes an image to the given width and height with the given sampler and
            source rectangle.
            </summary>
            <param name="source">The image to resize.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <param name="sampler">The <see cref="T:ImageProcessor.Samplers.IResampler"/> to perform the resampling.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/></returns>
        </member>
        <member name="M:ImageProcessor.Samplers.ImageSampleExtensions.Crop(ImageProcessor.Image,System.Int32,System.Int32)">
            <summary>
            Crops an image to the given width and height.
            </summary>
            <param name="source">The image to resize.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <returns>The <see cref="T:ImageProcessor.Image"/></returns>
        </member>
        <member name="M:ImageProcessor.Samplers.ImageSampleExtensions.Crop(ImageProcessor.Image,System.Int32,System.Int32,ImageProcessor.Rectangle)">
            <summary>
            Crops an image to the given width and height with the given source rectangle.
            <remarks>
            If the source rectangle is smaller than the target dimensions then the
            area within the source is resized performing a zoomed crop.
            </remarks>
            </summary>
            <param name="source">The image to resize.</param>
            <param name="width">The target image width.</param>
            <param name="height">The target image height.</param>
            <param name="sourceRectangle">
            The <see cref="T:ImageProcessor.Rectangle"/> structure that specifies the portion of the image object to draw.
            </param>
            <returns>The <see cref="T:ImageProcessor.Image"/></returns>
        </member>
        <member name="T:ImageProcessor.Samplers.Resize">
            <summary>
            Provides methods that allow the resizing of images using various resampling algorithms.
            </summary>
        </member>
        <member name="F:ImageProcessor.Samplers.Resize.Epsilon">
            <summary>
            The epsilon for comparing floating point numbers.
            </summary>
        </member>
        <member name="F:ImageProcessor.Samplers.Resize.horizontalWeights">
            <summary>
            The horizontal weights.
            </summary>
        </member>
        <member name="F:ImageProcessor.Samplers.Resize.verticalWeights">
            <summary>
            The vertical weights.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.Resize.#ctor(ImageProcessor.Samplers.IResampler)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Samplers.Resize"/> class.
            </summary>
            <param name="sampler">
            The sampler to perform the resize operation.
            </param>
        </member>
        <member name="P:ImageProcessor.Samplers.Resize.Sampler">
            <summary>
            Gets the sampler to perform the resize operation.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.Resize.OnApply(ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.Resize.Apply(ImageProcessor.ImageBase,ImageProcessor.ImageBase,ImageProcessor.Rectangle,ImageProcessor.Rectangle,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.Resize.PrecomputeWeights(System.Int32,System.Int32)">
            <summary>
            Computes the weights to apply at each pixel when resizing.
            </summary>
            <param name="destinationSize">The destination section size.</param>
            <param name="sourceSize">The source section size.</param>
            <returns>
            The <see cref="T:Weights[]"/>.
            </returns>
        </member>
        <member name="T:ImageProcessor.Samplers.Resize.Weight">
            <summary>
            Represents the weight to be added to a scaled pixel.
            </summary>
        </member>
        <member name="F:ImageProcessor.Samplers.Resize.Weight.Index">
            <summary>
            The pixel index.
            </summary>
        </member>
        <member name="F:ImageProcessor.Samplers.Resize.Weight.Value">
            <summary>
            The result of the interpolation algorithm.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.Resize.Weight.#ctor(System.Int32,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:ImageProcessor.Samplers.Resize.Weight"/> struct.
            </summary>
            <param name="index">The index.</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:ImageProcessor.Samplers.Resize.Weights">
            <summary>
            Represents a collection of weights and their sum.
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.Resize.Weights.Values">
            <summary>
            Gets or sets the values.
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.Resize.Weights.Sum">
            <summary>
            Gets or sets the sum.
            </summary>
        </member>
        <member name="T:ImageProcessor.Samplers.BicubicResampler">
            <summary>
            The function implements the bicubic kernel algorithm W(x) as described on
            <see href="https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">Wikipedia</see>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.BicubicResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.BicubicResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.BoxResampler">
            <summary>
            The function implements the box (nearest neighbour) algorithm.
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.BoxResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.BoxResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.CatmullRomResampler">
            <summary>
            The function implements the Catmull-Rom algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#cubic_bc"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.CatmullRomResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.CatmullRomResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.HermiteResampler">
            <summary>
            The function implements the hermite algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#cubic_bc"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.HermiteResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.HermiteResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.IResampler">
            <summary>
            Encapsulates an interpolation algorithm for resampling images.
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.IResampler.Radius">
            <summary>
            Gets the radius in which to sample pixels.
            </summary>
        </member>
        <member name="M:ImageProcessor.Samplers.IResampler.GetValue(System.Single)">
            <summary>
            Gets the result of the interpolation algorithm.
            </summary>
            <param name="x">The value to process.</param>
            <returns>
            The <see cref="T:System.Single"/>
            </returns>
        </member>
        <member name="T:ImageProcessor.Samplers.Lanczos3Resampler">
            <summary>
            The function implements the Lanczos kernel algorithm as described on
            <see href="https://en.wikipedia.org/wiki/Lanczos_resampling#Algorithm">Wikipedia</see>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.Lanczos3Resampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.Lanczos3Resampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.Lanczos5Resampler">
            <summary>
            The function implements the Lanczos kernel algorithm as described on
            <see href="https://en.wikipedia.org/wiki/Lanczos_resampling#Algorithm">Wikipedia</see>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.Lanczos5Resampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.Lanczos5Resampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.Lanczos8Resampler">
            <summary>
            The function implements the Lanczos kernel algorithm as described on
            <see href="https://en.wikipedia.org/wiki/Lanczos_resampling#Algorithm">Wikipedia</see>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.Lanczos8Resampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.Lanczos8Resampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.MitchellNetravaliResampler">
            <summary>
            The function implements the mitchell algorithm as described on
            <see href="https://de.wikipedia.org/wiki/Mitchell-Netravali-Filter">Wikipedia</see>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.MitchellNetravaliResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.MitchellNetravaliResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.RobidouxResampler">
            <summary>
            The function implements the Robidoux algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#robidoux"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.RobidouxResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.RobidouxResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.RobidouxSharpResampler">
            <summary>
            The function implements the Robidoux Sharp algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#robidoux"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.RobidouxSharpResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.RobidouxSharpResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.RobidouxSoftResampler">
            <summary>
            The function implements the Robidoux Soft algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#robidoux"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.RobidouxSoftResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.RobidouxSoftResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.SplineResampler">
            <summary>
            The function implements the spline algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/#cubic_bc"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.SplineResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.SplineResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.TriangleResampler">
            <summary>
            The function implements the triangle (bilinear) algorithm.
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.TriangleResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.TriangleResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:ImageProcessor.Samplers.WelchResampler">
            <summary>
            The function implements the welch algorithm.
            <see href="http://www.imagemagick.org/Usage/filter/"/>
            </summary>
        </member>
        <member name="P:ImageProcessor.Samplers.WelchResampler.Radius">
            <inheritdoc/>
        </member>
        <member name="M:ImageProcessor.Samplers.WelchResampler.GetValue(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.BeginWrite">
            <summary>
            Startup: normally writes the file header.
            In this module we may as well postpone everything until finish_output.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.ProcessPixelsRow(System.Byte[])">
            <summary>
            Write some pixel data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.EndWrite">
            <summary>
            Finish up at the end of the file.
            Here is where we really output the BMP file.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putGrayRow(System.Byte[])">
            <summary>
            This version is for grayscale OR quantized color output
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putRgbRow(System.Byte[])">
            <summary>
            This version is for writing 24-bit pixels
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.putCmykRow(System.Byte[])">
            <summary>
            This version is for writing 24-bit pixels
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.writeHeader">
            <summary>
            Write a Windows-style BMP file header, including colormap if needed
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.BitmapDestination.writeColormap(System.Int32,System.Int32)">
            <summary>
            Write the colormap.
            Windows uses BGR0 map entries; OS/2 uses BGR entries.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.CompressionParameters">
            <summary>
            Parameters of compression.
            </summary>
            <remarks>Being used in <see cref="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream,BitMiracle.LibJpeg.CompressionParameters)"/></remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.CompressionParameters"/> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            	<c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.CompressionParameters.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms 
            and data structures like a hash table. 
            </returns>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.Quality">
            <summary>
            Gets or sets the quality of JPEG image.
            </summary>
            <remarks>Default value: 75<br/>
            The quality value is expressed on the 0..100 scale.
            </remarks>
            <value>The quality of JPEG image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.SmoothingFactor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br/>
            If non-zero, the input image is smoothed; the value should be 1 for
            minimal smoothing to 100 for maximum smoothing.
            </remarks>
            <value>The coefficient of image smoothing.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.CompressionParameters.SimpleProgressive">
            <summary>
            Gets or sets a value indicating whether to write a progressive-JPEG file.
            </summary>
            <value>
            <c>true</c> for writing a progressive-JPEG file; <c>false</c> 
            for non-progressive JPEG files.
            </value>
        </member>
        <member name="T:BitMiracle.LibJpeg.DecompressorToJpegImage">
            <summary>
            Decompresses a jpeg image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.DecompressorToJpegImage.jpegImage">
            <summary>
            The jpeg image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.DecompressorToJpegImage.#ctor(BitMiracle.LibJpeg.JpegImage)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.DecompressorToJpegImage"/> class.
            </summary>
            <param name="jpegImage">
            The jpeg image.
            </param>
        </member>
        <member name="P:BitMiracle.LibJpeg.DecompressorToJpegImage.Output">
            <summary>
            Gets the stream with decompressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.DecompressorToJpegImage.SetImageAttributes(BitMiracle.LibJpeg.LoadedImageAttributes)">
            <summary>
            Sets the image attributes.
            </summary>
            <param name="parameters">
            The <see cref="T:BitMiracle.LibJpeg.LoadedImageAttributes"/> containing attributes.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            </exception>
        </member>
        <member name="M:BitMiracle.LibJpeg.DecompressorToJpegImage.BeginWrite">
            <summary>
            Begins writing.
            </summary>
            <remarks>Not implemented.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.DecompressorToJpegImage.ProcessPixelsRow(System.Byte[])">
            <summary>
            Processes the given row of pixels.
            </summary>
            <param name="row">
            The <see cref="T:byte[]"/> representing the row.
            </param>
        </member>
        <member name="M:BitMiracle.LibJpeg.DecompressorToJpegImage.EndWrite">
            <summary>
            Ends write.
            </summary>
            <remarks>Not implemented.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Colorspace">
            <summary>
            Known color spaces.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.Unknown">
            <summary>
            Unspecified colorspace
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.Grayscale">
            <summary>
            Grayscale
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.RGB">
            <summary>
            RGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.YCbCr">
            <summary>
            YCbCr (also known as YUV)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.CMYK">
            <summary>
            CMYK
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Colorspace.YCCK">
            <summary>
            YCbCrK
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.DCTMethod">
            <summary>
            DCT/IDCT algorithm options.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.DitherMode">
            <summary>
            Dithering options for decompression.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.IDecompressDestination">
            <summary>
            Common interface for processing of decompression.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.IDecompressDestination.Output">
            <summary>
            Gets the stream with decompressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.SetImageAttributes(BitMiracle.LibJpeg.LoadedImageAttributes)">
            <summary>
            Sets the image attributes.
            </summary>
            <param name="parameters">
            The <see cref="T:BitMiracle.LibJpeg.LoadedImageAttributes"/> containing attributes.
            </param>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.BeginWrite">
            <summary>
            Begins writing. Called before decompression
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.ProcessPixelsRow(System.Byte[])">
            <summary>
            Processes the given row of pixels.
            </summary>
            <param name="row">
            The <see cref="T:byte[]"/> representing the row.
            </param>
        </member>
        <member name="M:BitMiracle.LibJpeg.IDecompressDestination.EndWrite">
            <summary>
            Ends writing. Called after decompression
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Jpeg">
            <summary>
            Internal wrapper for classic jpeg compressor and decompressor
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Jpeg.CompressionParameters">
            <summary>
            Advanced users may set specific parameters of compression
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Jpeg.DecompressionParameters">
            <summary>
            Advanced users may set specific parameters of decompression
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.Compress(BitMiracle.LibJpeg.IRawImage,System.IO.Stream)">
            <summary>
            Compresses any image described as ICompressSource to JPEG
            </summary>
            <param name="source">Contains description of input image</param>
            <param name="output">Stream for output of compressed JPEG</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.Decompress(System.IO.Stream,BitMiracle.LibJpeg.IDecompressDestination)">
            <summary>
            Decompresses JPEG image to any image described as ICompressDestination
            </summary>
            <param name="jpeg">Stream with JPEG data</param>
            <param name="destination">Stream for output of compressed JPEG</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Jpeg.beforeDecompress(System.IO.Stream)">
            <summary>
            Tunes decompressor
            </summary>
            <param name="jpeg">Stream with input compressed JPEG data</param>
        </member>
        <member name="T:BitMiracle.LibJpeg.Jpeg.MarkerParser">
            <summary>
            Delegate for application-supplied marker processing methods.
            Need not pass marker code since it is stored in cinfo.unread_marker.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.JpegImage">
            <summary>
            Main class for work with JPEG images.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_rows">
            <summary>
            Description of image pixels (samples)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_compressedData">
            <summary>
            Bytes of jpeg image. Refreshed when m_compressionParameters changed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_compressionParameters">
            <summary>
            Current compression parameters corresponding with compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.JpegImage.m_decompressedData">
            <summary>
            Bytes of decompressed image (bitmap)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.#ctor(System.IO.Stream)">
            <summary>
            Creates <see cref="T:BitMiracle.LibJpeg.JpegImage"/> from stream with an arbitrary image data
            </summary>
            <param name="imageData">Stream containing bytes of image in 
            arbitrary format (BMP, Jpeg, GIF, PNG, TIFF, e.t.c)</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.#ctor(BitMiracle.LibJpeg.SampleRow[],BitMiracle.LibJpeg.Colorspace)">
            <summary>
            Creates <see cref="T:BitMiracle.LibJpeg.JpegImage"/> from pixels
            </summary>
            <param name="sampleData">Description of pixels.</param>
            <param name="colorspace">Colorspace of image.</param>
            <seealso cref="T:BitMiracle.LibJpeg.SampleRow"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.Dispose">
            <summary>
            Frees and releases all resources allocated by this <see cref="T:BitMiracle.LibJpeg.JpegImage"/>
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Width">
            <summary>
            Gets the width of image in <see cref="T:BitMiracle.LibJpeg.Sample">samples</see>.
            </summary>
            <value>The width of image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Height">
            <summary>
            Gets the height of image in <see cref="T:BitMiracle.LibJpeg.Sample">samples</see>.
            </summary>
            <value>The height of image.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.ComponentsPerSample">
            <summary>
            Gets the number of color components per <see cref="T:BitMiracle.LibJpeg.Sample">sample</see>.
            </summary>
            <value>The number of color components per sample.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.BitsPerComponent">
            <summary>
            Gets the number of bits per color component of <see cref="T:BitMiracle.LibJpeg.Sample">sample</see>.
            </summary>
            <value>The number of bits per color component.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.JpegImage.Colorspace">
            <summary>
            Gets the colorspace of image.
            </summary>
            <value>The colorspace of image.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.GetRow(System.Int32)">
            <summary>
            Retrieves the required row of image.
            </summary>
            <param name="rowNumber">The number of row.</param>
            <returns>Image row of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream)">
            <summary>
            Writes compressed JPEG image to stream.
            </summary>
            <param name="output">Output stream.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteJpeg(System.IO.Stream,BitMiracle.LibJpeg.CompressionParameters)">
            <summary>
            Compresses image to JPEG with given parameters and writes it to stream.
            </summary>
            <param name="output">Output stream.</param>
            <param name="parameters">The parameters of compression.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.WriteBitmap(System.IO.Stream)">
            <summary>
            Writes decompressed image data as bitmap to stream.
            </summary>
            <param name="output">Output stream.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.addSampleRow(BitMiracle.LibJpeg.SampleRow)">
            <summary>
            Needs for DecompressorToJpegImage class
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.JpegImage.isCompressed(System.IO.Stream)">
            <summary>
            Checks if imageData contains jpeg image
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.LoadedImageAttributes">
            <summary>
            Holds parameters of image for decompression (IDecomressDesination)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_colorspace">
            <summary>
            The m_colorspace.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_quantizeColors">
            <summary>
            The m_quantize colors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_width">
            <summary>
            The m_width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_height">
            <summary>
            The m_height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_componentsPerSample">
            <summary>
            The m_components per sample.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_components">
            <summary>
            The m_components.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_actualNumberOfColors">
            <summary>
            The m_actual number of colors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_colormap">
            <summary>
            The m_colormap.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_densityUnit">
            <summary>
            The m_density unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_densityX">
            <summary>
            The m_density x.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.LoadedImageAttributes.m_densityY">
            <summary>
            The m_density y.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.Colorspace">
            <summary>
            Gets the colorspace.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.QuantizeColors">
            <summary>
            Gets a value indicating whether quantize colors.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.Width">
            <summary>
            Gets the width.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.Height">
            <summary>
            Gets the height.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.ComponentsPerSample">
            <summary>
            Gets the components per sample.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.Components">
            <summary>
            Gets the components.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.ActualNumberOfColors">
            <summary>
            Gets the actual number of colors.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.Colormap">
            <summary>
            Gets the colormap.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.DensityUnit">
            <summary>
            Gets the density unit.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.DensityX">
            <summary>
            Gets the density x.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.LoadedImageAttributes.DensityY">
            <summary>
            Gets the density y.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Sample">
            <summary>
            Represents a "sample" (you can understand it as a "pixel") of image.
            </summary>
            <remarks>It's impossible to create an instance of this class directly, 
            but you can use existing samples through <see cref="T:BitMiracle.LibJpeg.SampleRow"/> collection. 
            Usual scenario is to get row of samples from the <see cref="M:BitMiracle.LibJpeg.JpegImage.GetRow(System.Int32)"/> method.
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.BitsPerComponent">
            <summary>
            Gets the number of bits per color component.
            </summary>
            <value>The number of bits per color component.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.ComponentCount">
            <summary>
            Gets the number of color components.
            </summary>
            <value>The number of color components.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Sample.Item(System.Int32)">
            <summary>
            Gets the color component at the specified index.
            </summary>
            <param name="componentNumber">The number of color component.</param>
            <returns>Value of color component.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Sample.GetComponent(System.Int32)">
            <summary>
            Gets the required color component.
            </summary>
            <param name="componentNumber">The number of color component.</param>
            <returns>Value of color component.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.SampleRow">
            <summary>
            Represents a row of image - collection of samples.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Byte[],System.Int32,System.Byte,System.Byte)">
            <summary>
            Creates a row from raw samples data.
            </summary>
            <param name="row">Raw description of samples.<br/>
            You can pass collection with more than sampleCount samples - only sampleCount samples 
            will be parsed and all remaining bytes will be ignored.</param>
            <param name="sampleCount">The number of samples in row.</param>
            <param name="bitsPerComponent">The number of bits per component.</param>
            <param name="componentsPerSample">The number of components per sample.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Int16[],System.Byte,System.Byte)">
            <summary>
            Creates row from an array of components.
            </summary>
            <param name="sampleComponents">Array of color components.</param>
            <param name="bitsPerComponent">The number of bits per component.</param>
            <param name="componentsPerSample">The number of components per sample.</param>
            <remarks>The difference between this constructor and 
            <see cref="M:BitMiracle.LibJpeg.SampleRow.#ctor(System.Byte[],System.Int32,System.Byte,System.Byte)">another one</see> -
            this constructor accept an array of prepared color components whereas
            another constructor accept raw bytes and parse them.
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.SampleRow.Length">
            <summary>
            Gets the number of samples in this row.
            </summary>
            <value>The number of samples.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.SampleRow.Item(System.Int32)">
            <summary>
            Gets the sample at the specified index.
            </summary>
            <param name="sampleNumber">The number of sample.</param>
            <returns>The required sample.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.GetAt(System.Int32)">
            <summary>
            Gets the sample at the specified index.
            </summary>
            <param name="sampleNumber">The number of sample.</param>
            <returns>The required sample.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.SampleRow.ToBytes">
            <summary>
            Serializes this row to raw bytes.
            </summary>
            <returns>The row representation as array of bytes</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.DensityUnit">
            <summary>
            The unit of density.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">
            <summary>
            Unknown density
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsInch">
            <summary>
            Dots/inch
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsCm">
            <summary>
            Dots/cm
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JBLOCK">
            <summary>
            One block of coefficients.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JBLOCK.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index of required element.</param>
            <value>The required element.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JHUFF_TBL">
            <summary>
            Huffman coding table.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JHUFF_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output 
            of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression. It's initialized
            <c>false</c> when the table is created, and set <c>true</c> when it's been
            output to the file. You could suppress output of a table by setting this to
            <c>true</c>. (See jpeg_suppress_tables for an example.)</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JpegConstants">
            <summary>
            Defines some JPEG constants.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE">
            <summary>
            The basic DCT block is 8x8 samples
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE2">
            <summary>
            DCTSIZE squared; the number of elements in a block. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_QUANT_TBLS">
            <summary>
            Quantization tables are numbered 0..3 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_HUFF_TBLS">
            <summary>
            Huffman tables are numbered 0..3
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPS_IN_SCAN">
            <summary>
            JPEG limit on the number of components in one scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.C_MAX_BLOCKS_IN_MCU">
            <summary>
            Compressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.D_MAX_BLOCKS_IN_MCU">
            <summary>
            Decompressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_SAMP_FACTOR">
            <summary>
            JPEG limit on sampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPONENTS">
            <summary>
            Maximum number of color channels allowed in JPEG image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.BITS_IN_JSAMPLE">
            <summary>
            The size of sample.
            </summary>
            <remarks>Are either:
            8 - for 8-bit sample values (the usual setting)<br/>
            12 - for 12-bit sample values (not supported by this version)<br/>
            Only 8 and 12 are legal data precisions for lossy JPEG according to the JPEG standard.
            Althought original IJG code claims it supports 12 bit images, our code does not support 
            anything except 8-bit images.</remarks>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_DEFAULT">
            <summary>
            DCT method used by default.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_FASTEST">
            <summary>
            Fastest DCT method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JPEG_MAX_DIMENSION">
            <summary>
            A tad under 64K to prevent overflows. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAXJSAMPLE">
            <summary>
            The maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.CENTERJSAMPLE">
            <summary>
            The medium sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_RED">
            <summary>
            Offset of Red in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_GREEN">
            <summary>
            Offset of Green in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_BLUE">
            <summary>
            Offset of Blue in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_PIXELSIZE">
            <summary>
            Bytes per RGB scanline element.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.HUFF_LOOKAHEAD">
            <summary>
            The number of bits of lookahead.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct">
            <summary>Base class for both JPEG compressor and decompresor.</summary>
            <remarks>
            Routines that are to be used by both halves of the library are declared
            to receive an instance of this class. There are no actual instances of 
            <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct"/>, only of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> 
            and <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor">
            <summary>
            Base constructor.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Base constructor.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.IsDecompressor">
            <summary>
            Gets a value indicating whether this instance is Jpeg decompressor.
            </summary>
            <value>
            	<c>true</c> if this is Jpeg decompressor; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Progress">
            <summary>
            Progress monitor.
            </summary>
            <value>The progress manager.</value>
            <remarks>Default value: <c>null</c>.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Err">
            <summary>
            Error handler module.
            </summary>
            <value>The error manager.</value>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Version">
            <summary>
            Gets the version of LibJpeg.
            </summary>
            <value>The version of LibJpeg.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Copyright">
            <summary>
            Gets the LibJpeg's copyright.
            </summary>
            <value>The copyright.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of samples.
            </summary>
            <param name="samplesPerRow">The number of samples in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of blocks.
            </summary>
            <param name="blocksPerRow">The number of blocks in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of blocks.</returns>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JBLOCK"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.AllocJpegSamples(System.Int32,System.Int32)">
            <summary>
            Creates 2-D sample array.
            </summary>
            <param name="samplesPerRow">The number of samples per row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">
            <summary>
            Abort processing of a JPEG compression or decompression operation,
            but don't destroy the object itself.
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_destroy">
            <summary>
            Destruction of a JPEG object. 
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(System.Int32,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(System.Int32,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,System.Int32,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_component_info">
            <summary>
            Basic info about one component (color channel).
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_id">
            <summary>
            Identifier for this component (0..255)
            </summary>
            <value>The component ID.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_index">
            <summary>
            Its index in SOF or <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info"/>.
            </summary>
            <value>The component index.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.H_samp_factor">
            <summary>
            Horizontal sampling factor (1..4)
            </summary>
            <value>The horizontal sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.V_samp_factor">
            <summary>
            Vertical sampling factor (1..4)
            </summary>
            <value>The vertical sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Quant_tbl_no">
            <summary>
            Quantization table selector (0..3)
            </summary>
            <value>The quantization table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Dc_tbl_no">
            <summary>
            DC entropy table selector (0..3)
            </summary>
            <value>The DC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Ac_tbl_no">
            <summary>
            AC entropy table selector (0..3)
            </summary>
            <value>The AC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Width_in_blocks">
            <summary>
            Gets or sets the width in blocks.
            </summary>
            <value>The width in blocks.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Downsampled_width">
            <summary>
            Gets the downsampled width.
            </summary>
            <value>The downsampled width.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct">
            <summary>
            JPEG compression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.IsDecompressor">
            <summary>
            Retrieves <c>false</c> because this is not decompressor.
            </summary>
            <value><c>false</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dest">
            <summary>
            Gets or sets the destination for compressed data
            </summary>
            <value>The destination for compressed data.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_width">
            <summary>
            Gets or sets the width of image, in pixels.
            </summary>
            <value>The width of image.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_height">
            <summary>
            Gets or sets the height of image, in pixels.
            </summary>
            <value>The height of image.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Input_components">
            <summary>
            Gets or sets the number of color channels (components per pixel)
            </summary>
            <value>The number of color channels.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space">
            <summary>
            Gets or sets the color space of source image.
            </summary>
            <value>The color space.</value>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Data_precision">
            <summary>
            Gets or sets the number of bits of precision in image data.
            </summary>
            <remarks>Default value: 8<br/>
            The number of bits.
            </remarks>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Num_components">
            <summary>
            Gets or sets the number of color components for JPEG color space.
            </summary>
            <value>The number of color components for JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the JPEG color space.
            </summary>
            <remarks>We recommend to use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> if you want to change this.</remarks>
            <value>The JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Raw_data_in">
            <summary>
            Gets or sets a value indicating whether you will be supplying raw data.
            </summary>
            <remarks>Default value: <c>false</c></remarks>
            <value><c>true</c> if you will be supplying raw data; otherwise, <c>false</c>.</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Optimize_coding">
            <summary>
            Gets or sets a value indicating a way of using Huffman coding tables.
            </summary>
            <remarks>When this is <c>true</c>, you need not supply Huffman tables at all, and any you do supply will be overwritten.</remarks>
            <value><c>true</c> causes the compressor to compute optimal Huffman coding tables 
            for the image. This requires an extra pass over the data and therefore costs a good 
            deal of space and time. The default is <c>false</c>, which tells the compressor to use the 
            supplied or default Huffman tables. In most cases optimal tables save only a few 
            percent of file size compared to the default tables.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.CCIR601_sampling">
            <summary>
            Gets or sets a value indicating whether first samples are cosited.
            </summary>
            <value><c>true</c> if first samples are cosited; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Smoothing_factor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br/>
            If non-zero, the input image is smoothed; the value should be 1 for minimal smoothing 
            to 100 for maximum smoothing.</remarks>
            <value>The coefficient of image smoothing.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The DCT algorithm.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval">
            <summary>
            Gets or sets the exact interval in MCU blocks.
            </summary>
            <remarks>Default value: 0<br/>
            One restart marker per MCU row is often a good choice. The overhead of restart markers 
            is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. 
            If you use restarts, you may want to use larger intervals in those cases.</remarks>
            <value>The restart interval.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows"/>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows">
            <summary>
            Gets or sets the interval in MCU rows.
            </summary>
            <remarks>Default value: 0<br/>
            If Restart_in_rows is not 0, then <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/> is set 
            after the image width in MCUs is computed.<br/>
            One restart marker per MCU row is often a good choice. 
            The overhead of restart markers is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. If you use restarts, you may want to use larger intervals in those cases.
            </remarks>
            <value>The restart interval in MCU rows.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header">
            <summary>
            Gets or sets a value indicating whether the JFIF APP0 marker is emitted.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> set this <c>true</c> 
            if a JFIF-legal JPEG color space (i.e., YCbCr or grayscale) is selected, otherwise <c>false</c>.</remarks>
            <value><c>true</c> if JFIF APP0 marker is emitted; otherwise, <c>false</c>.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit">
            <summary>
            Gets or sets the resolution information to be written into the JFIF marker; not used otherwise.
            </summary>
            <remarks>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown"/><br/>
            The pixel aspect ratio is defined by 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/> 
            even when Density_unit is <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">Unknown</see>.</remarks>
            <value>The density unit.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density">
            <summary>
            Gets or sets the horizontal component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The horizontal density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density">
            <summary>
            Gets or sets the vertical component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The vertical density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker">
            <summary>
            Gets or sets a value indicating whether to emit Adobe APP14 marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> 
            set this <c>true</c> if JPEG color space RGB, CMYK, or YCCK is selected, otherwise <c>false</c>. 
            It is generally a bad idea to set both <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/> and 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker"/>. 
            In fact, you probably shouldn't change the default settings at all - the default behavior ensures that the JPEG file's 
            color space can be recognized by the decoder.</remarks>
            <value>If <c>true</c> an Adobe APP14 marker is emitted; <c>false</c>, otherwise.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Component_info">
            <summary>
            Gets the components that appears in SOF.
            </summary>
            <value>The component info array.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Quant_tbl_ptrs">
            <summary>
            Gets the coefficient quantization tables.
            </summary>
            <value>The coefficient quantization tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dc_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Ac_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Next_scanline">
            <summary>
            Gets the index of next scanline to be written to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>.
            </summary>
            <remarks>Application may use this to control its processing loop, 
            e.g., "while (Next_scanline &lt; Image_height)"</remarks>
            <value>Range: from 0 to (Image_height - 1)</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_abort_compress">
            <summary>
            Abort processing of a JPEG compression operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">
            <summary>
            Forcibly suppress or un-suppress all quantization and Huffman tables.
            </summary>
            <remarks>Marks all currently defined tables as already written (if suppress)
            or not written (if !suppress). This will control whether they get 
            emitted by a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> call.<br/>
            
            This routine is exported for use by applications that want to produce
            abbreviated JPEG datastreams.</remarks>
            <param name="suppress">if set to <c>true</c> then suppress tables; 
            otherwise unsuppress.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">
            <summary>
            Finishes JPEG compression.
            </summary>
            <remarks>If a multipass operating mode was selected, this may do a great 
            deal of work including most of the actual output.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])">
            <summary>
            Write a special marker.
            </summary>
            <remarks>This is only recommended for writing COM or APPn markers. 
            Must be called after <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> and before first call to 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> or <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>.
            </remarks>
            <param name="marker">Specify the marker type parameter as <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.COM for COM or 
            <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.APP0 + n for APPn. (Actually, jpeg_write_marker will let you write any marker type, 
            but we don't recommend writing any other kinds of marker)</param>
            <param name="data">The data associated with the marker.</param>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)">
            <summary>
            Writes special marker's header.
            </summary>
            <param name="marker">Special marker.</param>
            <param name="datalen">Length of data associated with the marker.</param>
            <remarks>After calling this method you need to call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            exactly the number of times given in the length parameter.<br/>
            This method lets you empty the output buffer partway through a marker, which might be important when 
            using a suspending data destination module. In any case, if you are using a suspending destination, 
            you should flush its buffer after inserting any special markers.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)">
            <summary>
            Writes a byte of special marker's data.
            </summary>
            <param name="val">The byte of data.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">
            <summary>
            Alternate compression function: just write an abbreviated table file.
            </summary>
            <remarks>Before calling this, all parameters and a data destination must be set up.<br/>
            
            To produce a pair of files containing abbreviated tables and abbreviated
            image data, one would proceed as follows:<br/>
            
            <c>Initialize JPEG object<br/>
            Set JPEG parameters<br/>
            Set destination to table file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">jpeg_write_tables();</see><br/>
            Set destination to image file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress(false);</see><br/>
            Write data...<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">jpeg_finish_compress();</see><br/>
            </c><br/>
            
            jpeg_write_tables has the side effect of marking all tables written
            (same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">jpeg_suppress_tables(true)</see>).
            Thus a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress</see> 
            will not re-emit the tables unless it is passed <c>write_all_tables=true</c>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_stdio_dest(System.IO.Stream)">
            <summary>
            Sets output stream.
            </summary>
            <param name="outfile">The output stream.</param>
            <remarks>The caller must have already opened the stream, and is responsible
            for closing it after finishing compression.</remarks>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults">
            <summary>
            Jpeg_set_defaultses this instance.
            </summary>
            <remarks>Uses only the input image's color space (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>, 
            which must already be set in <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>). Many applications will only need 
            to use this routine and perhaps <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/>.
            </remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)">
            <summary>
            Set the JPEG colorspace (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space"/>,
            and choose colorspace-dependent parameters appropriately.
            </summary>
            <param name="colorspace">The required colorspace.</param>
            <remarks>See <see href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</see>, 
            below, before using this. A large number of parameters, including all per-component parameters, 
            are set by this routine; if you want to twiddle individual parameters you should call 
            <c>jpeg_set_colorspace</c> before rather than after.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_colorspace">
            <summary>
            Select an appropriate JPEG colorspace based on <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>,
            and calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/>
            </summary>
            <remarks>This is actually a subroutine of <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/>. 
            It's broken out in case you want to change just the colorspace-dependent JPEG parameters.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)">
            <summary>
            Constructs JPEG quantization tables appropriate for the indicated quality setting.
            </summary>
            <param name="quality">The quality value is expressed on the 0..100 scale recommended by IJG.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are constrained 
            to the range 1..255 for full JPEG baseline compatibility. In the current implementation, 
            this only makes a difference for quality settings below 25, and it effectively prevents 
            very small/low quality files from being generated. The IJG decoder is capable of reading 
            the non-baseline files generated at low quality settings when <c>force_baseline</c> is <c>false</c>,
            but other decoders may not be.</param>
            <remarks>Note that the exact mapping from quality values to tables may change in future IJG releases 
            as more is learned about DCT quantization.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_linear_quality(System.Int32,System.Boolean)">
            <summary>
            Same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/> except that the generated tables are the 
            sample tables given in the JPEG specification section K.1, multiplied by 
            the specified scale factor.
            </summary>
            <param name="scale_factor">The scale_factor.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are 
            constrained to the range 1..255 for full JPEG baseline compatibility. In the current 
            implementation, this only makes a difference for quality settings below 25, and it 
            effectively prevents very small/low quality files from being generated. The IJG decoder 
            is capable of reading the non-baseline files generated at low quality settings when 
            <c>force_baseline</c> is <c>false</c>, but other decoders may not be.</param>
            <remarks>Note that larger scale factors give lower quality. This entry point is 
            useful for conforming to the Adobe PostScript DCT conventions, but we do not 
            recommend linear scaling as a user-visible quality scale otherwise.
            </remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_add_quant_table(System.Int32,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Allows an arbitrary quantization table to be created.
            </summary>
            <param name="which_tbl">Indicates which table slot to fill.</param>
            <param name="basic_table">An array of 64 unsigned integers given in normal array order.
            These values are multiplied by <c>scale_factor/100</c> and then clamped to the range 1..65535 
            (or to 1..255 if <c>force_baseline</c> is <c>true</c>).<br/>
            The basic table should be given in JPEG zigzag order.
            </param>
            <param name="scale_factor">Multiplier for values in <c>basic_table</c>.</param>
            <param name="force_baseline">Defines range of values in <c>basic_table</c>. 
            If <c>true</c> - 1..255, otherwise - 1..65535.</param>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_quality_scaling(System.Int32)">
            <summary>
            Converts a value on the IJG-recommended quality scale to a linear scaling percentage.
            </summary>
            <param name="quality">The IJG-recommended quality scale. Should be 0 (terrible) to 100 (very good).</param>
            <returns>The linear scaling percentage.</returns>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_simple_progression">
            <summary>
            Generates a default scan script for writing a progressive-JPEG file.
            </summary>
            <remarks>This is the recommended method of creating a progressive file, unless you want 
            to make a custom scan sequence. You must ensure that the JPEG color space is 
            set correctly before calling this routine.</remarks>
            <seealso href="ce3f6712-3633-4a58-af07-626a4fba9ae4.htm" target="_self">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">
            <summary>
            Starts JPEG compression.
            </summary>
            <param name="write_all_tables">Write or not write all quantization and Huffman tables.</param>
            <remarks>Before calling this, all parameters and a data destination must be set up.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables"/>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Write some scanlines of data to the JPEG compressor.
            </summary>
            <param name="scanlines">The array of scanlines.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The return value will be the number of lines actually written.<br/>
            This should be less than the supplied <c>num_lines</c> only in case that 
            the data destination module has requested suspension of the compressor, 
            or if more than image_height scanlines are passed in.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_write_scanlines()</c> since this likely 
            signals an application programmer error. However, excess scanlines passed in the last 
            valid call are "silently" ignored, so that the application need not adjust <c>num_lines</c>
            for end-of-image when using a multiple-scanline buffer.</remarks>
            <seealso href="07136fd7-d482-48de-b88c-1a4b9658c69e.htm" target="_self">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to write raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The number of lines actually written.</returns>
            <remarks>Processes exactly one iMCU row per call, unless suspended.
            Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> when writing raw downsampled data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_coefficients(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Compression initialization for writing raw-coefficient data. Useful for lossless transcoding.
            </summary>
            <param name="coef_arrays">The virtual arrays need not be filled or even realized at the time 
            <c>jpeg_write_coefficients</c> is called; indeed, the virtual arrays typically will be realized 
            during this routine and filled afterwards.
            </param>
            <remarks>Before calling this, all parameters and a data destination must be set up.
            Call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress"/> to actually write the data.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initialize">
            <summary>
            Initialization of a JPEG compression object
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_compress_master">
            <summary>
            Master selection of compression modules.
            This is done once at the start of processing an image.  We determine
            which modules will be used and give them appropriate initialization calls.
            This routine is in charge of selecting the modules to be executed and
            making an initialization call to each one.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_master_control(System.Boolean)">
            <summary>
            Initialize master compression control.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_main_controller(System.Boolean)">
            <summary>
            Initialize main buffer controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.transencode_master_selection(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Master selection of compression modules for transcoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initial_setup">
            <summary>
            Do computations that are needed before master selection phase
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.validate_script">
            <summary>
            Verify that the scan script in scan_info[] is valid; 
            also determine whether it uses progressive JPEG, and set progressive_mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.std_huff_tables">
            <summary>
            Set up the standard Huffman tables (cf. JPEG standard section K.3)
            
            IMPORTANT: these are only valid for 8-bit data precision!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.add_huff_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL@,System.Byte[],System.Byte[])">
            <summary>
            Define a Huffman table
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_a_scan(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for specified component
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_dc_scans(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate interleaved DC scan if possible, else N scans
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_scans(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for each component
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct">
            <summary>
            JPEG decompression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method">
            <summary>
            The delegate for application-supplied marker processing methods.
            </summary>
            <param name="cinfo">Decompressor.</param>
            <returns>Return <c>true</c> to indicate success. <c>false</c> should be returned only 
            if you are using a suspending data source and it tells you to suspend.
            </returns>
            <remarks>Although the marker code is not explicitly passed, the routine can find it 
            in the <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker"/>. At the time of call, 
            the marker proper has been read from the data source module. The processor routine 
            is responsible for reading the marker length word and the remaining parameter bytes, if any.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.IsDecompressor">
            <summary>
            Retrieves <c>true</c> because this is a decompressor.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Src">
            <summary>
            Gets or sets the source for decompression.
            </summary>
            <value>The source for decompression.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_width">
            <summary>
            Gets the width of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The width of image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_height">
            <summary>
            Gets the height of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The height of image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Num_components">
            <summary>
            Gets the number of color components in JPEG image.
            </summary>
            <value>The number of color components.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the colorspace of JPEG image.
            </summary>
            <value>The colorspace of JPEG image.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">
            <summary>
            Gets the list of loaded special markers.
            </summary>
            <remarks>All the special markers in the file appear in this list, in order of 
            their occurrence in the file (but omitting any markers of types you didn't ask for)
            </remarks>
            <value>The list of loaded special markers.</value>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space">
            <summary>
            Gets or sets the output color space.
            </summary>
            <value>The output color space.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">
            <summary>
            Gets or sets the numerator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction Scale_num/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">Scale_denom</see>. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">
            <summary>
            Gets or sets the denominator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">Scale_num</see>/Scale_denom. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Buffered_image">
            <summary>
            Gets or sets a value indicating whether to use buffered-image mode.
            </summary>
            <value><c>true</c> if buffered-image mode is turned on; otherwise, <c>false</c>.</value>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Raw_data_out">
            <summary>
            Enable or disable raw data output.
            </summary>
            <value><c>true</c> if raw data output is enabled; otherwise, <c>false</c>.</value>
            <remarks>Default value: <c>false</c><br/>
            Set this to true before <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/> 
            if you need to obtain raw data output.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The algorithm used for the DCT step.</value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_fancy_upsampling">
            <summary>
            Enable or disable upsampling of chroma components.
            </summary>
            <value>If <c>true</c>, do careful upsampling of chroma components. 
            If <c>false</c>, a faster but sloppier method is used. 
            The visual impact of the sloppier method is often very small.
            </value>
            <remarks>Default value: <c>true</c></remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_block_smoothing">
            <summary>
            Apply interblock smoothing in early stages of decoding progressive JPEG files.
            </summary>
            <value>If <c>true</c>, interblock smoothing is applied in early stages of decoding progressive JPEG files; 
            if <c>false</c>, not. Early progression stages look "fuzzy" with smoothing, "blocky" without.</value>
            <remarks>Default value: <c>true</c><br/>
            In any case, block smoothing ceases to be applied after the first few AC coefficients are 
            known to full accuracy, so it is relevant only when using 
            <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> for progressive images.
            </remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">
            <summary>
            Colors quantization.
            </summary>
            <value>If set <c>true</c>, colormapped output will be delivered.<br/>
            Default value: <c>false</c>, meaning that full-color output will be delivered.
            </value>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode">
            <summary>
            Selects color dithering method.
            </summary>
            <value>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS"/>.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            At present, ordered dither is implemented only in the single-pass, standard-colormap case. 
            If you ask for ordered dither when <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize"/> is <c>true</c>
            or when you supply an external color map, you'll get F-S dithering.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize">
            <summary>
            Gets or sets a value indicating whether to use two-pass color quantization.
            </summary>
            <value>If <c>true</c>, an extra pass over the image is made to select a custom color map for the image.
            This usually looks a lot better than the one-size-fits-all colormap that is used otherwise.
            Ignored when the application supplies its own color map.<br/>
            
            Default value: <c>true</c>
            </value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Desired_number_of_colors">
            <summary>
            Maximum number of colors to use in generating a library-supplied color map.
            </summary>
            <value>Default value: 256.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            The actual number of colors is returned in a <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_1pass_quant">
            <summary>
            Enable future use of 1-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_external_quant">
            <summary>
            Enable future use of external colormap.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_2pass_quant">
            <summary>
            Enable future use of 2-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width">
            <summary>
            Gets the actual width of output image.
            </summary>
            <value>The width of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height">
            <summary>
            Gets the actual height of output image.
            </summary>
            <value>The height of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components">
            <summary>
            Gets the number of color components in <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>The number of color components.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_components">
            <summary>
            Gets the number of color components returned.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>When <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">quantizing colors</see>, 
            <c>Output_components</c> is 1, indicating a single color map index per pixel. 
            Otherwise it equals to <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/>.
            </value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Rec_outbuf_height">
            <summary>
            Gets the recommended height of scanline buffer.
            </summary>
            <value>In high-quality modes, <c>Rec_outbuf_height</c> is always 1, but some faster, 
            lower-quality modes set it to larger values (typically 2 to 4).</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.<br/>
            
            <c>Rec_outbuf_height</c> is the recommended minimum height (in scanlines) 
            of the buffer passed to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)"/>.
            If the buffer is smaller, the library will still work, but time will be wasted due 
            to unnecessary data copying. If you are going to ask for a high-speed processing mode, 
            you may as well go to the trouble of honoring <c>Rec_outbuf_height</c> so as to avoid data copying.
            (An output buffer larger than <c>Rec_outbuf_height</c> lines is OK, but won't provide 
            any material speed improvement over that height.)
            </remarks>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors">
            <summary>
            The number of colors in the color map.
            </summary>
            <value>The number of colors in the color map.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap">
            <summary>
            The color map, represented as a 2-D pixel array of <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/> rows 
            and <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> columns.
            </summary>
            <value>Colormap is set to <c>null</c> by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>.
            The application can supply a color map by setting <c>Colormap</c> non-null and setting 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> to the map size.
            </value>
            <remarks>Ignored if not quantizing.<br/>
            Implementation restriction: at present, an externally supplied <c>Colormap</c>
            is only accepted for 3-component output color spaces.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scanline">
            <summary>
            Gets the number of scanlines returned so far.
            </summary>
            <value>The output_scanline.</value>
            <remarks>Usually you can just use this variable as the loop counter, 
            so that the loop test looks like 
            <c>while (cinfo.Output_scanline &lt; cinfo.Output_height)</c></remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_scan_number">
            <summary>
            Gets the number of SOS markers seen so far.
            </summary>
            <value>The number of SOS markers seen so far.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_iMCU_row">
            <summary>
            Gets the number of iMCU rows completed.
            </summary>
            <value>The number of iMCU rows completed.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scan_number">
            <summary>
            Gets the nominal scan number being displayed.
            </summary>
            <value>The nominal scan number being displayed.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_iMCU_row">
            <summary>
            Gets the number of iMCU rows read.
            </summary>
            <value>The number of iMCU rows read.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Coef_bits">
            <summary>
            Gets the current progression status..
            </summary>
            <value><c>Coef_bits[c][i]</c> indicates the precision with 
            which component c's DCT coefficient i (in zigzag order) is known. 
            It is <c>-1</c> when no data has yet been received, otherwise 
            it is the point transform (shift) value for the most recent scan of the coefficient 
            (thus, 0 at completion of the progression). This is null when reading a non-progressive file.
            </value>
            <seealso href="bda5b19b-88e0-44bf-97de-cd30fc61bb65.htm" target="_self">Progressive JPEG support</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit">
            <summary>
            Gets the resolution information from JFIF marker.
            </summary>
            <value>The information from JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density">
            <summary>
            Gets the horizontal component of pixel ratio.
            </summary>
            <value>The horizontal component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density">
            <summary>
            Gets the vertical component of pixel ratio.
            </summary>
            <value>The vertical component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Data_precision">
            <summary>
            Gets the data precision.
            </summary>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker">
            <summary>
            Gets the last read and unprocessed JPEG marker.
            </summary>
            <value>It is either zero or the code of a JPEG marker that has been
            read from the data source, but has not yet been processed.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info">
            <summary>
            Comp_info[i] describes component that appears i'th in SOF
            </summary>
            <value>The components in SOF.</value>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_component_info"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_stdio_src(System.IO.Stream)">
            <summary>
            Sets input stream.
            </summary>
            <param name="infile">The input stream.</param>
            <remarks>
            The caller must have already opened the stream, and is responsible
            for closing it after finishing decompression.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">
            <summary>
            Decompression startup: this will read the source datastream header markers, up to the beginning of the compressed data proper.
            </summary>
            <param name="require_image">Read a description of <b>Return Value</b>.</param>
            <returns>
            If you pass <c>require_image=true</c> (normal case), you need not check for a
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> return code; an abbreviated file will cause
            an error exit. <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> is only possible if you use a data source
            module that can give a suspension return.<br/><br/>
            
            This method will read as far as the first SOS marker (ie, actual start of compressed data),
            and will save all tables and parameters in the JPEG object. It will also initialize the
            decompression parameters to default values, and finally return <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/>.
            On return, the application may adjust the decompression parameters and then call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>. (Or, if the application only wanted to
            determine the image parameters, the data need not be decompressed. In that case, call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/> to release any temporary space.)<br/><br/>
            
            If an abbreviated (tables only) datastream is presented, the routine will return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> upon reaching EOI. The application may then re-use
            the JPEG object to read the abbreviated image datastream(s). It is unnecessary (but OK) to call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">jpeg_abort</see> in this case.
            The <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> return code only occurs if the data source module
            requests suspension of the decompressor. In this case the application should load more source
            data and then re-call <c>jpeg_read_header</c> to resume processing.<br/><br/>
            
            If a non-suspending data source is used and <c>require_image</c> is <c>true</c>,
            then the return code need not be inspected since only <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/> is possible.
            </returns>
            <remarks>Need only initialize JPEG object and supply a data source before calling.<br/>
            On return, the image dimensions and other info have been stored in the JPEG object.
            The application may wish to consult this information before selecting decompression parameters.<br/>
            This routine is now just a front end to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>, with some extra error checking.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
            <seealso href="0955150c-4ee7-4b0f-a716-4bda2e85652b.htm" target="_self">Decompression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress">
            <summary>
            Decompression initialization.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            If a multipass operating mode was selected, this will do all but the last pass, and thus may take a great deal of time.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress"/>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Read some scanlines of data from the JPEG decompressor.
            </summary>
            <param name="scanlines">Buffer for filling.</param>
            <param name="max_lines">Required number of lines.</param>
            <returns>The return value will be the number of lines actually read. 
            This may be less than the number requested in several cases, including 
            bottom of image, data source suspension, and operating modes that emit multiple scanlines at a time.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_read_scanlines</c> since this likely signals an 
            application programmer error. However, an oversize buffer <c>(max_lines > scanlines remaining)</c> 
            is not an error.
            </remarks>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">
            <summary>
            Finish JPEG decompression.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>This will normally just verify the file trailer and release temp storage.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>
            <seealso href="9d052723-a7f9-42de-8747-0bd9896f8157.htm" target="_self">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to read raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="max_lines">The number of scanlines for reading.</param>
            <returns>The number of lines actually read.</returns>
            <remarks>Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">jpeg_read_scanlines</see> 
            when reading raw downsampled data. Processes exactly one iMCU row per call, unless suspended.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_has_multiple_scans">
            <summary>
            Is there more than one scan?
            </summary>
            <returns><c>true</c> if image has more than one scan; otherwise, <c>false</c></returns>
            <remarks>If you are concerned about maximum performance on baseline JPEG files,
            you should use <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> only
            when the incoming file actually has multiple scans. This can be tested by calling this method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)">
            <summary>
            Initialize for an output pass in <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see>.
            </summary>
            <param name="scan_number">Indicates which scan of the input file is to be displayed; 
            the scans are numbered starting at 1 for this purpose.</param>
            <returns><c>true</c> if done; <c>false</c> if suspended</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output"/>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">
            <summary>
            Finish up after an output pass in <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see>.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected only if a suspending data source is used.</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)"/>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_input_complete">
            <summary>
            Indicates if we have finished reading the input file.
            </summary>
            <returns><c>true</c> if we have finished reading the input file.</returns>
            <seealso href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input">
            <summary>
            Consume data in advance of what the decompressor requires.
            </summary>
            <returns>The result of data consumption.</returns>
            <remarks>This routine can be called at any time after initializing the JPEG object.
            It reads some additional data and returns when one of the indicated significant events
            occurs. If called after the EOI marker is reached, it will immediately return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI"/> without attempting to read more data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions">
            <summary>
            Pre-calculate output image dimensions and related values for current decompression parameters.
            </summary>
            <remarks>This is allowed for possible use by application. Hence it mustn't do anything 
            that can't be done twice. Also note that it may be called before the master module is initialized!
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_coefficients">
            <summary>
            Read or write the raw DCT coefficient arrays from a JPEG file (useful for lossless transcoding).
            </summary>
            <returns>Returns <c>null</c> if suspended. This case need be checked only 
            if a suspending data source is used.
            </returns>
            <remarks>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            The entire image is read into a set of virtual coefficient-block arrays, one per component.
            The return value is an array of virtual-array descriptors.<br/>
            
            An alternative usage is to simply obtain access to the coefficient arrays during a 
            <see href="6dba59c5-d32e-4dfc-87fe-f9eff7004146.htm" target="_self">buffered-image mode</see> decompression operation. This is allowed after any 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">jpeg_finish_output</see> call. The arrays can be accessed 
            until <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">jpeg_finish_decompress</see> is called. 
            Note that any call to the library may reposition the arrays, 
            so don't rely on <see cref="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)"/> results to stay valid across library calls.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_copy_critical_parameters(BitMiracle.LibJpeg.Classic.jpeg_compress_struct)">
            <summary>
            Initializes the compression object with default parameters, then copy from the source object 
            all parameters needed for lossless transcoding.
            </summary>
            <param name="dstinfo">Target JPEG compression object.</param>
            <remarks>Parameters that can be varied without loss (such as scan script and 
            Huffman optimization) are left in their default states.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_abort_decompress">
            <summary>
            Aborts processing of a JPEG decompression operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Sets processor for special marker.
            </summary>
            <param name="marker_code">The marker code.</param>
            <param name="routine">The processor.</param>
            <remarks>Allows you to supply your own routine to process 
            COM and/or APPn markers on-the-fly as they are read.
            </remarks>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_save_markers(System.Int32,System.Int32)">
            <summary>
            Control saving of COM and APPn markers into <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see>.
            </summary>
            <param name="marker_code">The marker type to save (see JPEG_MARKER enumeration).<br/>
            To arrange to save all the special marker types, you need to call this 
            routine 17 times, for COM and APP0-APP15 markers.</param>
            <param name="length_limit">If the incoming marker is longer than <c>length_limit</c> data bytes, 
            only <c>length_limit</c> bytes will be saved; this parameter allows you to avoid chewing up memory 
            when you only need to see the first few bytes of a potentially large marker. If you want to save 
            all the data, set <c>length_limit</c> to 0xFFFF; that is enough since marker lengths are only 16 bits. 
            As a special case, setting <c>length_limit</c> to 0 prevents that marker type from being saved at all. 
            (That is the default behavior, in fact.)
            </param>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.use_merged_upsample">
            <summary>
            Determine whether merged upsample/color conversion should be used.
            CRUCIAL: this must match the actual capabilities of merged upsampler!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.initialize">
            <summary>
            Initialization of JPEG compression objects.
            The error manager must already be set up (in case memory manager fails).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.transdecode_master_selection">
            <summary>
            Master selection of decompression modules for transcoding (that is, reading 
            raw DCT coefficient arrays from an input JPEG file.)
            This substitutes for initialization of the full decompressor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.output_pass_setup">
            <summary>
            Set up for an output pass, and perform any dummy pass(es) needed.
            Common subroutine for jpeg_start_decompress and jpeg_start_output.
            Entry: global_state = DSTATE_PRESCAN only if previously suspended.
            Exit: If done, returns true and sets global_state for proper output mode.
                  If suspended, returns false and sets global_state = DSTATE_PRESCAN.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.default_decompress_parms">
            <summary>
            Set default decompression parameters.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr">
            <summary>
            Data destination object for compression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.init_destination">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.empty_output_buffer">
            <summary>
            Empties output buffer.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.term_destination">
            <summary>
            Term_destinations this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.emit_byte(System.Int32)">
            <summary>
            Emits a byte.
            </summary>
            <param name="val">The byte value.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.freeInBuffer">
            <summary>
            Gets the number of free bytes in buffer.
            </summary>
            <value>The number of free bytes in buffer.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr">
            <summary>
            Contains simple error-reporting and trace-message routines.
            </summary>
            <remarks>This class is used by both the compression and decompression code.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Trace_level">
            <summary>
            Gets or sets the maximum message level that will be displayed.
            </summary>
            <value>Values are:
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Num_warnings">
            <summary>
            Gets the number of corrupt-data warnings.
            </summary>
            <value>The num_warnings.</value>
            <remarks>For recoverable corrupt-data errors, we emit a warning message, but keep going 
            unless <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">emit_message</see> chooses to abort. 
            <c>emit_message</c> should count warnings in <c>Num_warnings</c>. The surrounding application 
            can check for bad data by seeing if <c>Num_warnings</c> is nonzero at the end of processing.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.error_exit">
            <summary>
            Receives control for a fatal error.
            </summary>
            <remarks>This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> 
            and then throws an exception.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">
            <summary>
            Conditionally emit a trace or warning message.
            </summary>
            <param name="msg_level">The message severity level.<br/>
            Values are:<br/>
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </param>
            <remarks>The main reason for overriding this method would be to abort on warnings.
            This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> for message showing.<br/>
            
            An application might override this method if it wanted to abort on 
            warnings or change the policy about which messages to display.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">
            <summary>
            Actual output of any JPEG message.
            </summary>
            <remarks>Override this to send messages somewhere other than Console. 
            Note that this method does not know how to generate a message, only where to send it.
            For extending a generation of messages see <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">format_message</see>.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">
            <summary>
            Constructs a readable error message string.
            </summary>
            <remarks>This method is called by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see>.
            Few applications should need to override this method. One possible reason for doing so is to 
            implement dynamic switching of error message language.</remarks>
            <returns>The formatted message</returns>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.reset_error_mgr">
            <summary>
            Resets error manager to initial state.
            </summary>
            <remarks>This is called during compression startup to reset trace/error
            processing to default state. An application might possibly want to
            override this method if it has additional error processing state.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.GetMessageText(System.Int32)">
            <summary>
            Gets the actual message texts.
            </summary>
            <param name="code">The message code. See <see cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/> for details.</param>
            <returns>The message text associated with <c>code</c>.</returns>
            <remarks>It may be useful for an application to add its own message texts that are handled 
            by the same mechanism. You can override <c>GetMessageText</c> for this purpose. If you number 
            the addon messages beginning at 1000 or so, you won't have to worry about conflicts 
            with the library's built-in messages.
            </remarks>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER">
            <summary>
            JPEG marker codes.
            </summary>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DAC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DNL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EXP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP8">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP12">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.COM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.TEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.ERROR">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_marker_struct">
            <summary>
            Representation of special JPEG marker.
            </summary>
            <remarks>You can't create instance of this class manually.
            Concrete objects are instantiated by library and you can get them
            through <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see> property.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Marker">
            <summary>
            Gets the special marker.
            </summary>
            <value>The marker value.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.OriginalLength">
            <summary>
            Gets the full length of original data associated with the marker.
            </summary>
            <value>The length of original data associated with the marker.</value>
            <remarks>This length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Data">
            <summary>
            Gets the data associated with the marker.
            </summary>
            <value>The data associated with the marker.</value>
            <remarks>The length of this array doesn't exceed <c>length_limit</c> for the particular marker type.
            Note that this length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr">
            <summary>
            The progress monitor object.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">
            <summary>
            Occurs when progress is changed.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_counter">
            <summary>
            Gets or sets the number of work units completed in this pass.
            </summary>
            <value>The number of work units completed in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_limit">
            <summary>
            Gets or sets the total number of work units in this pass.
            </summary>
            <value>The total number of work units in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Completed_passes">
            <summary>
            Gets or sets the number of passes completed so far.
            </summary>
            <value>The number of passes completed so far.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Total_passes">
            <summary>
            Gets or sets the total number of passes expected.
            </summary>
            <value>The total number of passes expected.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Updated">
            <summary>
            Indicates that progress was changed.
            </summary>
            <remarks>Call this method if you change some progress parameters manually.
            This method ensures happening of the <see cref="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">OnProgress</see> event.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_source_mgr">
            <summary>
            Data source object for decompression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source 
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/></param>
            <param name="desired">The desired</param>
            <returns><c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible. 
            Some data source managers may be able to back up, or may have 
            additional knowledge about the data which permits a more 
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br/><br/>
            
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br/><br/>
            
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br/><br/>
            
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br/>
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br/>
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br/>
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br/>
            
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br/>
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br/>
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetTwoBytes(System.Int32@)">
            <summary>
            Reads two bytes interpreted as an unsigned 16-bit integer.
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetByte(System.Int32@)">
            <summary>
            Read a byte into variable V.
            If must suspend, take the specified action (typically "return false").
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetBytes(System.Byte[],System.Int32)">
            <summary>
            Gets the bytes.
            </summary>
            <param name="dest">The destination.</param>
            <param name="amount">The amount.</param>
            <returns>The number of available bytes.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.MakeByteAvailable">
            <summary>
            Functions for fetching data from the data source module.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
            <remarks>At all times, cinfo.src.next_input_byte and .bytes_in_buffer reflect
            the current restart point; we update them only when we have reached a
            suitable place to restart if a suspension occurs.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JQUANT_TBL">
            <summary>
            DCT coefficient quantization tables.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JQUANT_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jvirt_array`1">
            <summary>
            JPEG virtual array.
            </summary>
            <typeparam name="T">The type of array's elements.</typeparam>
            <remarks>You can't create virtual array manually. For creation use methods
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)"/> and
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.#ctor(System.Int32,System.Int32,BitMiracle.LibJpeg.Classic.jvirt_array{`0}.Allocator)">
            <summary>
            Request a virtual 2-D array
            </summary>
            <param name="width">Width of array</param>
            <param name="height">Total virtual array height</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jvirt_array`1.ErrorProcessor">
            <summary>
            Gets or sets the error processor.
            </summary>
            <value>The error processor.<br/>
            Default value: <c>null</c>
            </value>
            <remarks>Uses only for calling 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">jpeg_common_struct.ERREXIT</see>
            on error.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)">
            <summary>
            Access the part of a virtual array.
            </summary>
            <param name="startRow">The first row in required block.</param>
            <param name="numberOfRows">The number of required rows.</param>
            <returns>The required part of virtual array.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE">
            <summary>
            Known color spaces.
            </summary>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_UNKNOWN">
            <summary>
            Unspecified color space.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_GRAYSCALE">
            <summary>
            Grayscale
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_RGB">
            <summary>
            RGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCbCr">
            <summary>
            YCbCr (also known as YUV)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_CMYK">
            <summary>
            CMYK
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCCK">
            <summary>
            YCbCrK
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">
            <summary>
            Algorithm used for the DCT step.
            </summary>
            <remarks>The <c>FLOAT</c> method is very slightly more accurate than the <c>ISLOW</c> method, 
            but may give different results on different machines due to varying roundoff behavior. 
            The integer methods should give the same results on all machines. On machines with 
            sufficiently fast hardware, the floating-point method may also be the fastest. 
            The <c>IFAST</c> method is considerably less accurate than the other two; its use is not recommended 
            if high quality is a concern.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_ISLOW">
            <summary>
            Slow but accurate integer algorithm.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_IFAST">
            <summary>
            Faster, less accurate integer method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_FLOAT">
            <summary>
            Floating-point method.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DITHER_MODE">
            <summary>
            Dithering options for decompression.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_NONE">
            <summary>
            No dithering: fast, very low quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_ORDERED">
            <summary>
            Ordered dither: moderate speed and quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS">
            <summary>
            Floyd-Steinberg dither: slow, high quality
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE">
            <summary>
            Message codes used in code to signal errors, warning and trace messages.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_NOMESSAGE">
            <summary>
            Must be first entry!
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_ARITH_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_BUFFER_MODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCT_COEF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCTSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_MCU_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PRECISION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SAMPLING">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_STATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_VIRTUAL_ACCESS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BUFFER_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CANT_SUSPEND">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CCIR601_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_COMPONENT_COUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DHT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DQT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EMPTY_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EOI_EXPECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FILE_WRITE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EMPTY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISMATCHED_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISSING_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MODE_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOT_COMPILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_OUT_OF_MEMORY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_COMPONENTS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_NO_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_UNSUPPORTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOI_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOS_NO_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_TOO_LITTLE_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_UNKNOWN_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_WIDTH_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_16BIT_TABLES">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_ADOBE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_HUFFBITS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_EXTENSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_MISC_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_PARMLESS_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANTVALS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_SELECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RECOVERY_ACTION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RST">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SMOOTH_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_PARAMS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_JPEG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_PALETTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_RGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_UNKNOWN_IDS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ADOBE_XFORM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_BOGUS_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_EXTRANEOUS_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HIT_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JFIF_MAJOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JPEG_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_MUST_RESYNC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_NOT_SEQUENTIAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_TOO_MUCH_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_UNKNOWNMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_LASTMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.ReadResult">
            <summary>
            Describes a result of read operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED">
            <summary>
            Suspended due to lack of input data. Can occur only if a suspending data source is used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK">
            <summary>
            Found valid image datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY">
            <summary>
            Found valid table-specs-only datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_SOS">
            <summary>
            Reached a SOS marker (the start of a new scan)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI">
            <summary>
            Reached the EOI marker (end of image)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_ROW_COMPLETED">
            <summary>
            Completed reading one MCU row of compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SCAN_COMPLETED">
            <summary>
            Completed reading last MCU row of current scan.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state">
            <summary>
            Bitreading state saved across MCUs
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_working_state">
            <summary>
            Bitreading working state within an MCU
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer">
            <summary>
            Encapsulates buffer of image samples for one color component
            When provided with funny indices (see jpeg_d_main_controller for 
            explanation of what it is) uses them for non-linear row access.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl">
            <summary>
            Derived data constructed for each Huffman table
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode and return one MCU's worth of Huffman-compressed coefficients.
            The coefficients are reordered from zigzag order into natural array order,
            but are not dequantized.
            
            The i'th block of the MCU is stored into the block pointed to by
            MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
            (Wholesale zeroing is usually a little faster than retail...)
            
            Returns false if data source requested suspension.  In that case no
            changes have been made to permanent state.  (Exception: some output
            coefficients may already have been assigned.  This is harmless for
            this module, since we'll just re-assign them on the next call.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.start_pass(System.Boolean)">
            <summary>
            Initialize for a Huffman-compressed scan.
            If gather_statistics is true, we do not output anything during the scan,
            just count the Huffman symbols used and generate Huffman code tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_huff(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Encode and output one MCU's worth of Huffman-compressed coefficients.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_huff">
            <summary>
            Finish up at the end of a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_gather(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Trial-encode one MCU's worth of Huffman-compressed coefficients.
            No data is actually output, so no suspension return is possible.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_gather">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_one_block(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int16[],System.Int32,BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder.c_derived_tbl,BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder.c_derived_tbl)">
            <summary>
            Encode a single block's worth of coefficients
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.htest_one_block(System.Int16[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Huffman coding optimization.
            
            We first scan the supplied data and count the number of uses of each symbol
            that is to be Huffman-coded. (This process MUST agree with the code above.)
            Then we build a Huffman coding tree for the observed counts.
            Symbols which are not needed at all for the particular image are not
            assigned any code, which saves space in the DHT marker as well as in
            the compressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32,System.Int32)">
            <summary>
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_restart(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32)">
            <summary>
            Emit a restart marker and resynchronize predictions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jdiv_round_up(System.Int32,System.Int32)">
            <summary>
            Compute a/b rounded up to next integer, ie, ceil(a/b)
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jround_up(System.Int32,System.Int32)">
            <summary>
            Compute a rounded up to next multiple of b, ie, ceil(a/b)*b
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jcopy_sample_rows(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer,System.Int32,System.Byte[][],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy some rows of samples from one place to another.
            num_rows rows are copied from input_array[source_row++]
            to output_array[dest_row++]; these areas may overlap for duplication.
            The source and destination arrays must be at least as wide as num_cols.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.color_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            
            Note that we change from the application's interleaved-pixel format
            to our internal noninterleaved, one-plane-per-component format.
            The input buffer is therefore three times as wide as the output buffer.
            
            A starting row offset is provided only for the output buffer.  The caller
            can easily adjust the passed input_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_start">
            <summary>
            Initialize for RGB->YCC colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            RGB -&gt; YCbCr conversion: most common case
            YCbCr is defined per CCIR 601-1, except that Cb and Cr are
            normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
            The conversion equations to be implemented are therefore
            Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
            Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
            Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
            (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
            To avoid floating-point arithmetic, we represent the fractional constants
            as integers scaled up by 2^16 (about 4 digits precision); we have to divide
            the products by 2^16, with appropriate rounding, to get the correct answer.
            For even more speed, we avoid doing any multiplications in the inner loop
            by precalculating the constants times R,G,B for all possible values.
            For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
            for 12-bit samples it is still acceptable.  It's not very reasonable for
            16-bit samples, but if you want lossless storage you shouldn't be changing
            colorspace anyway.
            The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
            in the tables to save adding them separately in the inner loop.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_gray_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles RGB->grayscale conversion, which is the same
            as the RGB->Y portion of RGB->YCbCr.
            We assume rgb_ycc_start has been called (we only use the Y tables).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.cmyk_ycck_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles Adobe-style CMYK->YCCK conversion,
            where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
            conversion as above, while passing K (black) unchanged.
            We assume rgb_ycc_start has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.grayscale_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles grayscale output with no conversion.
            The source can be either plain grayscale or YCbCr (since Y == gray).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.null_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles multi-component colorspaces without conversion.
            We assume input_components == num_components.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for output colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.color_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the output colorspace.
            
            Note that we change from noninterleaved, one-plane-per-component format
            to interleaved-pixel format.  The output buffer is therefore three times
            as wide as the input buffer.
            A starting row offset is provided only for the input buffer.  The caller
            can easily adjust the passed output_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCC->RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_cmyk_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Adobe-style YCCK->CMYK conversion.
            We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
            conversion as above, while passing K (black) unchanged.
            We assume build_ycc_rgb_table has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.gray_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert grayscale to RGB: just duplicate the graylevel three times.
            This is provided to support applications that don't want to cope
            with grayscale as a separate case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.grayscale_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for grayscale: just copy the data.
            This also works for YCbCr -> grayscale conversion, in which
            we just copy the Y (luminance) component and ignore chrominance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.null_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for no colorspace change: just copy the data,
            converting from separate-planes to interleaved representation.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer">
            <summary>
            Color quantization or color precision reduction
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.prepare_for_pass">
            <summary>
            Per-pass setup.
            
            This is called at the beginning of each pass.  We determine which 
            modules will be active during this pass and give them appropriate 
            start_pass calls. 
            We also set is_last_pass to indicate whether any more passes will 
            be required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.pass_startup">
            <summary>
            Special start-of-pass hook.
            
            This is called by jpeg_write_scanlines if call_pass_startup is true.
            In single-pass processing, we need this hook because we don't want to
            write frame/scan headers during jpeg_start_compress; we want to let the
            application write COM markers etc. between jpeg_start_compress and the
            jpeg_write_scanlines loop.
            In multi-pass processing, this routine is not used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.finish_pass">
            <summary>
            Finish up at end of pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] are already set
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller">
            <summary>
            Coefficient buffer control
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller.process_data(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This routine handles the simple pass-through mode,
            where we have only a strip buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller">
            <summary>
            Compression preprocessing (downsampling input buffer control).
            
            For the simple (no-context-row) case, we just need to buffer one
            row group's worth of pixels for the downsampling step.  At the bottom of
            the image, we pad to a full row group by replicating the last pixel row.
            The downsampler's last output row is then replicated if needed to pad
            out to a full iMCU row.
            
            When providing context rows, we must buffer three row groups' worth of
            pixels.  Three row groups are physically allocated, but the row pointer
            arrays are made five row groups high, with the extra pointers above and
            below "wrapping around" to point to the last and first real row groups.
            This allows the downsampler to access the proper context rows.
            At the top and bottom of the image, we create dummy context rows by
            copying the first or last real pixel row.  This copying could be avoided
            by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
            trouble on the compression side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.create_context_buffer">
            <summary>
            Create the wrapped-around downsampling input buffer needed for context mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_WithoutContext(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the simple no-context case.
            
            Preprocessor output data is counted in "row groups".  A row group
            is defined to be v_samp_factor sample rows of each component.
            Downsampling will produce this much data from each max_v_samp_factor
            input rows.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_context(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the context case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.expand_bottom_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand an image vertically from height input_rows to height output_rows,
            by duplicating the bottom row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_for_output_pass">
            <summary>
            Per-pass setup.
            This is called at the beginning of each output pass.  We determine which
            modules will be active during this pass and give them appropriate
            start_pass calls.  We also set is_dummy_pass to indicate whether this
            is a "real" output pass or a dummy pass for color quantization.
            (In the latter case, we will crank the pass to completion.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.finish_output_pass">
            <summary>
            Finish up at end of an output pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.master_selection">
            <summary>
            Master selection of decompression modules.
            This is done once at jpeg_start_decompress time.  We determine
            which modules will be used and give them appropriate initialization calls.
            We also initialize the decompressor input side to begin consuming data.
            
            Since jpeg_read_header has finished, we know what is in the SOF
            and (first) SOS markers.  We also have all the application parameter
            settings.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_range_limit_table">
            <summary>
            Allocate and fill in the sample_range_limit table.
            
            Several decompression processes need to range-limit values to the range
            0..MAXJSAMPLE; the input value may fall somewhat outside this range
            due to noise introduced by quantization, roundoff error, etc. These
            processes are inner loops and need to be as fast as possible. On most
            machines, particularly CPUs with pipelines or instruction prefetch,
            a (subscript-check-less) C table lookup
                x = sample_range_limit[x];
            is faster than explicit tests
            <c>
                if (x &amp; 0)
                   x = 0;
                else if (x > MAXJSAMPLE)
                   x = MAXJSAMPLE;
            </c>
            These processes all use a common table prepared by the routine below.
            
            For most steps we can mathematically guarantee that the initial value
            of x is within MAXJSAMPLE + 1 of the legal range, so a table running from
            -(MAXJSAMPLE + 1) to 2 * MAXJSAMPLE + 1 is sufficient.  But for the initial
            limiting step (just after the IDCT), a wildly out-of-range value is 
            possible if the input data is corrupt.  To avoid any chance of indexing
            off the end of memory and getting a bad-pointer trap, we perform the
            post-IDCT limiting thus: <c>x = range_limit[x &amp; MASK];</c>
            where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
            samples.  Under normal circumstances this is more than enough range and
            a correct output will be generated; with bogus input data the mask will
            cause wraparound, and we will safely generate a bogus-but-in-range output.
            For the post-IDCT step, we want to convert the data from signed to unsigned
            representation by adding CENTERJSAMPLE at the same time that we limit it.
            So the post-IDCT limiting table ends up looking like this:
            <pre>
                CENTERJSAMPLE, CENTERJSAMPLE + 1, ..., MAXJSAMPLE,
                MAXJSAMPLE (repeat 2 * (MAXJSAMPLE + 1) - CENTERJSAMPLE times),
                0          (repeat 2 * (MAXJSAMPLE + 1) - CENTERJSAMPLE times),
                0, 1, ..., CENTERJSAMPLE - 1
            </pre>
            Negative inputs select values from the upper half of the table after
            masking.
            
            We can save some space by overlapping the start of the post-IDCT table
            with the simpler range limiting table.  The post-IDCT table begins at
            sample_range_limit + CENTERJSAMPLE.
            
            Note that the table is allocated in near data space on PCs; it's small
            enough and used often enough to justify this.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler">
            <summary>
            Downsampling
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.downsample(System.Byte[][][],System.Int32,System.Byte[][][],System.Int32)">
            <summary>
            Do downsampling for a whole row group (all components).
            
            In this version we simply downsample each component independently.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.int_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            One row group is processed per call.
            This version handles arbitrary integral sampling ratios, without smoothing.
            Note that this version is not actually used for customary sampling ratios.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v1_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the common case of 2:1 horizontal and 1:1 vertical,
            without smoothing.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.expand_right_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand a component horizontally from width input_cols to width output_cols,
            by duplicating the rightmost samples.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller">
            <summary>
            Coefficient buffer control
            
            This code applies interblock smoothing as described by section K.8
            of the JPEG standard: the first 5 AC coefficients are estimated from
            the DC values of a DCT block and its 8 neighboring blocks.
            We apply smoothing only for progressive JPEG decoding, and only if
            the coefficients it can estimate are not yet known to full precision.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_input_pass">
            <summary>
            Initialize for an input processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.consume_data">
            <summary>
            Consume input data and store it in the full-image coefficient buffer.
            We read as much as one fully interleaved MCU row ("iMCU" row) per call,
            ie, v_samp_factor block rows for each component in the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_output_pass">
            <summary>
            Initialize for an output processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_onepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the single-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Input and output must run in lockstep since we have only a one-MCU buffer.
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_data_ordinary(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the multi-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_smooth_data(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Variant of decompress_data for use when doing block smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.smoothing_ok">
            <summary>
            Determine whether block smoothing is applicable and safe.
            We also latch the current states of the coef_bits[] entries for the
            AC coefficients; otherwise, if the input side of the decompressor
            advances into a new scan, we might think the coefficients are known
            more accurately than they really are.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row (input side)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            
            In the current system design, the main buffer need never be a full-image
            buffer; any full-height buffers will be found inside the coefficient or
            postprocessing controllers.  Nonetheless, the main controller is not
            trivial.  Its responsibility is to provide context rows for upsampling/
            rescaling, and doing this in an efficient fashion is a bit tricky.
            
            Postprocessor input data is counted in "row groups".  A row group
            is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
            sample rows of each component.  (We require DCT_scaled_size values to be
            chosen such that these numbers are integers.  In practice DCT_scaled_size
            values will likely be powers of two, so we actually have the stronger
            condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
            Upsampling will typically produce max_v_samp_factor pixel rows from each
            row group (times any additional scale factor that the upsampler is
            applying).
            
            The coefficient controller will deliver data to us one iMCU row at a time;
            each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
            exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
            to one row of MCUs when the image is fully interleaved.)  Note that the
            number of sample rows varies across components, but the number of row
            groups does not.  Some garbage sample rows may be included in the last iMCU
            row at the bottom of the image.
            
            Depending on the vertical scaling algorithm used, the upsampler may need
            access to the sample row(s) above and below its current input row group.
            The upsampler is required to set need_context_rows true at global selection
            time if so.  When need_context_rows is false, this controller can simply
            obtain one iMCU row at a time from the coefficient controller and dole it
            out as row groups to the postprocessor.
            
            When need_context_rows is true, this controller guarantees that the buffer
            passed to postprocessing contains at least one row group's worth of samples
            above and below the row group(s) being processed.  Note that the context
            rows "above" the first passed row group appear at negative row offsets in
            the passed buffer.  At the top and bottom of the image, the required
            context rows are manufactured by duplicating the first or last real sample
            row; this avoids having special cases in the upsampling inner loops.
            
            The amount of context is fixed at one row group just because that's a
            convenient number for this controller to work with.  The existing
            upsamplers really only need one sample row of context.  An upsampler
            supporting arbitrary output rescaling might wish for more than one row
            group of context when shrinking the image; tough, we don't handle that.
            (This is justified by the assumption that downsizing will be handled mostly
            by adjusting the DCT_scaled_size values, so that the actual scale factor at
            the upsample step needn't be much less than one.)
            
            To provide the desired context, we have to retain the last two row groups
            of one iMCU row while reading in the next iMCU row.  (The last row group
            can't be processed until we have another row group for its below-context,
            and so we have to save the next-to-last group too for its above-context.)
            We could do this most simply by copying data around in our buffer, but
            that'd be very slow.  We can avoid copying any data by creating a rather
            strange pointer structure.  Here's how it works.  We allocate a workspace
            consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
            of row groups per iMCU row).  We create two sets of redundant pointers to
            the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
            pointer lists look like this:
                              M+1                          M-1
                              master pointer --> 0         master pointer --> 0
                              1                            1
                              ...                          ...
                              M-3                          M-3
                              M-2                           M
                              M-1                          M+1
                               M                           M-2
                              M+1                          M-1
                               0                            0
            We read alternate iMCU rows using each master pointer; thus the last two
            row groups of the previous iMCU row remain un-overwritten in the workspace.
            The pointer lists are set up so that the required context rows appear to
            be adjacent to the proper places when we pass the pointer lists to the
            upsampler.
            
            The above pictures describe the normal state of the pointer lists.
            At top and bottom of the image, we diddle the pointer lists to duplicate
            the first or last sample row as necessary (this is cheaper than copying
            sample rows around).
            
            This scheme breaks down if M less than 2, ie, min_DCT_scaled_size is 1.  In that
            situation each iMCU row provides only one row group so the buffering logic
            must be different (eg, we must read two iMCU rows before we can emit the
            first row group).  For now, we simply do not support providing context
            rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
            be worth providing --- if someone wants a 1/8th-size preview, they probably
            want it quick and dirty, so a context-free upsampler is sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_simple_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the simple case where no context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_context_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the case where context rows must be provided.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_crank_post(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            Final pass of two-pass quantization: just call the postprocessor.
            Source data will be the postprocessor controller's internal buffer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.alloc_funny_pointers">
            <summary>
            Allocate space for the funny pointer lists.
            This is done only once, not once per pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.make_funny_pointers">
            <summary>
            Create the funny pointer lists discussed in the comments above.
            The actual workspace is already allocated (in main.buffer),
            and the space for the pointer lists is allocated too.
            This routine just fills in the curiously ordered lists.
            This will be repeated at the beginning of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_wraparound_pointers">
            <summary>
            Set up the "wraparound" pointers at top and bottom of the pointer lists.
            This changes the pointer list state from top-of-image to the normal state.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_bottom_pointers">
            <summary>
            Change the pointer lists to duplicate the last sample row at the bottom
            of the image.  m_whichFunny indicates which m_funnyIndices holds the final iMCU row.
            Also sets rowgroups_avail to indicate number of nondummy row groups in row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller">
            <summary>
            Decompression postprocessing (color quantization buffer control)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Boolean)">
            <summary>
            Initialize postprocessing controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_1pass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the one-pass (strip buffer) case.
            This is used for color precision reduction as well as one-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_prepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Process some data in the first pass of 2-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_2pass(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the second pass of 2-pass quantization.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder">
            <summary>
            Entropy decoding
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder.jpeg_make_d_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder">
            <summary>
            Entropy encoding
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder.jpeg_make_c_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder.c_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            Compute the derived values for a Huffman table.
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder.jpeg_gen_optimal_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL,System.Int64[])">
            <summary>
            Generate the best Huffman code table for the given counts, fill htbl.
            
            The JPEG standard requires that no symbol be assigned a codeword of all
            one bits (so that padding bits added at the end of a compressed segment
            can't look like a valid code).  Because of the canonical ordering of
            codewords, this just means that there must be an unused slot in the
            longest codeword length category.  Section K.2 of the JPEG spec suggests
            reserving such a slot by pretending that symbol 256 is a valid symbol
            with count 1.  In theory that's not optimal; giving it count zero but
            including it in the symbol set anyway should give a better Huffman code.
            But the theoretically better code actually seems to come out worse in
            practice, because it produces more all-ones bytes (which incur stuffed
            zero bytes in the final file).  In any case the difference is tiny.
            
            The JPEG standard requires Huffman codes to be no more than 16 bits long.
            If some symbols have a very small but nonzero probability, the Huffman tree
            must be adjusted to meet the code length restriction.  We currently use
            the adjustment method suggested in JPEG section K.2.  This method is *not*
            optimal; it may not choose the best possible limited-length code.  But
            typically only very-low-frequency symbols will be given less-than-optimal
            lengths, so the code is almost optimal.  Experimental comparisons against
            an optimal limited-length-code algorithm indicate that the difference is
            microscopic --- usually less than a hundredth of a percent of total size.
            So the extra complexity of an optimal algorithm doesn't seem worthwhile.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct">
            <summary>
            Forward DCT (also controls coefficient quantization)
            
            A forward DCT routine is given a pointer to a work area of type DCTELEM[];
            the DCT is to be performed in-place in that buffer.  Type DCTELEM is int
            for 8-bit samples, int for 12-bit samples.  (NOTE: Floating-point DCT
            implementations use an array of type float, instead.)
            The DCT inputs are expected to be signed (range +-CENTERJSAMPLE).
            The DCT outputs are returned scaled up by a factor of 8; they therefore
            have a range of +-8K for 8-bit data, +-128K for 12-bit data. This
            convention improves accuracy in integer implementations and saves some
            work in floating-point ones.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.start_pass">
            <summary>
            Initialize for a processing pass.
            Verify that all referenced Q-tables are present, and set up
            the divisor table for each one.
            In the current implementation, DCT of all components is done during
            the first pass, even if only some components will be output in the
            first scan.  Hence all components should be examined here.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.forward_DCT(System.Int32,System.Byte[][],BitMiracle.LibJpeg.Classic.JBLOCK[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Perform forward DCT on one or more blocks of a component.
            
            The input samples are taken from the sample_data[] array starting at
            position start_row/start_col, and moving to the right for any additional
            blocks. The quantized coefficients are returned in coef_blocks[].
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_float(System.Single[])">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the 
            forward DCT (Discrete Cosine Transform).
            
            This implementation should be more accurate than either of the integer
            DCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_ifast(System.Int32[])">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            This file contains a fast, not so accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            see jpeg_fdct_islow for more details.  However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            Again to save a few shifts, the intermediate results between pass 1 and
            pass 2 are not upscaled, but are represented only to integral precision.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_islow(System.Int32[])">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A slow-but-accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D DCT step produces outputs which are a factor of sqrt(N)
            larger than the true DCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D DCT,
            because the y0 and y4 outputs need not be divided by sqrt(N).
            In the IJG code, this factor of 8 is removed by the quantization 
            step, NOT here.
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (For 12-bit sample data, the intermediate
            array is int anyway.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller">
            <summary>
            Input control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the input controller module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.reset_input_controller">
            <summary>
            Reset state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.start_input_pass">
            <summary>
            Initialize the input modules to read a scan of compressed data.
            The first call to this is done after initializing
            the entire decompressor (during jpeg_start_decompress).
            Subsequent calls come from consume_markers, below.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.finish_input_pass">
            <summary>
            Finish up after inputting a compressed-data scan.
            This is called by the coefficient controller after it's read all
            the expected data of the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.consume_markers">
            <summary>
            Read JPEG markers before, between, or after compressed-data scans.
            Change state as necessary when a new scan is reached.
            Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            The consume_input method pointer points either here or to the
            coefficient controller's consume_data routine, depending on whether
            we are reading a compressed data segment or inter-segment markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.initial_setup">
            <summary>
            Routines to calculate various quantities related to the size of the image.
            Called once, when first SOS marker is reached
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.latch_quant_tables">
            <summary>
            Save away a copy of the Q-table referenced by each component present
            in the current scan, unless already saved during a prior scan.
            
            In a multiple-scan JPEG file, the encoder could assign different components
            the same Q-table slot number, but change table definitions between scans
            so that each component uses a different Q-table.  (The IJG encoder is not
            currently capable of doing this, but other encoders might.)  Since we want
            to be able to dequantize all the components at the end of the file, this
            means that we have to save away the table actually used for each component.
            We do this by copying the table at the start of the first scan containing
            the component.
            The JPEG spec prohibits the encoder from changing the contents of a Q-table
            slot between scans of a component using that slot.  If the encoder does so
            anyway, this decoder will simply use the Q-table values that were current
            at the start of the first scan for the component.
            
            The decompressor output side looks only at the saved quant tables,
            not at the current Q-table slots.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] were set from SOS marker
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct">
            <summary>
            An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
            to an output sample array.  The routine must dequantize the input data as
            well as perform the IDCT; for dequantization, it uses the multiplier table
            pointed to by componentInfo.dct_table.  The output data is to be placed into the
            sample array starting at a specified column. (Any row offset needed will
            be applied to the array pointer before it is passed to the IDCT code)
            Note that the number of samples emitted by the IDCT routine is
            DCT_scaled_size * DCT_scaled_size.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            
            The decompressor input side saves away the appropriate
            quantization table for each component at the start of the first scan
            involving that component.  (This is necessary in order to correctly
            decode files that reuse Q-table slots.)
            When we are ready to make an output pass, the saved Q-table is converted
            to a multiplier table that will actually be used by the IDCT routine.
            The multiplier table contents are IDCT-method-dependent.  To support
            application changes in IDCT method between scans, we can remake the
            multiplier tables if necessary.
            In buffered-image mode, the first output pass may occur before any data
            has been seen for some components, and thus before their Q-tables have
            been saved away.  To handle this case, multiplier tables are preset
            to zeroes; the result of the IDCT will be a neutral gray level.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.start_pass">
            <summary>
            Prepare for an output pass.
            Here we select the proper IDCT routine for each component and build
            a matching multiplier table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_islow(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            A slow-but-accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
            larger than the true IDCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D IDCT,
            because the y0 and y4 inputs need not be divided by sqrt(N).
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (To scale up 12-bit sample data further, an
            intermediate int array would be needed.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.SLOW_INTEGER_DEQUANTIZE(System.Int32,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_ifast(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A fast, not so accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            The dequantized coefficients are not integers because the AA&amp;N scaling
            factors have been incorporated.  We represent them scaled up by FAST_INTEGER_PASS1_BITS,
            so that the first and second IDCT rounds have the same input scaling.
            For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = FAST_INTEGER_PASS1_BITS so as to
            avoid a descaling shift; this compromises accuracy rather drastically
            for small quantization table entries, but it saves a lot of shifts.
            For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
            so we use a much larger scaling factor to preserve accuracy.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
            multiplication will do.  For 12-bit data, the multiplier table is
            declared int, so a 32-bit multiply will be used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            Like DESCALE, but applies to a DCTELEM and produces an int.
            We assume that int right shift is unsigned if int right shift is.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_float(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            This implementation should be more accurate than either of the integer
            IDCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FLOAT_DEQUANTIZE(System.Int16,System.Single)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a float result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_4x4(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Inverse-DCT routines that produce reduced-size output:
            either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
            
            NOTE: this code only copes with 8x8 DCTs.
            
            The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&amp;M)
            algorithm. We simply replace each 8-to-8 1-D IDCT step
            with an 8-to-4 step that produces the four averages of two adjacent outputs
            (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
            These steps were derived by computing the corresponding values at the end
            of the normal LL&amp;M code, then simplifying as much as possible.
            
            1x1 is trivial: just take the DC coefficient divided by 8.
            
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 4x4 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_2x2(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 2x2 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_1x1(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 1x1 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.REDUCED_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader">
            <summary>
            Marker reading and parsing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the marker reader module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.reset_marker_reader">
            <summary>
            Reset marker processing state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_markers">
            <summary>
            Read markers until SOS or EOI.
            
            Returns same codes as are defined for jpeg_consume_input:
            JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_restart_marker">
            <summary>
            Read a restart marker, which is expected to appear next in the datastream;
            if the marker is not there, take appropriate recovery action.
            Returns false if suspension is required.
            
            Made public for use by entropy decoder only
            
            This is called by the entropy decoder after it has read an appropriate
            number of MCUs.  cinfo.unread_marker may be nonzero if the entropy decoder
            has already read a marker from the data source.  Under normal conditions
            cinfo.unread_marker will be reset to 0 before returning; if not reset,
            it holds a marker which the decoder will be unable to read past.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.next_marker">
            <summary>
            Find the next JPEG marker, save it in cinfo.unread_marker.
            Returns false if had to suspend before reaching a marker;
            in that case cinfo.unread_marker is unchanged.
            
            Note that the result might not be a valid marker code,
            but it will never be 0 or FF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Install a special processing method for COM or APPn markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.save_marker(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Save an APPn or COM marker into the marker list
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.skip_variable(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Skip over an unknown or uninteresting variable-length marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_interesting_appn(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Process an APP0 or APP14 marker without saving it
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app0(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP0.
            Take appropriate action if it is a JFIF marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app14(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP14.
            Take appropriate action if it is an Adobe marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_soi">
            <summary>
            Process an SOI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sof(System.Boolean)">
            <summary>
            Process a SOFn marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sos">
            <summary>
            Process a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dht">
            <summary>
            Process a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dqt">
            <summary>
            Process a DQT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dri">
            <summary>
            Process a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.first_marker">
            <summary>
            Like next_marker, but used to obtain the initial SOI marker.
            For this marker, we do not allow preceding garbage or fill; otherwise,
            we might well scan an entire input file before realizing it ain't JPEG.
            If an application wants to process non-JFIF files, it must seek to the
            SOI before calling the JPEG library.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer">
            <summary>
            Marker writing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_header">
            <summary>
            Write datastream header.
            This consists of an SOI and optional APPn markers.
            We recommend use of the JFIF marker, but not the Adobe marker,
            when using YCbCr or grayscale data.  The JFIF marker should NOT
            be used for any other JPEG colorspace.  The Adobe marker is helpful
            to distinguish RGB, CMYK, and YCCK colorspaces.
            Note that an application can write additional header markers after
            jpeg_start_compress returns.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_frame_header">
            <summary>
            Write frame header.
            This consists of DQT and SOFn markers.
            Note that we do not emit the SOF until we have emitted the DQT(s).
            This avoids compatibility problems with incorrect implementations that
            try to error-check the quant table numbers as soon as they see the SOF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_scan_header">
            <summary>
            Write scan header.
            This consists of DHT or DAC markers, optional DRI, and SOS.
            Compressed data will be written following the SOS.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_trailer">
            <summary>
            Write datastream trailer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_tables_only">
            <summary>
            Write an abbreviated table-specification datastream.
            This consists of SOI, DQT and DHT tables, and EOI.
            Any table that is defined and not marked sent_table = true will be
            emitted.  Note that all tables will be marked sent_table = true at exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_header(System.Int32,System.Int32)">
            <summary>
            Emit an arbitrary marker header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_byte(System.Byte)">
            <summary>
            Emit one byte of marker parameters following write_marker_header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sos">
            <summary>
            Emit a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sof(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a SOF marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_adobe_app14">
            <summary>
            Emit an Adobe APP14 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dri">
            <summary>
            Emit a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dht(System.Int32,System.Boolean)">
            <summary>
            Emit a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dqt(System.Int32)">
            <summary>
            Emit a DQT marker
            </summary>
            <param name="index">The index.</param>
            <returns>the precision used (0 = 8bits, 1 = 16bits) for baseline checking</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_jfif_app0">
            <summary>
            Emit a JFIF-compliant APP0 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_marker(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a marker code
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_2bytes(System.Int32)">
            <summary>
            Emit a 2-byte integer; these are always MSB first in JPEG files
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_byte(System.Int32)">
            <summary>
            Emit a byte
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info">
            <summary>
            The script for encoding a multiple-scan file is an array of these:
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler">
            <summary>
            Upsampling (note that upsampler must also call color converter)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE">
            <summary>
            Operating modes for buffer controllers
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer">
            <summary>
            The main purpose of 1-pass quantization is to provide a fast, if not very
            high quality, colormapped output capability.  A 2-pass quantizer usually
            gives better visual quality; however, for quantized grayscale output this
            quantizer is perfectly adequate.  Dithering is highly recommended with this
            quantizer, though you can turn it off if you really want to.
            
            In 1-pass quantization the colormap must be chosen in advance of seeing the
            image.  We use a map consisting of all combinations of Ncolors[i] color
            values for the i'th component.  The Ncolors[] values are chosen so that
            their product, the total number of colors, is no more than that requested.
            (In most cases, the product will be somewhat less.)
            
            Since the colormap is orthogonal, the representative value for each color
            component can be determined without considering the other components;
            then these indexes can be combined into a colormap index by a standard
            N-dimensional-array-subscript calculation.  Most of the arithmetic involved
            can be precalculated and stored in the lookup table colorindex[].
            colorindex[i][j] maps pixel value j in component i to the nearest
            representative value (grid plane) for that component; this index is
            multiplied by the array stride for component i, so that the
            index of the colormap entry closest to a given pixel value is just
                sum( colorindex[component-number][pixel-component-value] )
            Aside from being fast, this scheme allows for variable spacing between
            representative values with no additional lookup cost.
            
            If gamma correction has been applied in color conversion, it might be wise
            to adjust the color grid spacing so that the representative colors are
            equidistant in linear space.  At this writing, gamma correction is not
            implemented, so nothing is done here.
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ...	(here)	7/16
               3/16	5/16	1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array is indexed [component#][position].
            We provide (#columns + 2) entries per component; the extra entry at each
            end saves us from special-casing the first and last pixels.
            
            
            Declarations for ordered dithering.
            
            We use a standard 16x16 ordered dither array.  The basic concept of ordered
            dithering is described in many references, for instance Dale Schumacher's
            chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
            In place of Schumacher's comparisons against a "threshold" value, we add a
            "dither" value to the input pixel and then round the result to the nearest
            output value.  The dither value is equivalent to (0.5 - threshold) times
            the distance between output values.  For ordered dithering, we assume that
            the output colors are equally spaced; if not, results will probably be
            worse, since the dither may be too much or too little at a given point.
            
            The normal calculation would be to form pixel value + dither, range-limit
            this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
            We can skip the separate range-limiting step by extending the colorindex
            table in both directions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 1-pass color quantization.
            </summary>
            <param name="cinfo">The cinfo.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for one-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.finish_pass">
            <summary>
            Finish up at the end of the pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            Shouldn't get to this!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, no dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with ordered dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, with ordered dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colormap">
            <summary>
            Create the colormap.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colorindex">
            <summary>
            Create the color index table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_odither_tables">
            <summary>
            Create the ordered-dither tables.
            Components having the same number of representative colors may 
            share a dither table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.alloc_fs_workspace">
            <summary>
            Allocate workspace for Floyd-Steinberg errors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.largest_input_value(System.Int32,System.Int32)">
            <summary>
            Return largest input value that should map to j'th output value
            Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.output_value(System.Int32,System.Int32)">
            <summary>
            Return j'th output value, where j will range from 0 to maxj
            The output values must fall in 0..MAXJSAMPLE in increasing order
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.select_ncolors(System.Int32[])">
            <summary>
            Determine allocation of desired colors to components,
            and fill in Ncolors[] array to indicate choice.
            Return value is total number of colors (product of Ncolors[] values).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.make_odither_array(System.Int32)">
            <summary>
            Create an ordered-dither array for a component having ncolors
            distinct output values.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer">
            <summary>
            This module implements the well-known Heckbert paradigm for color
            quantization.  Most of the ideas used here can be traced back to
            Heckbert's seminal paper
            Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
            Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
            
            In the first pass over the image, we accumulate a histogram showing the
            usage count of each possible color.  To keep the histogram to a reasonable
            size, we reduce the precision of the input; typical practice is to retain
            5 or 6 bits per color, so that 8 or 4 different input values are counted
            in the same histogram cell.
            
            Next, the color-selection step begins with a box representing the whole
            color space, and repeatedly splits the "largest" remaining box until we
            have as many boxes as desired colors.  Then the mean color in each
            remaining box becomes one of the possible output colors.
            
            The second pass over the image maps each input pixel to the closest output
            color (optionally after applying a Floyd-Steinberg dithering correction).
            This mapping is logically trivial, but making it go fast enough requires
            considerable care.
            
            Heckbert-style quantizers vary a good deal in their policies for choosing
            the "largest" box and deciding where to cut it.  The particular policies
            used here have proved out well in experimental comparisons, but better ones
            may yet be found.
            
            In earlier versions of the IJG code, this module quantized in YCbCr color
            space, processing the raw upsampled data without a color conversion step.
            This allowed the color conversion math to be done only once per colormap
            entry, not once per pixel.  However, that optimization precluded other
            useful optimizations (such as merging color conversion with upsampling)
            and it also interfered with desired capabilities such as quantizing to an
            externally-supplied colormap.  We have therefore abandoned that approach.
            The present code works in the post-conversion color space, typically RGB.
            
            To improve the visual quality of the results, we actually work in scaled
            RGB space, giving G distances more weight than R, and R in turn more than
            B.  To do everything in integer math, we must use integer scale factors.
            The 2/3/1 scale factors used here correspond loosely to the relative
            weights of the colors in the NTSC grayscale equation.
            If you want to use this code to quantize a non-RGB color space, you'll
            probably need to change these scale factors.
            
            First we have the histogram data structure and routines for creating it.
            
            The number of bits of precision can be adjusted by changing these symbols.
            We recommend keeping 6 bits for G and 5 each for R and B.
            If you have plenty of memory and cycles, 6 bits all around gives marginally
            better results; if you are short of memory, 5 bits all around will save
            some space but degrade the results.
            To maintain a fully accurate histogram, we'd need to allocate a "long"
            (preferably unsigned long) for each cell.  In practice this is overkill;
            we can get by with 16 bits per cell.  Few of the cell counts will overflow,
            and clamping those that do overflow to the maximum value will give close-
            enough results.  This reduces the recommended histogram size from 256Kb
            to 128Kb, which is a useful savings on PC-class machines.
            (In the second pass the histogram space is re-used for pixel mapping data;
            in that capacity, each cell must be able to store zero to the number of
            desired colors.  16 bits/cell is plenty for that too.)
            Since the JPEG code is intended to run in small memory model on 80x86
            machines, we can't just allocate the histogram in one chunk.  Instead
            of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
            pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
            each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
            on 80x86 machines, the pointer row is in near memory but the actual
            arrays are in far memory (same arrangement as we use for image arrays).
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ... (here)  7/16
            3/16    5/16    1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array has (#columns + 2) entries; the extra entry at
            each end saves us from special-casing the first and last pixels.
            Each entry is three values long, one value for each color component.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 2-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for each processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.prescan_quantize(System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Prescan some rows of pixels.
            In this module the prescan simply updates the histogram, which has been
            initialized to zeroes by start_pass.
            An output_buf parameter is required by the method signature, but no data
            is actually output (in fact the buffer controller is probably passing a
            null pointer).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_no_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.finish_pass1">
            <summary>
            Finish up at the end of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.compute_color(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Compute representative color for a box, put it in colormap[icolor]
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.select_colors(System.Int32)">
            <summary>
            Master routine for color selection
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.median_cut(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Repeatedly select and split the largest box until we have enough boxes
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_color_pop(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest color population
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_volume(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest (scaled) volume
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.update_box(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Shrink the min/max bounds of a box to enclose only nonzero elements,
            and recompute its volume and population
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.init_error_limit">
            <summary>
            Initialize the error-limiting transfer function (lookup table).
            The raw F-S error computation can potentially compute error values of up to
            +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
            much less, otherwise obviously wrong pixels will be created.  (Typical
            effects include weird fringes at color-area boundaries, isolated bright
            pixels in a dark area, etc.)  The standard advice for avoiding this problem
            is to ensure that the "corners" of the color cube are allocated as output
            colors; then repeated errors in the same direction cannot cause cascading
            error buildup.  However, that only prevents the error from getting
            completely out of hand; Aaron Giles reports that error limiting improves
            the results even with corner colors allocated.
            A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
            well, but the smoother transfer function used below is even better.  Thanks
            to Aaron Giles for this idea.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_nearby_colors(System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Locate the colormap entries close enough to an update box to be candidates
            for the nearest entry to some cell(s) in the update box.  The update box
            is specified by the center coordinates of its first cell.  The number of
            candidate colormap entries is returned, and their colormap indexes are
            placed in colorlist[].
            This routine uses Heckbert's "locally sorted search" criterion to select
            the colors that need further consideration.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_best_colors(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Find the closest colormap entry for each cell in the update box,
            given the list of candidate colors prepared by find_nearby_colors.
            Return the indexes of the closest entries in the bestcolor[] array.
            This routine uses Thomas' incremental distance calculation method to
            find the distance from a colormap entry to successive cells in the box.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.fill_inverse_cmap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fill the inverse-colormap entries in the update box that contains
            histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but
            we can fill as many others as we wish.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressDataImpl(System.Byte[][][])">
            <summary>
            Process some data in the single-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressFirstPass(System.Byte[][][])">
            <summary>
            Process some data in the first pass of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            This amount of data is read from the source buffer, DCT'd and quantized,
            and saved into the virtual arrays.  We also generate suitable dummy blocks
            as needed at the right and lower edges.  (The dummy blocks are constructed
            in the virtual arrays, which have been padded appropriately.)  This makes
            it possible for subsequent passes not to worry about real vs. dummy blocks.
            
            We must also emit the data to the entropy encoder.  This is conveniently
            done by calling compress_output() after we've loaded the current strip
            of the virtual arrays.
            
            NB: input_buf contains a plane for each component in image.  All
            components are DCT'd and loaded into the virtual arrays in this pass.
            However, it may be that only a subset of the components are emitted to
            the entropy encoder during this first pass; be careful about looking
            at the scan-dependent variables (MCU dimensions, etc).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressOutput">
            <summary>
            Process some data in subsequent passes of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr">
            <summary>
            Expanded data destination object for output to Stream
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.init_destination">
            <summary>
            Initialize destination --- called by jpeg_start_compress
            before any data is actually written.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.empty_output_buffer">
            <summary>
            Empty the output buffer --- called whenever buffer fills up.
            
            In typical applications, this should write the entire output buffer
            (ignoring the current state of next_output_byte and free_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been dumped.
            
            In applications that need to be able to suspend compression due to output
            overrun, a false return indicates that the buffer cannot be emptied now.
            In this situation, the compressor will return to its caller (possibly with
            an indication that it has not accepted all the supplied scanlines).  The
            application should resume compression after it has made more room in the
            output buffer.  Note that there are substantial restrictions on the use of
            suspension --- see the documentation.
            
            When suspending, the compressor will back up to a convenient restart point
            (typically the start of the current MCU). next_output_byte and free_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point will be regenerated after resumption, so do not
            write it out when emptying the buffer externally.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.term_destination">
            <summary>
            Terminate destination --- called by jpeg_finish_compress
            after all data has been written.  Usually needs to flush buffer.
            
            NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_1v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            1:1 vertical sampling case: much easier, never need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_2v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            2:1 vertical sampling case: may need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v1_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v2_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][])">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCC->RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr">
            <summary>
            Expanded data source object for stdio input
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize source - called by jpeg_read_header
            before any data is actually read.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.fill_input_buffer">
            <summary>
            Fill the input buffer - called whenever buffer is emptied.
            
            In typical applications, this should read fresh data into the buffer
            (ignoring the current state of next_input_byte and bytes_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been reloaded.  It is not necessary to
            fill the buffer entirely, only to obtain at least one more byte.
            
            There is no such thing as an EOF return.  If the end of the file has been
            reached, the routine has a choice of ERREXIT() or inserting fake data into
            the buffer.  In most cases, generating a warning message and inserting a
            fake EOI marker is the best course of action --- this will allow the
            decompressor to output however much of the image is there.  However,
            the resulting error message is misleading if the real problem is an empty
            input file, so we handle that case specially.
            
            In applications that need to be able to suspend compression due to input
            not being available yet, a false return indicates that no more data can be
            obtained right now, but more may be forthcoming later.  In this situation,
            the decompressor will return to its caller (with an indication of the
            number of scanlines it has read, if any).  The application should resume
            decompression after it has loaded more data into the input buffer.  Note
            that there are substantial restrictions on the use of suspension --- see
            the documentation.
            
            When suspending, the decompressor will back up to a convenient restart point
            (typically the start of the current MCU). next_input_byte and bytes_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point must be rescanned after resumption, so move it to
            the front of the buffer rather than discarding it.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller">
            <summary>
            This is a special implementation of the coefficient
            buffer controller.  This is similar to jccoefct.c, but it handles only
            output from presupplied virtual arrays.  Furthermore, we generate any
            dummy padding blocks on-the-fly rather than expecting them to be present
            in the arrays.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_compress_struct,BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Initialize coefficient buffer controller.
            
            Each passed coefficient array must be the right size for that
            coefficient: width_in_blocks wide and height_in_blocks high,
            with unit height at least v_samp_factor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.compress_data(System.Byte[][][])">
            <summary>
            Process some data.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf is ignored; it is likely to be a null pointer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            
            In this version we upsample each component independently.
            We upsample one row group into the conversion buffer, then apply
            color conversion a row at a time.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.noop_upsample">
            <summary>
            This is a no-op version used for "uninteresting" components.
            These components will not be referenced by color conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.fullsize_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            For full-size components, we just make color_buf[ci] point at the
            input buffer, and thus avoid copying any data.  Note that this is
            safe only because sep_upsample doesn't declare the input row group
            "consumed" until we are done color converting and emitting it.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_fancy_upsample(System.Int32,BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
            
            The upsampling algorithm is linear interpolation between pixel centers,
            also known as a "triangle filter".  This is a good compromise between
            speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
            of the way between input pixel centers.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_fancy_upsample(System.Int32,BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
            Again a triangle filter; see comments for h2v1 case, above.
            
            It is OK for us to reference the adjacent input rows because we demanded
            context from the main buffer controller (see initialization code).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.int_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer@)">
            <summary>
            This version handles any integral sampling ratios.
            This is not used for typical JPEG files, so it need not be fast.
            Nor, for that matter, is it particularly accurate: the algorithm is
            simple replication of the input pixel onto the corresponding output
            pixels.  The hi-falutin sampling literature refers to this as a
            "box filter".  A box filter tends to introduce visible artifacts,
            so if you are actually going to use 3:1 or 4:1 sampling ratios
            you would be well advised to improve this code.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for progressive Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.decode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.decode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.decode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_decoder.undo_decode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[],System.Int32[],System.Int32)">
            <summary>
            MCU decoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for progressive Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.encode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.encode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.encode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.encode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.finish_pass_phuff">
            <summary>
            Finish up at the end of a Huffman-compressed progressive scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.finish_pass_gather_phuff">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.emit_bits(System.Int32,System.Int32)">
            <summary>
            Outputting bits to the file
            
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.phuff_entropy_encoder.IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than int.
            We assume that int right shift is unsigned if int right shift is,
            which should be safe.
            </summary>
        </member>
    </members>
</doc>
